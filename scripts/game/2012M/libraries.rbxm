<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Script" referent="RBX0">
		<Properties>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">Sorter</string>
			<ProtectedString name="Source">print(&quot;Special thanks to Bitl, Carrot, iago, winsupermario1234, Khangaroo, drslicendice, coke, TheLivingBee, Raymonf, and a bunch of play - testers for help making 2012 fully stable and work. 8)&quot;)
script.Backpack:clone().Parent = game.StarterGui
script.ResetCommand:clone().Parent = game.Workspace
script:remove()</ProtectedString>
		</Properties>
		<Item class="Script" referent="RBX1">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ResetCommand</string>
				<ProtectedString name="Source">function onChatted(msg, speaker)
    
    source = string.lower(speaker.Name)
    msg = string.lower(msg)
    -- Note: This one is NOT caps sensitive

    if msg == &quot;!!!reset&quot; then
        speaker.Character.Humanoid.Health = 0
    end
end

function onPlayerEntered(newPlayer)
        newPlayer.Chatted:connect(function(msg) onChatted(msg, newPlayer) end) 
end
 
game.Players.ChildAdded:connect(onPlayerEntered)</ProtectedString>
			</Properties>
		</Item>
		<Item class="ScreenGui" referent="RBX2">
			<Properties>
				<string name="Name">Backpack</string>
			</Properties>
			<Item class="LocalScript" referent="RBX3">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">BackpackBuilder</string>
					<ProtectedString name="Source">--rbxsig%IEUAo3Q1k4Rwb3ZcqPBum//j3+Jm/9Nv0JyCeCRWUrggWps7aG81/aPzlH9pPlMkkdsZwLsCRu6eTTrqzXn2DAJNPRs7y8akc3z91r1DP3jwomfpdT+2DBAmPk3Cdj8NXQzP6T+uEYm2kk2TW9pXonKvCgRVqXFx8J7mTr+aM1M=%
--rbxassetid%45284430%
local t = {}

local function ScopedConnect(parentInstance, instance, event, signalFunc, syncFunc, removeFunc)
&#9;local eventConnection = nil

&#9;--Connection on parentInstance is scoped by parentInstance (when destroyed, it goes away)
&#9;local tryConnect = function()
&#9;&#9;if game:IsAncestorOf(parentInstance) then
&#9;&#9;&#9;--Entering the world, make sure we are connected/synced
&#9;&#9;&#9;if not eventConnection then
&#9;&#9;&#9;&#9;eventConnection = instance[event]:connect(signalFunc)
&#9;&#9;&#9;&#9;if syncFunc then syncFunc() end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;--Probably leaving the world, so disconnect for now
&#9;&#9;&#9;if eventConnection then
&#9;&#9;&#9;&#9;eventConnection:disconnect()
&#9;&#9;&#9;&#9;if removeFunc then removeFunc() end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;--Hook it up to ancestryChanged signal
&#9;local connection = parentInstance.AncestryChanged:connect(tryConnect)
&#9;
&#9;--Now connect us if we&apos;re already in the world
&#9;tryConnect()
&#9;
&#9;return connection
end

local function getScreenGuiAncestor(instance)
&#9;local localInstance = instance
&#9;while localInstance and not localInstance:IsA(&quot;ScreenGui&quot;) do
&#9;&#9;localInstance = localInstance.Parent
&#9;end
&#9;return localInstance
end

local function CreateButtons(frame, buttons, yPos, ySize)
&#9;local buttonNum = 1
&#9;local buttonObjs = {}
&#9;for i, obj in ipairs(buttons) do 
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot; .. buttonNum
&#9;&#9;button.Font = Enum.Font.Arial
&#9;&#9;button.FontSize = Enum.FontSize.Size18
&#9;&#9;button.AutoButtonColor = true
&#9;&#9;button.Modal = true
&#9;&#9;if obj[&quot;Style&quot;] then
&#9;&#9;&#9;button.Style = obj.Style
&#9;&#9;else
&#9;&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;end
&#9;&#9;button.Text = obj.Text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.MouseButton1Click:connect(obj.Function)
&#9;&#9;button.Parent = frame
&#9;&#9;buttonObjs[buttonNum] = button

&#9;&#9;buttonNum = buttonNum + 1
&#9;end
&#9;local numButtons = buttonNum-1

&#9;if numButtons == 1 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.35, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.4,0,ySize.Scale, ySize.Offset)
&#9;elseif numButtons == 2 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.1, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.8/3,0, ySize.Scale, ySize.Offset)

&#9;&#9;frame.Button2.Position = UDim2.new(0.55, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button2.Size = UDim2.new(.35,0, ySize.Scale, ySize.Offset)
&#9;elseif numButtons &gt;= 3 then
&#9;&#9;local spacing = .1 / numButtons
&#9;&#9;local buttonSize = .9 / numButtons

&#9;&#9;buttonNum = 1
&#9;&#9;while buttonNum &lt;= numButtons do
&#9;&#9;&#9;buttonObjs[buttonNum].Position = UDim2.new(spacing*buttonNum + (buttonNum-1) * buttonSize, 0, yPos.Scale, yPos.Offset)
&#9;&#9;&#9;buttonObjs[buttonNum].Size = UDim2.new(buttonSize, 0, ySize.Scale, ySize.Offset)
&#9;&#9;&#9;buttonNum = buttonNum + 1
&#9;&#9;end
&#9;end
end

local function setSliderPos(newAbsPosX,slider,sliderPosition,bar,steps)

&#9;local newStep = steps - 1 --otherwise we really get one more step than we want
&#9;local relativePosX = math.min(1, math.max(0, (newAbsPosX - bar.AbsolutePosition.X) / bar.AbsoluteSize.X ))
&#9;local wholeNum, remainder = math.modf(relativePosX * newStep)
&#9;if remainder &gt; 0.5 then
&#9;&#9;wholeNum = wholeNum + 1
&#9;end
&#9;relativePosX = wholeNum/newStep

&#9;local result = math.ceil(relativePosX * newStep)
&#9;if sliderPosition.Value ~= (result + 1) then --only update if we moved a step
&#9;&#9;sliderPosition.Value = result + 1
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end
&#9;
end

local function cancelSlide(areaSoak)
&#9;areaSoak.Visible = false
&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
end

t.CreateStyledMessageDialog = function(title, message, style, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0, 165)
&#9;frame.Position = UDim2.new(0.25, 0, 0.5, -72.5)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound&#9;
&#9;
&#9;local styleImage = Instance.new(&quot;ImageLabel&quot;)
&#9;styleImage.Name = &quot;StyleImage&quot;
&#9;styleImage.BackgroundTransparency = 1
&#9;styleImage.Position = UDim2.new(0,5,0,15)
&#9;if style == &quot;error&quot; or style == &quot;Error&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;rbxasset://ui/error.png&quot;
&#9;elseif style == &quot;notify&quot; or style == &quot;Notify&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;rbxasset://ui/notify.png&quot;
&#9;elseif style == &quot;confirm&quot; or style == &quot;Confirm&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 74, 0, 76)
&#9;&#9;styleImage.Image = &quot;rbxasset://ui/confirm.png&quot;
&#9;else
&#9;&#9;return t.CreateMessageDialog(title,message,buttons)
&#9;end
&#9;styleImage.Parent = frame
&#9;
&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.TextStrokeTransparency = 0
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 80, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, -80, 0, 40)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextStrokeTransparency = 0
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 80, 0, 45)
&#9;messageLabel.Size = UDim2.new(0.95, -80, 0, 55)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0, 105), UDim.new(0, 40) )

&#9;return frame
end

t.CreateMessageDialog = function(title, message, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0.5, 0)
&#9;frame.Position = UDim2.new(0.25, 0, 0.25, 0)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound

&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 0, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, 0, 0.15, 0)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 0, 0.175, 0)
&#9;messageLabel.Size = UDim2.new(0.95, 0, .55, 0)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0.8,0), UDim.new(0.15, 0))

&#9;return frame
end

t.CreateDropDownMenu = function(items, onSelect, forRoblox)
&#9;local width = UDim.new(0, 100)
&#9;local height = UDim.new(0, 32)

&#9;local xPos = 0.055
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;DropDownMenu&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(width, height)

&#9;local dropDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;dropDownMenu.Name = &quot;DropDownMenuButton&quot;
&#9;dropDownMenu.TextWrap = true
&#9;dropDownMenu.TextColor3 = Color3.new(1,1,1)
&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;dropDownMenu.Font = Enum.Font.ArialBold
&#9;dropDownMenu.FontSize = Enum.FontSize.Size18
&#9;dropDownMenu.TextXAlignment = Enum.TextXAlignment.Left
&#9;dropDownMenu.TextYAlignment = Enum.TextYAlignment.Center
&#9;dropDownMenu.BackgroundTransparency = 1
&#9;dropDownMenu.AutoButtonColor = true
&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;dropDownMenu.Size = UDim2.new(1,0,1,0)
&#9;dropDownMenu.Parent = frame
&#9;dropDownMenu.ZIndex = 2

&#9;local dropDownIcon = Instance.new(&quot;ImageLabel&quot;)
&#9;dropDownIcon.Name = &quot;Icon&quot;
&#9;dropDownIcon.Active = false
&#9;dropDownIcon.Image = &quot;rbxasset://ui/dropdownicon.png&quot;
&#9;dropDownIcon.BackgroundTransparency = 1
&#9;dropDownIcon.Size = UDim2.new(0,11,0,6)
&#9;dropDownIcon.Position = UDim2.new(1,-11,0.5, -2)
&#9;dropDownIcon.Parent = dropDownMenu
&#9;dropDownIcon.ZIndex = 2
&#9;
&#9;local itemCount = #items
&#9;local dropDownItemCount = #items
&#9;local useScrollButtons = false
&#9;if dropDownItemCount &gt; 6 then
&#9;&#9;useScrollButtons = true
&#9;&#9;dropDownItemCount = 6
&#9;end
&#9;
&#9;local droppedDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;droppedDownMenu.Name = &quot;List&quot;
&#9;droppedDownMenu.Text = &quot;&quot;
&#9;droppedDownMenu.BackgroundTransparency = 1
&#9;--droppedDownMenu.AutoButtonColor = true
&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;droppedDownMenu.Visible = false
&#9;droppedDownMenu.Active = true&#9;--Blocks clicks
&#9;droppedDownMenu.Position = UDim2.new(0,0,0,0)
&#9;droppedDownMenu.Size = UDim2.new(1,0, (1 + dropDownItemCount)*.8, 0)
&#9;droppedDownMenu.Parent = frame
&#9;droppedDownMenu.ZIndex = 2

&#9;local choiceButton = Instance.new(&quot;TextButton&quot;)
&#9;choiceButton.Name = &quot;ChoiceButton&quot;
&#9;choiceButton.BackgroundTransparency = 1
&#9;choiceButton.BorderSizePixel = 0
&#9;choiceButton.Text = &quot;ReplaceMe&quot;
&#9;choiceButton.TextColor3 = Color3.new(1,1,1)
&#9;choiceButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;choiceButton.TextYAlignment = Enum.TextYAlignment.Center
&#9;choiceButton.BackgroundColor3 = Color3.new(1, 1, 1)
&#9;choiceButton.Font = Enum.Font.Arial
&#9;choiceButton.FontSize = Enum.FontSize.Size18
&#9;if useScrollButtons then
&#9;&#9;choiceButton.Size = UDim2.new(1,-13, .8/((dropDownItemCount + 1)*.8),0) 
&#9;else
&#9;&#9;choiceButton.Size = UDim2.new(1, 0, .8/((dropDownItemCount + 1)*.8),0) 
&#9;end
&#9;choiceButton.TextWrap = true
&#9;choiceButton.ZIndex = 2

&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = true
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 3

&#9;local dropDownSelected = false

&#9;local scrollUpButton 
&#9;local scrollDownButton
&#9;local scrollMouseCount = 0

&#9;local setZIndex = function(baseZIndex)
&#9;&#9;droppedDownMenu.ZIndex = baseZIndex +1
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex + 2
&#9;&#9;&#9;&#9;elseif child.Name == &quot;ClickCaptureButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollBarPosition = 1
&#9;local updateScroll = function()
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.Active = scrollBarPosition &gt; 1 
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.Active = scrollBarPosition + dropDownItemCount &lt;= itemCount 
&#9;&#9;end

&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if not children then return end

&#9;&#9;local childNum = 1&#9;&#9;&#9;
&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;if childNum &lt; scrollBarPosition or childNum &gt;= scrollBarPosition + dropDownItemCount then
&#9;&#9;&#9;&#9;&#9;obj.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;obj.Position = UDim2.new(0,0,((childNum-scrollBarPosition+1)*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;&#9;&#9;&#9;obj.Visible = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;obj.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;obj.BackgroundTransparency = 1

&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;local toggleVisibility = function()
&#9;&#9;dropDownSelected = not dropDownSelected

&#9;&#9;areaSoak.Visible = not areaSoak.Visible
&#9;&#9;dropDownMenu.Visible = not dropDownSelected
&#9;&#9;droppedDownMenu.Visible = dropDownSelected
&#9;&#9;if dropDownSelected then
&#9;&#9;&#9;setZIndex(4)
&#9;&#9;else
&#9;&#9;&#9;setZIndex(2)
&#9;&#9;end
&#9;&#9;if useScrollButtons then
&#9;&#9;&#9;updateScroll()
&#9;&#9;end
&#9;end
&#9;droppedDownMenu.MouseButton1Click:connect(toggleVisibility)

&#9;local updateSelection = function(text)
&#9;&#9;local foundItem = false
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;local childNum = 1
&#9;&#9;if children then
&#9;&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;if obj.Text == text then
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;&#9;foundItem = true&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;scrollBarPosition = childNum
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if not text then
&#9;&#9;&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;&#9;&#9;scrollBarPosition = 1
&#9;&#9;else
&#9;&#9;&#9;if not foundItem then
&#9;&#9;&#9;&#9;error(&quot;Invalid Selection Update -- &quot; .. text)
&#9;&#9;&#9;end

&#9;&#9;&#9;if scrollBarPosition + dropDownItemCount &gt; itemCount + 1 then
&#9;&#9;&#9;&#9;scrollBarPosition = itemCount - dropDownItemCount + 1
&#9;&#9;&#9;end

&#9;&#9;&#9;dropDownMenu.Text = text
&#9;&#9;end
&#9;end
&#9;
&#9;local function scrollDown()
&#9;&#9;if scrollBarPosition + dropDownItemCount &lt;= itemCount then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition + 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;local function scrollUp()
&#9;&#9;if scrollBarPosition &gt; 1 then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition - 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;
&#9;if useScrollButtons then
&#9;&#9;--Make some scroll buttons
&#9;&#9;scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;&#9;scrollUpButton.BackgroundTransparency = 1
&#9;&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollUpButton.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;scrollUpButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;
&#9;&#9;&#9;&#9;scrollUp()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollUp() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)

&#9;&#9;scrollUpButton.Parent = droppedDownMenu

&#9;&#9;scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;&#9;scrollDownButton.BackgroundTransparency = 1
&#9;&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollDownButton.Position = UDim2.new(1,-11,1,-11)
&#9;&#9;scrollDownButton.Parent = droppedDownMenu
&#9;&#9;scrollDownButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1

&#9;&#9;&#9;&#9;scrollDown()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollDown() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)&#9;

&#9;&#9;local scrollbar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;&#9;scrollbar.BackgroundTransparency = 1
&#9;&#9;scrollbar.Size = UDim2.new(0, 18, (dropDownItemCount*.8)/((dropDownItemCount+1)*.8), -(17) - 11 - 4)
&#9;&#9;scrollbar.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),17+2)
&#9;&#9;scrollbar.Parent = droppedDownMenu
&#9;end

&#9;for i,item in ipairs(items) do
&#9;&#9;-- needed to maintain local scope for items in event listeners below
&#9;&#9;local button = choiceButton:clone()
&#9;&#9;if forRoblox then
&#9;&#9;&#9;button.RobloxLocked = true
&#9;&#9;end&#9;&#9;
&#9;&#9;button.Text = item
&#9;&#9;button.Parent = droppedDownMenu
&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;button.BackgroundTransparency = 1

&#9;&#9;&#9;updateSelection(item)
&#9;&#9;&#9;onSelect(item)

&#9;&#9;&#9;toggleVisibility()
&#9;&#9;end)
&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;--Add Highlight&#9;
&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)

&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)
&#9;end

&#9;--This does the initial layout of the buttons&#9;
&#9;updateScroll()
&#9;
&#9;frame.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(frame)
&#9;&#9;end
&#9;end)

&#9;dropDownMenu.MouseButton1Click:connect(toggleVisibility)
&#9;areaSoak.MouseButton1Click:connect(toggleVisibility)
&#9;return frame, updateSelection
end

t.CreatePropertyDropDownMenu = function(instance, property, enum)

&#9;local items = enum:GetEnumItems()
&#9;local names = {}
&#9;local nameToItem = {}
&#9;for i,obj in ipairs(items) do
&#9;&#9;names[i] = obj.Name
&#9;&#9;nameToItem[obj.Name] = obj
&#9;end

&#9;local frame
&#9;local updateSelection
&#9;frame, updateSelection = t.CreateDropDownMenu(names, function(text) instance[property] = nameToItem[text] end)

&#9;ScopedConnect(frame, instance, &quot;Changed&quot;, 
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == property then
&#9;&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;&#9;end
&#9;&#9;end,
&#9;&#9;function()
&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;end)

&#9;return frame
end

t.GetFontHeight = function(font, fontSize)
&#9;if font == nil or fontSize == nil then
&#9;&#9;error(&quot;Font and FontSize must be non-nil&quot;)
&#9;end

&#9;if font == Enum.Font.Legacy then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 15
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 17
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 21
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 27
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 54
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 72
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;elseif font == Enum.Font.Arial or font == Enum.Font.ArialBold then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 8
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 9
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 10
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 11
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 24
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 48
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;error(&quot;Unknown Font &quot; .. font)
&#9;end
end

local function layoutGuiObjectsHelper(frame, guiObjects, settingsTable)
&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;local pixelsRemaining = frame.AbsoluteSize.Y
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if child:IsA(&quot;TextLabel&quot;) or child:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;local isLabel = child:IsA(&quot;TextLabel&quot;)
&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;end
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, pixelsRemaining)

&#9;&#9;&#9;if child.TextFits and child.TextBounds.Y &lt; pixelsRemaining then
&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextLabelSizePadY&quot;])
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextButtonSizePadY&quot;])
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;while not child.TextFits do
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.AbsoluteSize.Y + 1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y&#9;&#9;

&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;pixelsRemaining = -1
&#9;&#9;&#9;end&#9;&#9;&#9;

&#9;&#9;else
&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;child.Visible = (pixelsRemaining &gt;= 0)
&#9;&#9;end
&#9;end
end

t.LayoutGuiObjects = function(frame, guiObjects, settingsTable)
&#9;if not frame:IsA(&quot;GuiObject&quot;) then
&#9;&#9;error(&quot;Frame must be a GuiObject&quot;)
&#9;end
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if not child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements that are layed out must be of type GuiObject&quot;)
&#9;&#9;end
&#9;end

&#9;if not settingsTable then
&#9;&#9;settingsTable = {}
&#9;end

&#9;if not settingsTable[&quot;TextLabelSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelSizePadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextLabelPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelPositionPadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextButtonSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonSizePadY&quot;] = 12
&#9;end
&#9;if not settingsTable[&quot;TextButtonPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonPositionPadY&quot;] = 2
&#9;end

&#9;--Wrapper frame takes care of styled objects
&#9;local wrapperFrame = Instance.new(&quot;Frame&quot;)
&#9;wrapperFrame.Name = &quot;WrapperFrame&quot;
&#9;wrapperFrame.BackgroundTransparency = 1
&#9;wrapperFrame.Size = UDim2.new(1,0,1,0)
&#9;wrapperFrame.Parent = frame

&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;child.Parent = wrapperFrame
&#9;end

&#9;local recalculate = function()
&#9;&#9;wait()
&#9;&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
&#9;end
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(recalculate)

&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
end


t.CreateSlider = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 4
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local bar = Instance.new(&quot;TextButton&quot;)
&#9;bar.Text = &quot;&quot;
&#9;bar.AutoButtonColor = false
&#9;bar.Name = &quot;Bar&quot;
&#9;bar.BackgroundColor3 = Color3.new(0,0,0)
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width,0,5)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,5)
&#9;end
&#9;bar.BorderColor3 = Color3.new(95/255,95/255,95/255)
&#9;bar.ZIndex = 2
&#9;bar.Parent = sliderGui
&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end
&#9;
&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/Slider.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-10)
&#9;slider.Size = UDim2.new(0,20,0,20)
&#9;slider.ZIndex = 3
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)
&#9;
&#9;return sliderGui, sliderPosition, sliderSteps

end

t.CreateTrueScrollingFrame = function()
&#9;local lowY = nil
&#9;local highY = nil
&#9;
&#9;local dragCon = nil
&#9;local upCon = nil

&#9;local internalChange = false

&#9;local descendantsChangeConMap = {}

&#9;local scrollingFrame = Instance.new(&quot;Frame&quot;)
&#9;scrollingFrame.Name = &quot;ScrollingFrame&quot;
&#9;scrollingFrame.Active = true
&#9;scrollingFrame.Size = UDim2.new(1,0,1,0)
&#9;scrollingFrame.ClipsDescendants = true

&#9;local controlFrame = Instance.new(&quot;Frame&quot;)
&#9;controlFrame.Name = &quot;ControlFrame&quot;
&#9;controlFrame.BackgroundTransparency = 1
&#9;controlFrame.Size = UDim2.new(0,18,1,0)
&#9;controlFrame.Position = UDim2.new(1,-20,0,0)
&#9;controlFrame.Parent = scrollingFrame
&#9;
&#9;local scrollBottom = Instance.new(&quot;BoolValue&quot;)
&#9;scrollBottom.Value = false
&#9;scrollBottom.Name = &quot;ScrollBottom&quot;
&#9;scrollBottom.Parent = controlFrame
&#9;
&#9;local scrollUp = Instance.new(&quot;BoolValue&quot;)
&#9;scrollUp.Value = false
&#9;scrollUp.Name = &quot;scrollUp&quot;
&#9;scrollUp.Parent = controlFrame

&#9;local scrollUpButton = Instance.new(&quot;TextButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.Text = &quot;&quot;
&#9;scrollUpButton.AutoButtonColor = false
&#9;scrollUpButton.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollUpButton.BorderColor3 = Color3.new(1,1,1)
&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;scrollUpButton.Size = UDim2.new(0,18,0,18)
&#9;scrollUpButton.ZIndex = 2
&#9;scrollUpButton.Parent = controlFrame
&#9;for i = 1, 6 do
&#9;&#9;local triFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;triFrame.BorderColor3 = Color3.new(1,1,1)
&#9;&#9;triFrame.Name = &quot;tri&quot; .. tostring(i)
&#9;&#9;triFrame.ZIndex = 3
&#9;&#9;triFrame.BackgroundTransparency = 0.5
&#9;&#9;triFrame.Size = UDim2.new(0,12 - ((i -1) * 2),0,0)
&#9;&#9;triFrame.Position = UDim2.new(0,3 + (i -1),0.5,2 - (i -1))
&#9;&#9;triFrame.Parent = scrollUpButton
&#9;end
&#9;scrollUpButton.MouseEnter:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.1
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollUpButton.MouseLeave:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)

&#9;local scrollDownButton = scrollUpButton:clone()
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.Position = UDim2.new(0,0,1,-18)
&#9;local downChildren = scrollDownButton:GetChildren()
&#9;for i = 1, #downChildren do
&#9;&#9;downChildren[i].Position = UDim2.new(0,3 + (i -1),0.5,-2 + (i - 1))
&#9;end
&#9;scrollDownButton.MouseEnter:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.1
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.MouseLeave:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.5
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.Parent = controlFrame
&#9;
&#9;local scrollTrack = Instance.new(&quot;Frame&quot;)
&#9;scrollTrack.Name = &quot;ScrollTrack&quot;
&#9;scrollTrack.BackgroundTransparency = 1
&#9;scrollTrack.Size = UDim2.new(0,18,1,-38)
&#9;scrollTrack.Position = UDim2.new(0,0,0,19)
&#9;scrollTrack.Parent = controlFrame

&#9;local scrollbar = Instance.new(&quot;TextButton&quot;)
&#9;scrollbar.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollbar.BorderColor3 = Color3.new(1,1,1)
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.AutoButtonColor = false
&#9;scrollbar.Text = &quot;&quot;
&#9;scrollbar.Active = true
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.ZIndex = 2
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.Size = UDim2.new(0, 18, 0.1, 0)
&#9;scrollbar.Position = UDim2.new(0,0,0,0)
&#9;scrollbar.Parent = scrollTrack

&#9;local scrollNub = Instance.new(&quot;Frame&quot;)
&#9;scrollNub.Name = &quot;ScrollNub&quot;
&#9;scrollNub.BorderColor3 = Color3.new(1,1,1)
&#9;scrollNub.Size = UDim2.new(0,10,0,0)
&#9;scrollNub.Position = UDim2.new(0.5,-5,0.5,0)
&#9;scrollNub.ZIndex = 2
&#9;scrollNub.BackgroundTransparency = 0.5
&#9;scrollNub.Parent = scrollbar

&#9;local newNub = scrollNub:clone()
&#9;newNub.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;newNub.Parent = scrollbar
&#9;
&#9;local lastNub = scrollNub:clone()
&#9;lastNub.Position = UDim2.new(0.5,-5,0.5,2)
&#9;lastNub.Parent = scrollbar

&#9;scrollbar.MouseEnter:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.1
&#9;&#9;scrollNub.BackgroundTransparency = 0.1
&#9;&#9;newNub.BackgroundTransparency = 0.1
&#9;&#9;lastNub.BackgroundTransparency = 0.1
&#9;end)
&#9;scrollbar.MouseLeave:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.5
&#9;&#9;scrollNub.BackgroundTransparency = 0.5
&#9;&#9;newNub.BackgroundTransparency = 0.5
&#9;&#9;lastNub.BackgroundTransparency = 0.5
&#9;end)

&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10
&#9;
&#9;local function positionScrollBar(x,y,offset)
&#9;&#9;local oldPos = scrollbar.Position

&#9;&#9;if y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;
&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y

&#9;&#9;if y &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;local newScaleYPos = (y - scrollTrack.AbsolutePosition.y - offset)/scrollTrack.AbsoluteSize.y
&#9;&#9;if newScaleYPos + relativeSize &gt; 1 then
&#9;&#9;&#9;newScaleYPos = 1 - relativeSize
&#9;&#9;&#9;scrollBottom.Value = true
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;elseif newScaleYPos &lt;= 0 then
&#9;&#9;&#9;newScaleYPos = 0
&#9;&#9;&#9;scrollUp.Value = true
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;else
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;end
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,newScaleYPos,0)
&#9;&#9;
&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;end

&#9;local function drillDownSetHighLow(instance)
&#9;&#9;if not instance or not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if instance == controlFrame then return end
&#9;&#9;if instance:IsDescendantOf(controlFrame) then return end
&#9;&#9;if not instance.Visible then return end

&#9;&#9;if lowY and lowY &gt; instance.AbsolutePosition.Y then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;elseif not lowY then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;end
&#9;&#9;if highY and highY &lt; (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;local children = instance:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;drillDownSetHighLow(children[i])
&#9;&#9;end
&#9;end

&#9;local function resetHighLow()
&#9;&#9;local firstChildren = scrollingFrame:GetChildren()

&#9;&#9;for i = 1, #firstChildren do
&#9;&#9;&#9;drillDownSetHighLow(firstChildren[i])
&#9;&#9;end
&#9;end

&#9;local function recalculate()
&#9;&#9;internalChange = true

&#9;&#9;local percentFrame = 0
&#9;&#9;if scrollbar.Position.Y.Scale &gt; 0 then
&#9;&#9;&#9;if scrollbar.Visible then
&#9;&#9;&#9;&#9;percentFrame = scrollbar.Position.Y.Scale/((scrollTrack.AbsoluteSize.Y - scrollbar.AbsoluteSize.Y)/scrollTrack.AbsoluteSize.Y)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;percentFrame = 0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if percentFrame &gt; 0.99 then percentFrame = 1 end

&#9;&#9;local hiddenYAmount = (scrollingFrame.AbsoluteSize.Y - (highY - lowY)) * percentFrame
&#9;&#9;
&#9;&#9;local guiChildren = scrollingFrame:GetChildren()
&#9;&#9;for i = 1, #guiChildren do
&#9;&#9;&#9;if guiChildren[i] ~= controlFrame then
&#9;&#9;&#9;&#9;guiChildren[i].Position = UDim2.new(guiChildren[i].Position.X.Scale,guiChildren[i].Position.X.Offset,
&#9;&#9;&#9;&#9;&#9;0, math.ceil(guiChildren[i].AbsolutePosition.Y) - math.ceil(lowY) + hiddenYAmount)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()
&#9;&#9;internalChange = false
&#9;end

&#9;local function setSliderSizeAndPosition()
&#9;&#9;if not highY or not lowY then return end

&#9;&#9;local totalYSpan = math.abs(highY - lowY)
&#9;&#9;if totalYSpan == 0 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false

&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;local percentShown = scrollingFrame.AbsoluteSize.Y/totalYSpan
&#9;&#9;if percentShown &gt;= 1 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false
&#9;&#9;&#9;recalculate()
&#9;&#9;else
&#9;&#9;&#9;scrollbar.Visible = true
&#9;&#9;&#9;scrollDownButton.Visible = true
&#9;&#9;&#9;scrollUpButton.Visible = true

&#9;&#9;&#9;scrollbar.Size = UDim2.new(scrollbar.Size.X.Scale,scrollbar.Size.X.Offset,percentShown,0)
&#9;&#9;end

&#9;&#9;local percentPosition = (scrollingFrame.AbsolutePosition.Y - lowY)/totalYSpan
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,percentPosition,-scrollbar.AbsoluteSize.X/2)

&#9;&#9;if scrollbar.AbsolutePosition.y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;end

&#9;&#9;if (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.Y) &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;end
&#9;end
&#9;
&#9;local buttonScrollAmountPixels = 7
&#9;local reentrancyGuardScrollUp = false
&#9;local function doScrollUp()
&#9;&#9;if reentrancyGuardScrollUp then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollUp = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y - buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollUp = false
&#9;end
&#9;
&#9;local reentrancyGuardScrollDown = false
&#9;local function doScrollDown()
&#9;&#9;if reentrancyGuardScrollDown then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollDown = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y + buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollDown = false
&#9;end

&#9;local function scrollUp(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollbar.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function scrollDown(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;scrollbar.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollbar.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollbar.AbsolutePosition.y
&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;local prevY = y
&#9;&#9;&#9;local reentrancyGuardMouseScroll = false
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;if reentrancyGuardMouseScroll then return end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = true
&#9;&#9;&#9;&#9;&#9;if positionScrollBar(x,y,mouseOffset) then
&#9;&#9;&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = false
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(function()
&#9;&#9;scrollUp()
&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)

&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(function()
&#9;&#9; scrollDown()
&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;
&#9;local function heightCheck(instance)
&#9;&#9;if highY and (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) &gt; highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;setSliderSizeAndPosition()
&#9;end
&#9;
&#9;local function highLowRecheck()
&#9;&#9;local oldLowY = lowY
&#9;&#9;local oldHighY = highY
&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()

&#9;&#9;if (lowY ~= oldLowY) or (highY ~= oldHighY) then
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end

&#9;local function descendantChanged(this, prop)
&#9;&#9;if internalChange then return end
&#9;&#9;if not this.Visible then return end

&#9;&#9;if prop == &quot;Size&quot; or prop == &quot;Position&quot; then
&#9;&#9;&#9;wait()
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end
&#9;end

&#9;scrollingFrame.DescendantAdded:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end

&#9;&#9;if instance.Visible then
&#9;&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end

&#9;&#9;descendantsChangeConMap[instance] = instance.Changed:connect(function(prop) descendantChanged(instance, prop) end)
&#9;end)

&#9;scrollingFrame.DescendantRemoving:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if descendantsChangeConMap[instance] then
&#9;&#9;&#9;descendantsChangeConMap[instance]:disconnect()
&#9;&#9;&#9;descendantsChangeConMap[instance] = nil
&#9;&#9;end
&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;highLowRecheck()
&#9;end)
&#9;
&#9;scrollingFrame.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;if not highY or not lowY then return end

&#9;&#9;&#9;highLowRecheck()
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end)

&#9;return scrollingFrame, controlFrame
end

t.CreateScrollingFrame = function(orderList,scrollStyle)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;ScrollingFrame&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(1,0,1,0)
&#9;
&#9;local scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.BackgroundTransparency = 1
&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 

&#9;
&#9;local scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.BackgroundTransparency = 1
&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;
&#9;local scrollbar = Instance.new(&quot;ImageButton&quot;)
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;scrollbar.BackgroundTransparency = 1
&#9;scrollbar.Size = UDim2.new(0, 18, 0, 150)

&#9;local scrollStamp = 0
&#9;&#9;
&#9;local scrollDrag = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDrag.Image = &quot;rbxasset://ui/scrolldrag.png&quot;
&#9;scrollDrag.Size = UDim2.new(1, 0, 0, 16)
&#9;scrollDrag.BackgroundTransparency = 1
&#9;scrollDrag.Name = &quot;ScrollDrag&quot;
&#9;scrollDrag.Active = true
&#9;scrollDrag.Parent = scrollbar
&#9;
&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10

&#9;local style = &quot;simple&quot;
&#9;if scrollStyle and tostring(scrollStyle) then
&#9;&#9;style = scrollStyle
&#9;end
&#9;
&#9;local scrollPosition = 1
&#9;local rowSize = 0
&#9;local howManyDisplayed = 0
&#9;&#9;
&#9;local layoutGridScrollBar = function()
&#9;&#9;howManyDisplayed = 0
&#9;&#9;local guiObjects = {}
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;
&#9;&#9;local totalPixelsY = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemainingY = frame.AbsoluteSize.Y
&#9;&#9;
&#9;&#9;local totalPixelsX  = frame.AbsoluteSize.X
&#9;&#9;
&#9;&#9;local xCounter = 0
&#9;&#9;local rowSizeCounter = 0
&#9;&#9;local setRowSize = true

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;
&#9;&#9;local currentRowY = 0

&#9;&#9;pos = scrollPosition
&#9;&#9;--count up from current scroll position to fill out grid
&#9;&#9;while pos &lt;= #guiObjects and pixelsBelowScrollbar &lt; totalPixelsY do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;--previous pos was the end of a row
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;end
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos + 1
&#9;&#9;end
&#9;&#9;--Count wherever current row left off
&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;currentRowY = 0
&#9;&#9;
&#9;&#9;pos = scrollPosition - 1
&#9;&#9;xCounter = 0
&#9;&#9;
&#9;&#9;--objects with varying X,Y dimensions can rarely cause minor errors
&#9;&#9;--rechecking every new scrollPosition is necessary to avoid 100% of errors
&#9;&#9;
&#9;&#9;--count backwards from current scrollPosition to see if we can add more rows
&#9;&#9;while pixelsBelowScrollbar + currentRowY &lt; totalPixelsY and pos &gt;= 1 do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;rowSizeCounter = rowSizeCounter + 1
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;rowSizeCounter = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= rowSize then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1 
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - rowSize
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end

&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end
&#9;&#9;
&#9;&#9;--Do check last time if pos = 0
&#9;&#9;if (pos == 0) and (pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY) then
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;end

&#9;&#9;xCounter = 0
&#9;&#9;--pos = scrollPosition
&#9;&#9;rowSizeCounter = 0
&#9;&#9;setRowSize = true
&#9;&#9;local lastChildSize = 0
&#9;&#9;
&#9;&#9;local xOffset,yOffset = 0
&#9;&#9;if guiObjects[1] then
&#9;&#9;&#9;yOffset = math.ceil(math.floor(math.fmod(totalPixelsY,guiObjects[1].AbsoluteSize.X))/2)
&#9;&#9;&#9;xOffset = math.ceil(math.floor(math.fmod(totalPixelsX,guiObjects[1].AbsoluteSize.Y))/2)
&#9;&#9;end
&#9;&#9;
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemainingY &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;if setRowSize then rowSizeCounter = rowSizeCounter + 1 end
&#9;&#9;&#9;&#9;&#9;if xCounter + child.AbsoluteSize.X &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;&#9;&#9;if setRowSize then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;setRowSize = false
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;xCounter = 0
&#9;&#9;&#9;&#9;&#9;&#9;pixelsRemainingY = pixelsRemainingY - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale,xCounter + xOffset, 0, totalPixelsY - pixelsRemainingY + yOffset)
&#9;&#9;&#9;&#9;&#9;xCounter = xCounter + child.AbsoluteSize.X
&#9;&#9;&#9;&#9;&#9;child.Visible = ((pixelsRemainingY - child.AbsoluteSize.Y) &gt;= 0)
&#9;&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;lastChildSize = child.AbsoluteSize&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;if lastChildSize == 0 then 
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;else
&#9;&#9;&#9;scrollDownButton.Active = ((pixelsRemainingY - lastChildSize.Y) &lt; 0)
&#9;&#9;end
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end



&#9;local layoutSimpleScrollBar = function()
&#9;&#9;local guiObjects = {}&#9;
&#9;&#9;howManyDisplayed = 0
&#9;&#9;
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemaining = frame.AbsoluteSize.Y

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;while pixelsBelowScrollbar &lt; totalPixels and pos &gt;= 1 do
&#9;&#9;&#9;if pos &gt;= scrollPosition then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y &lt;= totalPixels then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= 1 then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--local (&quot;Backing up ScrollPosition from -- &quot; ..scrollPosition)
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end

&#9;&#9;pos = scrollPosition
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemaining &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if  (pixelsRemaining &gt;= 0) then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;scrollDownButton.Active = (pixelsRemaining &lt; 0)
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end
&#9;
&#9;&#9;
&#9;local moveDragger = function()&#9;
&#9;&#9;local guiObjects = 0
&#9;&#9;local children = frame:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;if not scrollDrag.Parent then return end
&#9;&#9;
&#9;&#9;local dragSizeY = scrollDrag.Parent.AbsoluteSize.y * (1/(guiObjects - howManyDisplayed + 1))
&#9;&#9;if dragSizeY &lt; 16 then dragSizeY = 16 end
&#9;&#9;scrollDrag.Size = UDim2.new(scrollDrag.Size.X.Scale,scrollDrag.Size.X.Offset,scrollDrag.Size.Y.Scale,dragSizeY)

&#9;&#9;local relativeYPos = (scrollPosition - 1)/(guiObjects - (howManyDisplayed))
&#9;&#9;if relativeYPos &gt; 1 then relativeYPos = 1
&#9;&#9;elseif relativeYPos &lt; 0 then relativeYPos = 0 end
&#9;&#9;local absYPos = 0
&#9;&#9;
&#9;&#9;if relativeYPos ~= 0 then
&#9;&#9;&#9;absYPos = (relativeYPos * scrollbar.AbsoluteSize.y) - (relativeYPos * scrollDrag.AbsoluteSize.y)
&#9;&#9;end
&#9;&#9;
&#9;&#9;scrollDrag.Position = UDim2.new(scrollDrag.Position.X.Scale,scrollDrag.Position.X.Offset,scrollDrag.Position.Y.Scale,absYPos)
&#9;end

&#9;local reentrancyGuard = false
&#9;local recalculate = function()
&#9;&#9;if reentrancyGuard then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;reentrancyGuard = true
&#9;&#9;wait()
&#9;&#9;local success, err = nil
&#9;&#9;if style == &quot;grid&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutGridScrollBar() end)
&#9;&#9;elseif style == &quot;simple&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutSimpleScrollBar() end)
&#9;&#9;end
&#9;&#9;if not success then print(err) end
&#9;&#9;moveDragger()
&#9;&#9;reentrancyGuard = false
&#9;end
&#9;
&#9;local doScrollUp = function()
&#9;&#9;scrollPosition = (scrollPosition) - rowSize
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;recalculate(nil)
&#9;end
&#9;
&#9;local doScrollDown = function()
&#9;&#9;scrollPosition = (scrollPosition) + rowSize
&#9;&#9;recalculate(nil)
&#9;end

&#9;local scrollUp = function(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollDrag.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollDown = function(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollDrag.AbsolutePosition.y + scrollDrag.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local y = 0
&#9;scrollDrag.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollDrag.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollDrag.AbsolutePosition.y
&#9;&#9;&#9;local dragCon
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;local barAbsPos = scrollbar.AbsolutePosition.y
&#9;&#9;&#9;&#9;local barAbsSize = scrollbar.AbsoluteSize.y
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local dragAbsSize = scrollDrag.AbsoluteSize.y
&#9;&#9;&#9;&#9;local barAbsOne = barAbsPos + barAbsSize - dragAbsSize
&#9;&#9;&#9;&#9;y = y - mouseOffset
&#9;&#9;&#9;&#9;y = y &lt; barAbsPos and barAbsPos or y &gt; barAbsOne and barAbsOne or y
&#9;&#9;&#9;&#9;y = y - barAbsPos
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local guiObjects = 0
&#9;&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local doublePercent = y/(barAbsSize-dragAbsSize)
&#9;&#9;&#9;&#9;local rowDiff = rowSize
&#9;&#9;&#9;&#9;local totalScrollCount = guiObjects - (howManyDisplayed - 1)
&#9;&#9;&#9;&#9;local newScrollPosition = math.floor((doublePercent * totalScrollCount) + 0.5) + rowDiff
&#9;&#9;&#9;&#9;if newScrollPosition &lt; scrollPosition then
&#9;&#9;&#9;&#9;&#9;rowDiff = -rowDiff
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if newScrollPosition &lt; 1 then
&#9;&#9;&#9;&#9;&#9;newScrollPosition = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;scrollPosition = newScrollPosition
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollUp()
&#9;&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)


&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollDown()&#9;
&#9;&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollbar.MouseButton1Down:connect(
&#9;&#9;function(x,y)
&#9;&#9;&#9;if y &gt; (scrollDrag.AbsoluteSize.y + scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollDown(y)
&#9;&#9;&#9;elseif y &lt; (scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollUp(y)
&#9;&#9;&#9;end
&#9;&#9;end)


&#9;frame.ChildAdded:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)

&#9;frame.ChildRemoved:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(function() recalculate(nil) end)

&#9;return frame, scrollUpButton, scrollDownButton, recalculate, scrollbar
end
local function binaryGrow(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local biggestLegal = min

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (biggestLegal == nil or biggestLegal &lt; mid) then
&#9;&#9;&#9;biggestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--Try growing
&#9;&#9;&#9;min = mid + 1
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, shrink
&#9;&#9;&#9;max = mid - 1
&#9;&#9;end
&#9;end
&#9;return biggestLegal
end


local function binaryShrink(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local smallestLegal = max

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (smallestLegal == nil or smallestLegal &gt; mid) then
&#9;&#9;&#9;smallestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--It fits, shrink
&#9;&#9;&#9;max = mid - 1&#9;&#9;&#9;
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, grow
&#9;&#9;&#9;min = mid + 1
&#9;&#9;end
&#9;end
&#9;return smallestLegal
end


local function getGuiOwner(instance)
&#9;while instance ~= nil do
&#9;&#9;if instance:IsA(&quot;ScreenGui&quot;) or instance:IsA(&quot;BillboardGui&quot;)  then
&#9;&#9;&#9;return instance
&#9;&#9;end
&#9;&#9;instance = instance.Parent
&#9;end
&#9;return nil
end

t.AutoTruncateTextObject = function(textLabel)
&#9;local text = textLabel.Text

&#9;local fullLabel = textLabel:Clone()
&#9;fullLabel.Name = &quot;Full&quot; .. textLabel.Name 
&#9;fullLabel.BorderSizePixel = 0
&#9;fullLabel.BackgroundTransparency = 0
&#9;fullLabel.Text = text
&#9;fullLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;fullLabel.Position = UDim2.new(0,-3,0,0)
&#9;fullLabel.Size = UDim2.new(0,100,1,0)
&#9;fullLabel.Visible = false
&#9;fullLabel.Parent = textLabel

&#9;local shortText = nil
&#9;local mouseEnterConnection = nil
&#9;local mouseLeaveConnection= nil

&#9;local checkForResize = function()
&#9;&#9;if getGuiOwner(textLabel) == nil then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;textLabel.Text = text
&#9;&#9;if textLabel.TextFits then 
&#9;&#9;&#9;--Tear down the rollover if it is active
&#9;&#9;&#9;if mouseEnterConnection then
&#9;&#9;&#9;&#9;mouseEnterConnection:disconnect()
&#9;&#9;&#9;&#9;mouseEnterConnection = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection then
&#9;&#9;&#9;&#9;mouseLeaveConnection:disconnect()
&#9;&#9;&#9;&#9;mouseLeaveConnection = nil
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local len = string.len(text)
&#9;&#9;&#9;textLabel.Text = text .. &quot;~&quot;

&#9;&#9;&#9;--Shrink the text
&#9;&#9;&#9;local textSize = binaryGrow(0, len, 
&#9;&#9;&#9;&#9;function(pos)
&#9;&#9;&#9;&#9;&#9;if pos == 0 then
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = string.sub(text, 1, pos) .. &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;shortText = string.sub(text, 1, textSize) .. &quot;~&quot;
&#9;&#9;&#9;textLabel.Text = shortText
&#9;&#9;&#9;
&#9;&#9;&#9;--Make sure the fullLabel fits
&#9;&#9;&#9;if not fullLabel.TextFits then
&#9;&#9;&#9;&#9;--Already too small, grow it really bit to start
&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, 10000, 1, 0)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;--Okay, now try to binary shrink it back down
&#9;&#9;&#9;local fullLabelSize = binaryShrink(textLabel.AbsoluteSize.X,fullLabel.AbsoluteSize.X, 
&#9;&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, size, 1, 0)
&#9;&#9;&#9;&#9;&#9;return fullLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;fullLabel.Size = UDim2.new(0,fullLabelSize+6,1,0)

&#9;&#9;&#9;--Now setup the rollover effects, if they are currently off
&#9;&#9;&#9;if mouseEnterConnection == nil then
&#9;&#9;&#9;&#9;mouseEnterConnection = textLabel.MouseEnter:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.ZIndex = textLabel.ZIndex + 1
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection == nil then
&#9;&#9;&#9;&#9;mouseLeaveConnection = textLabel.MouseLeave:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = shortText
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;textLabel.AncestryChanged:connect(checkForResize)
&#9;textLabel.Changed:connect(
&#9;&#9;function(prop) 
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then 
&#9;&#9;&#9;&#9;checkForResize() &#9;
&#9;&#9;&#9;end 
&#9;&#9;end)

&#9;checkForResize()

&#9;local function changeText(newText)
&#9;&#9;text = newText
&#9;&#9;fullLabel.Text = text
&#9;&#9;checkForResize()
&#9;end

&#9;return textLabel, changeText
end

local function TransitionTutorialPages(fromPage, toPage, transitionFrame, currentPageValue)&#9;
&#9;if fromPage then
&#9;&#9;fromPage.Visible = false
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = fromPage.Size
&#9;&#9;&#9;transitionFrame.Position = fromPage.Position
&#9;&#9;end
&#9;else
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = UDim2.new(0.0,50,0.0,50)
&#9;&#9;&#9;transitionFrame.Position = UDim2.new(0.5,-25,0.5,-25)
&#9;&#9;end
&#9;end
&#9;transitionFrame.Visible = true
&#9;currentPageValue.Value = nil

&#9;local newsize, newPosition
&#9;if toPage then
&#9;&#9;--Make it visible so it resizes
&#9;&#9;toPage.Visible = true

&#9;&#9;newSize = toPage.Size
&#9;&#9;newPosition = toPage.Position

&#9;&#9;toPage.Visible = false
&#9;else
&#9;&#9;newSize = UDim2.new(0.0,50,0.0,50)
&#9;&#9;newPosition = UDim2.new(0.5,-25,0.5,-25)
&#9;end
&#9;transitionFrame:TweenSizeAndPosition(newSize, newPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, 0.3, true,
&#9;&#9;function(state)
&#9;&#9;&#9;if state == Enum.TweenStatus.Completed then
&#9;&#9;&#9;&#9;transitionFrame.Visible = false
&#9;&#9;&#9;&#9;if toPage then
&#9;&#9;&#9;&#9;&#9;toPage.Visible = true
&#9;&#9;&#9;&#9;&#9;currentPageValue.Value = toPage
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
end

t.CreateTutorial = function(name, tutorialKey, createButtons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;Tutorial-&quot; .. name
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)

&#9;local transitionFrame = Instance.new(&quot;Frame&quot;)
&#9;transitionFrame.Name = &quot;TransitionFrame&quot;
&#9;transitionFrame.Style = Enum.FrameStyle.RobloxRound
&#9;transitionFrame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;transitionFrame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;transitionFrame.Visible = false
&#9;transitionFrame.Parent = frame

&#9;local currentPageValue = Instance.new(&quot;ObjectValue&quot;)
&#9;currentPageValue.Name = &quot;CurrentTutorialPage&quot;
&#9;currentPageValue.Value = nil
&#9;currentPageValue.Parent = frame

&#9;local boolValue = Instance.new(&quot;BoolValue&quot;)
&#9;boolValue.Name = &quot;Buttons&quot;
&#9;boolValue.Value = createButtons
&#9;boolValue.Parent = frame

&#9;local pages = Instance.new(&quot;Frame&quot;)
&#9;pages.Name = &quot;Pages&quot;
&#9;pages.BackgroundTransparency = 1
&#9;pages.Size = UDim2.new(1,0,1,0)
&#9;pages.Parent = frame

&#9;local function getVisiblePageAndHideOthers()
&#9;&#9;local visiblePage = nil
&#9;&#9;local children = pages:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i,child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;if visiblePage then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;visiblePage = child
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return visiblePage
&#9;end

&#9;local showTutorial = function(alwaysShow)
&#9;&#9;if alwaysShow or UserSettings().GameSettings:GetTutorialState(tutorialKey) == false then
&#9;&#9;&#9;print(&quot;Showing tutorial-&quot;,tutorialKey)
&#9;&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;&#9;local firstPage = pages:FindFirstChild(&quot;TutorialPage1&quot;)
&#9;&#9;&#9;if firstPage then
&#9;&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, firstPage, transitionFrame, currentPageValue)&#9;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;Could not find TutorialPage1&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local dismissTutorial = function()
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;if currentTutorialPage then
&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, nil, transitionFrame, currentPageValue)
&#9;&#9;end

&#9;&#9;UserSettings().GameSettings:SetTutorialState(tutorialKey, true)
&#9;end

&#9;local gotoPage = function(pageNum)
&#9;&#9;local page = pages:FindFirstChild(&quot;TutorialPage&quot; .. pageNum)
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()
&#9;&#9;TransitionTutorialPages(currentTutorialPage, page, transitionFrame, currentPageValue)
&#9;end

&#9;return frame, showTutorial, dismissTutorial, gotoPage
end 

local function CreateBasicTutorialPage(name, handleResize, skipTutorial, giveDoneButton)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TutorialPage&quot;
&#9;frame.Style = Enum.FrameStyle.RobloxRound
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;frame.Visible = false
&#9;
&#9;local frameHeader = Instance.new(&quot;TextLabel&quot;)
&#9;frameHeader.Name = &quot;Header&quot;
&#9;frameHeader.Text = name
&#9;frameHeader.BackgroundTransparency = 1
&#9;frameHeader.FontSize = Enum.FontSize.Size24
&#9;frameHeader.Font = Enum.Font.ArialBold
&#9;frameHeader.TextColor3 = Color3.new(1,1,1)
&#9;frameHeader.TextXAlignment = Enum.TextXAlignment.Center
&#9;frameHeader.TextWrap = true
&#9;frameHeader.Size = UDim2.new(1,-55, 0, 22)
&#9;frameHeader.Position = UDim2.new(0,0,0,0)
&#9;frameHeader.Parent = frame

&#9;local skipButton = Instance.new(&quot;ImageButton&quot;)
&#9;skipButton.Name = &quot;SkipButton&quot;
&#9;skipButton.AutoButtonColor = false
&#9;skipButton.BackgroundTransparency = 1
&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;skipButton.MouseButton1Click:connect(function()
&#9;&#9;skipTutorial()
&#9;end)
&#9;skipButton.MouseEnter:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton_dn.png&quot;
&#9;end)
&#9;skipButton.MouseLeave:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;end)
&#9;skipButton.Size = UDim2.new(0, 25, 0, 25)
&#9;skipButton.Position = UDim2.new(1, -25, 0, 0)
&#9;skipButton.Parent = frame
&#9;
&#9;
&#9;if giveDoneButton then
&#9;&#9;local doneButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;doneButton.Name = &quot;DoneButton&quot;
&#9;&#9;doneButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;doneButton.Text = &quot;Done&quot;
&#9;&#9;doneButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;doneButton.Font = Enum.Font.ArialBold
&#9;&#9;doneButton.FontSize = Enum.FontSize.Size18
&#9;&#9;doneButton.Size = UDim2.new(0,100,0,50)
&#9;&#9;doneButton.Position = UDim2.new(0.5,-50,1,-50)
&#9;&#9;
&#9;&#9;if skipTutorial then
&#9;&#9;&#9;doneButton.MouseButton1Click:connect(function() skipTutorial() end)
&#9;&#9;end
&#9;&#9;
&#9;&#9;doneButton.Parent = frame
&#9;end

&#9;local innerFrame = Instance.new(&quot;Frame&quot;)
&#9;innerFrame.Name = &quot;ContentFrame&quot;
&#9;innerFrame.BackgroundTransparency = 1
&#9;innerFrame.Position = UDim2.new(0,0,0,25)
&#9;innerFrame.Parent = frame

&#9;local nextButton = Instance.new(&quot;TextButton&quot;)
&#9;nextButton.Name = &quot;NextButton&quot;
&#9;nextButton.Text = &quot;Next&quot;
&#9;nextButton.TextColor3 = Color3.new(1,1,1)
&#9;nextButton.Font = Enum.Font.Arial
&#9;nextButton.FontSize = Enum.FontSize.Size18
&#9;nextButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;nextButton.Size = UDim2.new(0,80, 0, 32)
&#9;nextButton.Position = UDim2.new(0.5, 5, 1, -32)
&#9;nextButton.Active = false
&#9;nextButton.Visible = false
&#9;nextButton.Parent = frame

&#9;local prevButton = Instance.new(&quot;TextButton&quot;)
&#9;prevButton.Name = &quot;PrevButton&quot;
&#9;prevButton.Text = &quot;Previous&quot;
&#9;prevButton.TextColor3 = Color3.new(1,1,1)
&#9;prevButton.Font = Enum.Font.Arial
&#9;prevButton.FontSize = Enum.FontSize.Size18
&#9;prevButton.Style = Enum.ButtonStyle.RobloxButton
&#9;prevButton.Size = UDim2.new(0,80, 0, 32)
&#9;prevButton.Position = UDim2.new(0.5, -85, 1, -32)
&#9;prevButton.Active = false
&#9;prevButton.Visible = false
&#9;prevButton.Parent = frame

&#9;if giveDoneButton then
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-75)
&#9;else
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-22)
&#9;end

&#9;local parentConnection = nil

&#9;local function basicHandleResize()
&#9;&#9;if frame.Visible and frame.Parent then
&#9;&#9;&#9;local maxSize = math.min(frame.Parent.AbsoluteSize.X, frame.Parent.AbsoluteSize.Y)
&#9;&#9;&#9;handleResize(200,maxSize)
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;Parent&quot; then
&#9;&#9;&#9;&#9;if parentConnection ~= nil then
&#9;&#9;&#9;&#9;&#9;parentConnection:disconnect()
&#9;&#9;&#9;&#9;&#9;parentConnection = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if frame.Parent and frame.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;parentConnection = frame.Parent.Changed:connect(
&#9;&#9;&#9;&#9;&#9;&#9;function(parentProp)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if parentProp == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;if prop == &quot;Visible&quot; then 
&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;end
&#9;&#9;end)

&#9;return frame, innerFrame
end

t.CreateTextTutorialPage = function(name, text, skipTutorialFunc)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local textLabel = Instance.new(&quot;TextLabel&quot;)
&#9;textLabel.BackgroundTransparency = 1
&#9;textLabel.TextColor3 = Color3.new(1,1,1)
&#9;textLabel.Text = text
&#9;textLabel.TextWrap = true
&#9;textLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;textLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;textLabel.Font = Enum.Font.Arial
&#9;textLabel.FontSize = Enum.FontSize.Size14
&#9;textLabel.Size = UDim2.new(1,0,1,0)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;end)
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc)
&#9;textLabel.Parent = contentFrame

&#9;return frame
end

t.CreateImageTutorialPage = function(name, imageAsset, x, y, skipTutorialFunc, giveDoneButton)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local imageLabel = Instance.new(&quot;ImageLabel&quot;)
&#9;imageLabel.BackgroundTransparency = 1
&#9;imageLabel.Image = imageAsset
&#9;imageLabel.Size = UDim2.new(0,x,0,y)
&#9;imageLabel.Position = UDim2.new(0.5,-x/2,0.5,-y/2)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;return size &gt;= x and size &gt;= y
&#9;&#9;&#9;end)
&#9;&#9;if size &gt;= x and size &gt;= y then
&#9;&#9;&#9;imageLabel.Size = UDim2.new(0,x, 0,y)
&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5,-x/2, 0.5, -y/2)
&#9;&#9;else
&#9;&#9;&#9;if x &gt; y then
&#9;&#9;&#9;&#9;--X is limiter, so 
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(1,0,y/x,0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0,0, 0.5 - (y/x)/2, 0)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--Y is limiter
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(x/y,0,1, 0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5-(x/y)/2, 0, 0, 0)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;size = size + 50
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc, giveDoneButton)
&#9;imageLabel.Parent = contentFrame

&#9;return frame
end

t.AddTutorialPage = function(tutorial, tutorialPage)
&#9;local transitionFrame = tutorial.TransitionFrame
&#9;local currentPageValue = tutorial.CurrentTutorialPage

&#9;if not tutorial.Buttons.Value then
&#9;&#9;tutorialPage.NextButton.Parent = nil
&#9;&#9;tutorialPage.PrevButton.Parent = nil
&#9;end

&#9;local children = tutorial.Pages:GetChildren()
&#9;if children and #children &gt; 0 then
&#9;&#9;tutorialPage.Name = &quot;TutorialPage&quot; .. (#children+1)
&#9;&#9;local previousPage = children[#children]
&#9;&#9;if not previousPage:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements under Pages must be GuiObjects&quot;)
&#9;&#9;end

&#9;&#9;if tutorial.Buttons.Value then
&#9;&#9;&#9;if previousPage.NextButton.Active then
&#9;&#9;&#9;&#9;error(&quot;NextButton already Active on previousPage, please only add pages with RbxGui.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;previousPage.NextButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(previousPage, tutorialPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;previousPage.NextButton.Active = true
&#9;&#9;&#9;previousPage.NextButton.Visible = true

&#9;&#9;&#9;if tutorialPage.PrevButton.Active then
&#9;&#9;&#9;&#9;error(&quot;PrevButton already Active on tutorialPage, please only add pages with RbxGui.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;tutorialPage.PrevButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(tutorialPage, previousPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;tutorialPage.PrevButton.Active = true
&#9;&#9;&#9;tutorialPage.PrevButton.Visible = true
&#9;&#9;end

&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;else
&#9;&#9;--First child
&#9;&#9;tutorialPage.Name = &quot;TutorialPage1&quot;
&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;end
end 

t.CreateSetPanel = function(userIdsForSets, objectSelected, dialogClosed, size, position, showAdminCategories, useAssetVersionId)

&#9;if not userIdsForSets then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is nil, should be a table of number ids&quot;)
&#9;end
&#9;if type(userIdsForSets) ~= &quot;table&quot; and type(userIdsForSets) ~= &quot;userdata&quot; then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is of type &quot; ..type(userIdsForSets) .. &quot;, should be of type table or userdata&quot;)
&#9;end
&#9;if not objectSelected then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is nil, should be a callback function!&quot;)
&#9;end
&#9;if type(objectSelected) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is of type &quot; .. type(objectSelected) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;if dialogClosed and type(dialogClosed) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: dialogClosed (third arg) is of type &quot; .. type(dialogClosed) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;
&#9;if showAdminCategories == nil then -- by default, don&apos;t show beta sets
&#9;&#9;showAdminCategories = false
&#9;end

&#9;local arrayPosition = 1
&#9;local insertButtons = {}
&#9;local insertButtonCons = {}
&#9;local contents = nil
&#9;local setGui = nil

&#9;-- used for water selections
&#9;local waterForceDirection = &quot;NegX&quot;
&#9;local waterForce = &quot;None&quot;
&#9;local waterGui, waterTypeChangedEvent = nil
&#9;
&#9;local Data = {}
&#9;Data.CurrentCategory = nil
&#9;Data.Category = {}
&#9;local SetCache = {}
&#9;
&#9;local userCategoryButtons = nil
&#9;
&#9;local buttonWidth = 64
&#9;local buttonHeight = buttonWidth
&#9;
&#9;local SmallThumbnailUrl = nil
&#9;local LargeThumbnailUrl = nil
&#9;local BaseUrl = game:GetService(&quot;ContentProvider&quot;).BaseUrl:lower()
&#9;
&#9;if useAssetVersionId then
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;assetversionid=&quot;
&#9;else
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;aid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;aid=&quot;
&#9;end
&#9;&#9;
&#9;local function drillDownSetZIndex(parent, index)
&#9;&#9;local children = parent:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;if children[i]:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;children[i].ZIndex = index
&#9;&#9;&#9;end
&#9;&#9;&#9;drillDownSetZIndex(children[i], index)
&#9;&#9;end
&#9;end
&#9;
&#9;-- for terrain stamping
&#9;local currTerrainDropDownFrame = nil
&#9;local terrainShapes = {&quot;Block&quot;,&quot;Vertical Ramp&quot;,&quot;Corner Wedge&quot;,&quot;Inverse Corner Wedge&quot;,&quot;Horizontal Ramp&quot;,&quot;Auto-Wedge&quot;}
&#9;local terrainShapeMap = {}
&#9;for i = 1, #terrainShapes do
&#9;&#9;terrainShapeMap[terrainShapes[i]] = i - 1
&#9;end&#9;
&#9;terrainShapeMap[terrainShapes[#terrainShapes]] = 6

&#9;local function createWaterGui()
&#9;&#9;local waterForceDirections = {&quot;NegX&quot;,&quot;X&quot;,&quot;NegY&quot;,&quot;Y&quot;,&quot;NegZ&quot;,&quot;Z&quot;}
&#9;&#9;local waterForces = {&quot;None&quot;, &quot;Small&quot;, &quot;Medium&quot;, &quot;Strong&quot;, &quot;Max&quot;}

&#9;&#9;local waterFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;waterFrame.Name = &quot;WaterFrame&quot;
&#9;&#9;waterFrame.Style = Enum.FrameStyle.RobloxSquare
&#9;&#9;waterFrame.Size = UDim2.new(0,150,0,110)
&#9;&#9;waterFrame.Visible = false

&#9;&#9;local waterForceLabel = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;waterForceLabel.Name = &quot;WaterForceLabel&quot;
&#9;&#9;waterForceLabel.BackgroundTransparency = 1
&#9;&#9;waterForceLabel.Size = UDim2.new(1,0,0,12)
&#9;&#9;waterForceLabel.Font = Enum.Font.ArialBold
&#9;&#9;waterForceLabel.FontSize = Enum.FontSize.Size12
&#9;&#9;waterForceLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;waterForceLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;waterForceLabel.Text = &quot;Water Force&quot;
&#9;&#9;waterForceLabel.Parent = waterFrame

&#9;&#9;local waterForceDirLabel = waterForceLabel:Clone()
&#9;&#9;waterForceDirLabel.Name = &quot;WaterForceDirectionLabel&quot;
&#9;&#9;waterForceDirLabel.Text = &quot;Water Force Direction&quot;
&#9;&#9;waterForceDirLabel.Position = UDim2.new(0,0,0,50)
&#9;&#9;waterForceDirLabel.Parent = waterFrame

&#9;&#9;local waterTypeChangedEvent = Instance.new(&quot;BindableEvent&quot;,waterFrame)
&#9;&#9;waterTypeChangedEvent.Name = &quot;WaterTypeChangedEvent&quot;

&#9;&#9;local waterForceDirectionSelectedFunc = function(newForceDirection)
&#9;&#9;&#9;waterForceDirection = newForceDirection
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end
&#9;&#9;local waterForceSelectedFunc = function(newForce)
&#9;&#9;&#9;waterForce = newForce
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end

&#9;&#9;local waterForceDirectionDropDown, forceWaterDirectionSelection = t.CreateDropDownMenu(waterForceDirections, waterForceDirectionSelectedFunc)
&#9;&#9;waterForceDirectionDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDirectionDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;forceWaterDirectionSelection(&quot;NegX&quot;)
&#9;&#9;waterForceDirectionDropDown.Parent = waterForceDirLabel

&#9;&#9;local waterForceDropDown, forceWaterForceSelection = t.CreateDropDownMenu(waterForces, waterForceSelectedFunc)
&#9;&#9;forceWaterForceSelection(&quot;None&quot;)
&#9;&#9;waterForceDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;waterForceDropDown.Parent = waterForceLabel

&#9;&#9;return waterFrame, waterTypeChangedEvent
&#9;end

&#9;-- Helper Function that contructs gui elements
&#9;local function createSetGui()
&#9;
&#9;&#9;local setGui = Instance.new(&quot;ScreenGui&quot;)
&#9;&#9;setGui.Name = &quot;SetGui&quot;
&#9;&#9;
&#9;&#9;local setPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;setPanel.Name = &quot;SetPanel&quot;
&#9;&#9;setPanel.Active = true
&#9;&#9;setPanel.BackgroundTransparency = 1
&#9;&#9;if position then
&#9;&#9;&#9;setPanel.Position = position
&#9;&#9;else
&#9;&#9;&#9;setPanel.Position = UDim2.new(0.2, 29, 0.1, 24)
&#9;&#9;end
&#9;&#9;if size then
&#9;&#9;&#9;setPanel.Size = size
&#9;&#9;else
&#9;&#9;&#9;setPanel.Size = UDim2.new(0.6, -58, 0.64, 0)
&#9;&#9;end
&#9;&#9;setPanel.Style = Enum.FrameStyle.RobloxRound
&#9;&#9;setPanel.ZIndex = 6
&#9;&#9;setPanel.Parent = setGui
&#9;&#9;
&#9;&#9;&#9;-- Children of SetPanel
&#9;&#9;&#9;local itemPreview = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;itemPreview.Name = &quot;ItemPreview&quot;
&#9;&#9;&#9;itemPreview.BackgroundTransparency = 1
&#9;&#9;&#9;itemPreview.Position = UDim2.new(0.8,5,0.085,0)
&#9;&#9;&#9;itemPreview.Size = UDim2.new(0.21,0,0.9,0)
&#9;&#9;&#9;itemPreview.ZIndex = 6
&#9;&#9;&#9;itemPreview.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of ItemPreview
&#9;&#9;&#9;&#9;local textPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;textPanel.Name = &quot;TextPanel&quot;
&#9;&#9;&#9;&#9;textPanel.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;textPanel.Position = UDim2.new(0,0,0.45,0)
&#9;&#9;&#9;&#9;textPanel.Size = UDim2.new(1,0,0.55,0)
&#9;&#9;&#9;&#9;textPanel.ZIndex = 6
&#9;&#9;&#9;&#9;textPanel.Parent = itemPreview
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- Children of TextPanel
&#9;&#9;&#9;&#9;&#9;local rolloverText = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;&#9;rolloverText.Name = &quot;RolloverText&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;rolloverText.Size = UDim2.new(1,0,0,48)
&#9;&#9;&#9;&#9;&#9;rolloverText.ZIndex = 6
&#9;&#9;&#9;&#9;&#9;rolloverText.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;rolloverText.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;&#9;rolloverText.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;&#9;rolloverText.TextWrap = true
&#9;&#9;&#9;&#9;&#9;rolloverText.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;&#9;rolloverText.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;&#9;rolloverText.Parent = textPanel
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local largePreview = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;largePreview.Name = &quot;LargePreview&quot;
&#9;&#9;&#9;&#9;largePreview.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;largePreview.Image = &quot;&quot;
&#9;&#9;&#9;&#9;largePreview.Size = UDim2.new(1,0,0,170)
&#9;&#9;&#9;&#9;largePreview.ZIndex = 6
&#9;&#9;&#9;&#9;largePreview.Parent = itemPreview
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;local sets = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;sets.Name = &quot;Sets&quot;
&#9;&#9;&#9;sets.BackgroundTransparency = 1
&#9;&#9;&#9;sets.Position = UDim2.new(0,0,0,5)
&#9;&#9;&#9;sets.Size = UDim2.new(0.23,0,1,-5)
&#9;&#9;&#9;sets.ZIndex = 6
&#9;&#9;&#9;sets.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Sets
&#9;&#9;&#9;&#9;local line = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;line.Name = &quot;Line&quot;
&#9;&#9;&#9;&#9;line.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;line.BackgroundTransparency = 0.7
&#9;&#9;&#9;&#9;line.BorderSizePixel = 0
&#9;&#9;&#9;&#9;line.Position = UDim2.new(1,-3,0.06,0)
&#9;&#9;&#9;&#9;line.Size = UDim2.new(0,3,0.9,0)
&#9;&#9;&#9;&#9;line.ZIndex = 6
&#9;&#9;&#9;&#9;line.Parent = sets
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsLists, controlFrame = t.CreateTrueScrollingFrame()
&#9;&#9;&#9;&#9;setsLists.Size = UDim2.new(1,-6,0.94,0)
&#9;&#9;&#9;&#9;setsLists.Position = UDim2.new(0,0,0.06,0)
&#9;&#9;&#9;&#9;setsLists.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsLists.Name = &quot;SetsLists&quot;
&#9;&#9;&#9;&#9;setsLists.ZIndex = 6
&#9;&#9;&#9;&#9;setsLists.Parent = sets
&#9;&#9;&#9;&#9;drillDownSetZIndex(controlFrame, 7)
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsHeader = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;setsHeader.Name = &quot;SetsHeader&quot;
&#9;&#9;&#9;&#9;setsHeader.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsHeader.Size = UDim2.new(0,47,0,24)
&#9;&#9;&#9;&#9;setsHeader.ZIndex = 6
&#9;&#9;&#9;&#9;setsHeader.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;setsHeader.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;setsHeader.Text = &quot;Sets&quot;
&#9;&#9;&#9;&#9;setsHeader.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setsHeader.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;setsHeader.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;setsHeader.Parent = sets
&#9;&#9;&#9;
&#9;&#9;&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;&#9;&#9;cancelButton.Position = UDim2.new(1,-32,0,-2)
&#9;&#9;&#9;cancelButton.Size = UDim2.new(0,34,0,34)
&#9;&#9;&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;&#9;cancelButton.ZIndex = 6
&#9;&#9;&#9;cancelButton.Text = &quot;&quot;
&#9;&#9;&#9;cancelButton.Modal = true
&#9;&#9;&#9;cancelButton.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Cancel Button
&#9;&#9;&#9;&#9;local cancelImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;cancelImage.Name = &quot;CancelImage&quot;
&#9;&#9;&#9;&#9;cancelImage.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;cancelImage.Image = &quot;rbxasset://ui/cancel.png&quot;
&#9;&#9;&#9;&#9;cancelImage.Position = UDim2.new(0,-2,0,-2)
&#9;&#9;&#9;&#9;cancelImage.Size = UDim2.new(0,16,0,16)
&#9;&#9;&#9;&#9;cancelImage.ZIndex = 6
&#9;&#9;&#9;&#9;cancelImage.Parent = cancelButton
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;return setGui
&#9;end
&#9;
&#9;local function createSetButton(text)
&#9;&#9;local setButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;
&#9;&#9;if text then setButton.Text = text
&#9;&#9;else setButton.Text = &quot;&quot; end
&#9;&#9;
&#9;&#9;setButton.AutoButtonColor = false
&#9;&#9;setButton.BackgroundTransparency = 1
&#9;&#9;setButton.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.BorderSizePixel = 0
&#9;&#9;setButton.Size = UDim2.new(1,-5,0,18)
&#9;&#9;setButton.ZIndex = 6
&#9;&#9;setButton.Visible = false
&#9;&#9;setButton.Font = Enum.Font.Arial
&#9;&#9;setButton.FontSize = Enum.FontSize.Size18
&#9;&#9;setButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;
&#9;&#9;return setButton
&#9;end
&#9;
&#9;local function buildSetButton(name, setId, setImageId, i,  count)
&#9;&#9;local button = createSetButton(name)
&#9;&#9;button.Text = name
&#9;&#9;button.Name = &quot;SetButton&quot;
&#9;&#9;button.Visible = true
&#9;&#9;
&#9;&#9;local setValue = Instance.new(&quot;IntValue&quot;)
&#9;&#9;setValue.Name = &quot;SetId&quot;
&#9;&#9;setValue.Value = setId
&#9;&#9;setValue.Parent = button

&#9;&#9;local setName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;setName.Name = &quot;SetName&quot;
&#9;&#9;setName.Value = name
&#9;&#9;setName.Parent = button

&#9;&#9;return button
&#9;end
&#9;
&#9;local function processCategory(sets)
&#9;&#9;local setButtons = {}
&#9;&#9;local numSkipped = 0
&#9;&#9;for i = 1, #sets do
&#9;&#9;&#9;if not showAdminCategories and sets[i].Name == &quot;Beta&quot; then
&#9;&#9;&#9;&#9;numSkipped = numSkipped + 1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;setButtons[i - numSkipped] = buildSetButton(sets[i].Name, sets[i].CategoryId, sets[i].ImageAssetId, i - numSkipped, #sets)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return setButtons
&#9;end
&#9;
&#9;local function handleResize()
&#9;&#9;wait() -- neccessary to insure heartbeat happened
&#9;&#9;
&#9;&#9;local itemPreview = setGui.SetPanel.ItemPreview
&#9;&#9;
&#9;&#9;itemPreview.LargePreview.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.X)
&#9;&#9;itemPreview.LargePreview.Position = UDim2.new(0.5,-itemPreview.LargePreview.AbsoluteSize.X/2,0,0)
&#9;&#9;itemPreview.TextPanel.Position = UDim2.new(0,0,0,itemPreview.LargePreview.AbsoluteSize.Y)
&#9;&#9;itemPreview.TextPanel.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.Y - itemPreview.LargePreview.AbsoluteSize.Y)
&#9;end
&#9;
&#9;local function makeInsertAssetButton()
&#9;&#9;local insertAssetButtonExample = Instance.new(&quot;Frame&quot;)
&#9;&#9;insertAssetButtonExample.Name = &quot;InsertAssetButtonExample&quot;
&#9;&#9;insertAssetButtonExample.Position = UDim2.new(0,128,0,64)
&#9;&#9;insertAssetButtonExample.Size = UDim2.new(0,64,0,64)
&#9;&#9;insertAssetButtonExample.BackgroundTransparency = 1
&#9;&#9;insertAssetButtonExample.ZIndex = 6
&#9;&#9;insertAssetButtonExample.Visible = false

&#9;&#9;local assetId = Instance.new(&quot;IntValue&quot;)
&#9;&#9;assetId.Name = &quot;AssetId&quot;
&#9;&#9;assetId.Value = 0
&#9;&#9;assetId.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;local assetName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;assetName.Name = &quot;AssetName&quot;
&#9;&#9;assetName.Value = &quot;&quot;
&#9;&#9;assetName.Parent = insertAssetButtonExample

&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot;
&#9;&#9;button.Text = &quot;&quot;
&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;button.Position = UDim2.new(0.025,0,0.025,0)
&#9;&#9;button.Size = UDim2.new(0.95,0,0.95,0)
&#9;&#9;button.ZIndex = 6
&#9;&#9;button.Parent = insertAssetButtonExample

&#9;&#9;local buttonImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;buttonImage.Name = &quot;ButtonImage&quot;
&#9;&#9;buttonImage.Image = &quot;&quot;
&#9;&#9;buttonImage.Position = UDim2.new(0,-7,0,-7)
&#9;&#9;buttonImage.Size = UDim2.new(1,14,1,14)
&#9;&#9;buttonImage.BackgroundTransparency = 1
&#9;&#9;buttonImage.ZIndex = 7
&#9;&#9;buttonImage.Parent = button

&#9;&#9;local configIcon = buttonImage:clone()
&#9;&#9;configIcon.Name = &quot;ConfigIcon&quot;
&#9;&#9;configIcon.Visible = false
&#9;&#9;configIcon.Position = UDim2.new(1,-23,1,-24)
&#9;&#9;configIcon.Size = UDim2.new(0,16,0,16)
&#9;&#9;configIcon.Image = &quot;&quot;
&#9;&#9;configIcon.ZIndex = 6
&#9;&#9;configIcon.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;return insertAssetButtonExample
&#9;end
&#9;
&#9;local function showLargePreview(insertButton)
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetId&quot;) then
&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(LargeThumbnailUrl .. tostring(insertButton.AssetId.Value))
&#9;&#9;&#9;&#9;setGui.SetPanel.ItemPreview.LargePreview.Image = LargeThumbnailUrl .. tostring(insertButton.AssetId.Value)
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetName&quot;) then
&#9;&#9;&#9;setGui.SetPanel.ItemPreview.TextPanel.RolloverText.Text = insertButton.AssetName.Value
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectTerrainShape(shape)
&#9;&#9;if currTerrainDropDownFrame then
&#9;&#9;&#9;objectSelected(tostring(currTerrainDropDownFrame.AssetName.Value), tonumber(currTerrainDropDownFrame.AssetId.Value), shape)
&#9;&#9;end
&#9;end
&#9;
&#9;local function createTerrainTypeButton(name, parent)
&#9;&#9;local dropDownTextButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;dropDownTextButton.Name = name .. &quot;Button&quot;
&#9;&#9;dropDownTextButton.Font = Enum.Font.ArialBold
&#9;&#9;dropDownTextButton.FontSize = Enum.FontSize.Size14
&#9;&#9;dropDownTextButton.BorderSizePixel = 0
&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;dropDownTextButton.Text = name
&#9;&#9;dropDownTextButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;dropDownTextButton.ZIndex = parent.ZIndex + 1
&#9;&#9;dropDownTextButton.Size = UDim2.new(0,parent.Size.X.Offset - 2,0,16)
&#9;&#9;dropDownTextButton.Position = UDim2.new(0,1,0,0)

&#9;&#9;dropDownTextButton.MouseEnter:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 0
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(0,0,0)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseLeave:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;if dropDownTextButton.Parent and dropDownTextButton.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;dropDownTextButton.Parent.Visible = false
&#9;&#9;&#9;end
&#9;&#9;&#9;selectTerrainShape(terrainShapeMap[dropDownTextButton.Text])
&#9;&#9;end)

&#9;&#9;return dropDownTextButton
&#9;end
&#9;
&#9;local function createTerrainDropDownMenu(zIndex)
&#9;&#9;local dropDown = Instance.new(&quot;Frame&quot;)
&#9;&#9;dropDown.Name = &quot;TerrainDropDown&quot;
&#9;&#9;dropDown.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;dropDown.BorderColor3 = Color3.new(1,0,0)
&#9;&#9;dropDown.Size = UDim2.new(0,200,0,0)
&#9;&#9;dropDown.Visible = false
&#9;&#9;dropDown.ZIndex = zIndex
&#9;&#9;dropDown.Parent = setGui

&#9;&#9;for i = 1, #terrainShapes do
&#9;&#9;&#9;local shapeButton = createTerrainTypeButton(terrainShapes[i],dropDown)
&#9;&#9;&#9;shapeButton.Position = UDim2.new(0,1,0,(i - 1) * (shapeButton.Size.Y.Offset))
&#9;&#9;&#9;shapeButton.Parent = dropDown
&#9;&#9;&#9;dropDown.Size = UDim2.new(0,200,0,dropDown.Size.Y.Offset + (shapeButton.Size.Y.Offset))
&#9;&#9;end

&#9;&#9;dropDown.MouseLeave:connect(function()
&#9;&#9;&#9;dropDown.Visible = false
&#9;&#9;end)
&#9;end

&#9;
&#9;local function createDropDownMenuButton(parent)
&#9;&#9;local dropDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;dropDownButton.Name = &quot;DropDownButton&quot;
&#9;&#9;dropDownButton.Image = &quot;rbxasset://ui/dropdownbutton.png&quot;
&#9;&#9;dropDownButton.BackgroundTransparency = 1
&#9;&#9;dropDownButton.Size = UDim2.new(0,16,0,16)
&#9;&#9;dropDownButton.Position = UDim2.new(1,-24,0,6)
&#9;&#9;dropDownButton.ZIndex = parent.ZIndex + 2
&#9;&#9;dropDownButton.Parent = parent
&#9;&#9;
&#9;&#9;if not setGui:FindFirstChild(&quot;TerrainDropDown&quot;) then
&#9;&#9;&#9;createTerrainDropDownMenu(8)
&#9;&#9;end
&#9;&#9;
&#9;&#9;dropDownButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;setGui.TerrainDropDown.Visible = true
&#9;&#9;&#9;setGui.TerrainDropDown.Position = UDim2.new(0,parent.AbsolutePosition.X,0,parent.AbsolutePosition.Y)
&#9;&#9;&#9;currTerrainDropDownFrame = parent
&#9;&#9;end)
&#9;end
&#9;
&#9;local function buildInsertButton()
&#9;&#9;local insertButton = makeInsertAssetButton()
&#9;&#9;insertButton.Name = &quot;InsertAssetButton&quot;
&#9;&#9;insertButton.Visible = true

&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;createDropDownMenuButton(insertButton)
&#9;&#9;end

&#9;&#9;local lastEnter = nil
&#9;&#9;local mouseEnterCon = insertButton.MouseEnter:connect(function()
&#9;&#9;&#9;lastEnter = insertButton
&#9;&#9;&#9;delay(0.1,function()
&#9;&#9;&#9;&#9;if lastEnter == insertButton then
&#9;&#9;&#9;&#9;&#9;showLargePreview(insertButton)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end)
&#9;&#9;return insertButton, mouseEnterCon
&#9;end
&#9;
&#9;local function realignButtonGrid(columns)
&#9;&#9;local x = 0
&#9;&#9;local y = 0 
&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;insertButtons[i].Position = UDim2.new(0, buttonWidth * x, 0, buttonHeight * y)
&#9;&#9;&#9;x = x + 1
&#9;&#9;&#9;if x &gt;= columns then
&#9;&#9;&#9;&#9;x = 0
&#9;&#9;&#9;&#9;y = y + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function setInsertButtonImageBehavior(insertFrame, visible, name, assetId)
&#9;&#9;if visible then
&#9;&#9;&#9;insertFrame.AssetName.Value = name
&#9;&#9;&#9;insertFrame.AssetId.Value = assetId
&#9;&#9;&#9;local newImageUrl = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;if newImageUrl ~= insertFrame.Button.ButtonImage.Image then
&#9;&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(SmallThumbnailUrl  .. assetId)
&#9;&#9;&#9;&#9;&#9;insertFrame.Button.ButtonImage.Image = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;table.insert(insertButtonCons,
&#9;&#9;&#9;&#9;insertFrame.Button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;-- special case for water, show water selection gui
&#9;&#9;&#9;&#9;&#9;local isWaterSelected = (name == &quot;Water&quot;) and (Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot;)
&#9;&#9;&#9;&#9;&#9;waterGui.Visible = isWaterSelected
&#9;&#9;&#9;&#9;&#9;if isWaterSelected then
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId), nil)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId))
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;)
&#9;&#9;&#9;insertFrame.Visible = true
&#9;&#9;else
&#9;&#9;&#9;insertFrame.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local function loadSectionOfItems(setGui, rows, columns)
&#9;&#9;local pageSize = rows * columns

&#9;&#9;if arrayPosition &gt; #contents then return end

&#9;&#9;local origArrayPos = arrayPosition

&#9;&#9;local yCopy = 0
&#9;&#9;for i = 1, pageSize + 1 do 
&#9;&#9;&#9;if arrayPosition &gt;= #contents + 1 then
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end

&#9;&#9;&#9;local buttonCon
&#9;&#9;&#9;insertButtons[arrayPosition], buttonCon = buildInsertButton()
&#9;&#9;&#9;table.insert(insertButtonCons,buttonCon)
&#9;&#9;&#9;insertButtons[arrayPosition].Parent = setGui.SetPanel.ItemsFrame
&#9;&#9;&#9;arrayPosition = arrayPosition + 1
&#9;&#9;end
&#9;&#9;realignButtonGrid(columns)

&#9;&#9;local indexCopy = origArrayPos
&#9;&#9;for index = origArrayPos, arrayPosition do
&#9;&#9;&#9;if insertButtons[index] then
&#9;&#9;&#9;&#9;if contents[index] then

&#9;&#9;&#9;&#9;&#9;-- we don&apos;t want water to have a drop down button
&#9;&#9;&#9;&#9;&#9;if contents[index].Name == &quot;Water&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;insertButtons[index]:FindFirstChild(&quot;DropDownButton&quot;,true):Destroy()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;local assetId
&#9;&#9;&#9;&#9;&#9;if useAssetVersionId then
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetVersionId
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;setInsertButtonImageBehavior(insertButtons[index], true, contents[index].Name, assetId)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;&#9;indexCopy = index
&#9;&#9;end
&#9;end
&#9;
&#9;local function setSetIndex()
&#9;&#9;Data.Category[Data.CurrentCategory].Index = 0

&#9;&#9;rows = 7
&#9;&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;&#9;contents = Data.Category[Data.CurrentCategory].Contents
&#9;&#9;if contents then
&#9;&#9;&#9;-- remove our buttons and their connections
&#9;&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;&#9;insertButtons[i]:remove()
&#9;&#9;&#9;end
&#9;&#9;&#9;for i = 1, #insertButtonCons do
&#9;&#9;&#9;&#9;if insertButtonCons[i] then insertButtonCons[i]:disconnect() end
&#9;&#9;&#9;end
&#9;&#9;&#9;insertButtonCons = {}
&#9;&#9;&#9;insertButtons = {}

&#9;&#9;&#9;arrayPosition = 1
&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectSet(button, setName, setId, setIndex)
&#9;&#9;if button and Data.Category[Data.CurrentCategory] ~= nil then
&#9;&#9;&#9;if button ~= Data.Category[Data.CurrentCategory].Button then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = button

&#9;&#9;&#9;&#9;if SetCache[setId] == nil then
&#9;&#9;&#9;&#9;&#9;SetCache[setId] = game:GetService(&quot;InsertService&quot;):GetCollection(setId)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Contents = SetCache[setId]

&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetName = setName
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetId = setId
&#9;&#9;&#9;end
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategoryPage(buttons, page)
&#9;&#9;if buttons ~= Data.CurrentCategory then
&#9;&#9;&#9;if Data.CurrentCategory then
&#9;&#9;&#9;&#9;for key, button in pairs(Data.CurrentCategory) do
&#9;&#9;&#9;&#9;&#9;button.Visible = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;Data.CurrentCategory = buttons
&#9;&#9;&#9;if Data.Category[Data.CurrentCategory] == nil then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory] = {}
&#9;&#9;&#9;&#9;if #buttons &gt; 0 then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[1], buttons[1].SetName.Value, buttons[1].SetId.Value, 0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = nil
&#9;&#9;&#9;&#9;selectSet(Data.Category[Data.CurrentCategory].ButtonFrame, Data.Category[Data.CurrentCategory].SetName, Data.Category[Data.CurrentCategory].SetId, Data.Category[Data.CurrentCategory].Index)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategory(category)
&#9;&#9;selectCategoryPage(category, 0)
&#9;end
&#9;
&#9;local function resetAllSetButtonSelection()
&#9;&#9;local setButtons = setGui.SetPanel.Sets.SetsLists:GetChildren()
&#9;&#9;for i = 1, #setButtons do
&#9;&#9;&#9;if setButtons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;setButtons[i].Selected = false
&#9;&#9;&#9;&#9;setButtons[i].BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setButtons[i].TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setButtons[i].BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function populateSetsFrame()
&#9;&#9;local currRow = 0
&#9;&#9;for i = 1, #userCategoryButtons do
&#9;&#9;&#9;local button = userCategoryButtons[i]
&#9;&#9;&#9;button.Visible = true
&#9;&#9;&#9;button.Position = UDim2.new(0,5,0,currRow * button.Size.Y.Offset)
&#9;&#9;&#9;button.Parent = setGui.SetPanel.Sets.SetsLists
&#9;&#9;&#9;
&#9;&#9;&#9;if i == 1 then -- we will have this selected by default, so show it
&#9;&#9;&#9;&#9;button.Selected = true
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;end

&#9;&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;resetAllSetButtonSelection()
&#9;&#9;&#9;&#9;button.Selected = not button.Selected
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;selectSet(button, button.Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;end)

&#9;&#9;&#9;currRow = currRow + 1
&#9;&#9;end

&#9;&#9;local buttons =  setGui.SetPanel.Sets.SetsLists:GetChildren()

&#9;&#9;-- set first category as loaded for default
&#9;&#9;if buttons then
&#9;&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;&#9;if buttons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[i], buttons[i].Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;&#9;&#9;selectCategory(userCategoryButtons)
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;setGui = createSetGui()
&#9;waterGui, waterTypeChangedEvent = createWaterGui()
&#9;waterGui.Position = UDim2.new(0,55,0,0)
&#9;waterGui.Parent = setGui
&#9;setGui.Changed:connect(function(prop) -- this resizes the preview image to always be the right size
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;handleResize()
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end)
&#9;
&#9;local scrollFrame, controlFrame = t.CreateTrueScrollingFrame()
&#9;scrollFrame.Size = UDim2.new(0.54,0,0.85,0)
&#9;scrollFrame.Position = UDim2.new(0.24,0,0.085,0)
&#9;scrollFrame.Name = &quot;ItemsFrame&quot;
&#9;scrollFrame.ZIndex = 6
&#9;scrollFrame.Parent = setGui.SetPanel
&#9;scrollFrame.BackgroundTransparency = 1

&#9;drillDownSetZIndex(controlFrame,7)

&#9;controlFrame.Parent = setGui.SetPanel
&#9;controlFrame.Position = UDim2.new(0.76, 5, 0, 0)

&#9;local debounce = false
&#9;controlFrame.ScrollBottom.Changed:connect(function(prop)
&#9;&#9;if controlFrame.ScrollBottom.Value == true then
&#9;&#9;&#9;if debounce then return end
&#9;&#9;&#9;debounce = true
&#9;&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;&#9;debounce = false
&#9;&#9;end
&#9;end)

&#9;local userData = {}
&#9;for id = 1, #userIdsForSets do
&#9;&#9;local newUserData = game:GetService(&quot;InsertService&quot;):GetUserSets(userIdsForSets[id])
&#9;&#9;if newUserData and #newUserData &gt; 2 then
&#9;&#9;&#9;-- start at #3 to skip over My Decals and My Models for each account
&#9;&#9;&#9;for category = 3, #newUserData do
&#9;&#9;&#9;&#9;if newUserData[category].Name == &quot;High Scalability&quot; then -- we want high scalability parts to show first
&#9;&#9;&#9;&#9;&#9;table.insert(userData,1,newUserData[category])
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;table.insert(userData, newUserData[category])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;
&#9;end
&#9;if userData then
&#9;&#9;userCategoryButtons = processCategory(userData)
&#9;end

&#9;rows = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;populateSetsFrame()

&#9;insertPanelCloseCon = setGui.SetPanel.CancelButton.MouseButton1Click:connect(function()
&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;if dialogClosed then dialogClosed() end
&#9;end)
&#9;
&#9;local setVisibilityFunction = function(visible)
&#9;&#9;if visible then
&#9;&#9;&#9;setGui.SetPanel.Visible = true
&#9;&#9;else
&#9;&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local getVisibilityFunction = function()
&#9;&#9;if setGui then
&#9;&#9;&#9;if setGui:FindFirstChild(&quot;SetPanel&quot;) then
&#9;&#9;&#9;&#9;return setGui.SetPanel.Visible
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;return false
&#9;end
&#9;
&#9;return setGui, setVisibilityFunction, getVisibilityFunction, waterTypeChangedEvent
end

t.CreateTerrainMaterialSelector = function(size,position)
&#9;local terrainMaterialSelectionChanged = Instance.new(&quot;BindableEvent&quot;)
&#9;terrainMaterialSelectionChanged.Name = &quot;TerrainMaterialSelectionChanged&quot;

&#9;local selectedButton = nil

&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TerrainMaterialSelector&quot;
&#9;if size then
&#9;&#9;frame.Size = size
&#9;else
&#9;&#9;frame.Size = UDim2.new(0, 245, 0, 230)
&#9;end
&#9;if position then
&#9;&#9;frame.Position = position
&#9;end
&#9;frame.BorderSizePixel = 0
&#9;frame.BackgroundColor3 = Color3.new(0,0,0)
&#9;frame.Active = true

&#9;terrainMaterialSelectionChanged.Parent = frame

&#9;local waterEnabled = true -- todo: turn this on when water is ready

&#9;local materialToImageMap = {}
&#9;local materialNames = {&quot;Grass&quot;, &quot;Sand&quot;, &quot;Brick&quot;, &quot;Granite&quot;, &quot;Asphalt&quot;, &quot;Iron&quot;, &quot;Aluminum&quot;, &quot;Gold&quot;, &quot;Plank&quot;, &quot;Log&quot;, &quot;Gravel&quot;, &quot;Cinder Block&quot;, &quot;Stone Wall&quot;, &quot;Concrete&quot;, &quot;Plastic (red)&quot;, &quot;Plastic (blue)&quot;}
&#9;if waterEnabled then
&#9;&#9;table.insert(materialNames,&quot;Water&quot;)
&#9;end
&#9;local currentMaterial = 1

&#9;function getEnumFromName(choice)
&#9;&#9;if choice == &quot;Grass&quot; then return 1 end
&#9;&#9;if choice == &quot;Sand&quot; then return 2 end 
&#9;&#9;if choice == &quot;Erase&quot; then return 0 end
&#9;&#9;if choice == &quot;Brick&quot; then return 3 end
&#9;&#9;if choice == &quot;Granite&quot; then return 4 end
&#9;&#9;if choice == &quot;Asphalt&quot; then return 5 end
&#9;&#9;if choice == &quot;Iron&quot; then return 6 end
&#9;&#9;if choice == &quot;Aluminum&quot; then return 7 end
&#9;&#9;if choice == &quot;Gold&quot; then return 8 end
&#9;&#9;if choice == &quot;Plank&quot; then return 9 end
&#9;&#9;if choice == &quot;Log&quot; then return 10 end
&#9;&#9;if choice == &quot;Gravel&quot; then return 11 end
&#9;&#9;if choice == &quot;Cinder Block&quot; then return 12 end
&#9;&#9;if choice == &quot;Stone Wall&quot; then return 13 end
&#9;&#9;if choice == &quot;Concrete&quot; then return 14 end
&#9;&#9;if choice == &quot;Plastic (red)&quot; then return 15 end
&#9;&#9;if choice == &quot;Plastic (blue)&quot; then return 16 end
&#9;&#9;if choice == &quot;Water&quot; then return 17 end
&#9;end

&#9;function getNameFromEnum(choice)
&#9;&#9;if choice == Enum.CellMaterial.Grass or choice == 1 then return &quot;Grass&quot;end
&#9;&#9;if choice == Enum.CellMaterial.Sand or choice == 2 then return &quot;Sand&quot; end 
&#9;&#9;if choice == Enum.CellMaterial.Empty or choice == 0 then return &quot;Erase&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Brick or choice == 3 then return &quot;Brick&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Granite or choice == 4 then return &quot;Granite&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Asphalt or choice == 5 then return &quot;Asphalt&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Iron or choice == 6 then return &quot;Iron&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Aluminum or choice == 7 then return &quot;Aluminum&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gold or choice == 8 then return &quot;Gold&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodPlank or choice == 9 then return &quot;Plank&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodLog or choice == 10 then return &quot;Log&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gravel or choice == 11 then return &quot;Gravel&quot; end
&#9;&#9;if choice == Enum.CellMaterial.CinderBlock or choice == 12 then return &quot;Cinder Block&quot; end
&#9;&#9;if choice == Enum.CellMaterial.MossyStone or choice == 13 then return &quot;Stone Wall&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Cement or choice == 14 then return &quot;Concrete&quot; end
&#9;&#9;if choice == Enum.CellMaterial.RedPlastic or choice == 15 then return &quot;Plastic (red)&quot; end
&#9;&#9;if choice == Enum.CellMaterial.BluePlastic or choice == 16 then return &quot;Plastic (blue)&quot; end

&#9;&#9;if waterEnabled then
&#9;&#9;&#9;if choice == Enum.CellMaterial.Water or choice == 17 then return &quot;Water&quot; end
&#9;&#9;end
&#9;end


&#9;local function updateMaterialChoice(choice)
&#9;&#9;currentMaterial = getEnumFromName(choice)
&#9;&#9;terrainMaterialSelectionChanged:Fire(currentMaterial)
&#9;end

&#9;-- we so need a better way to do this
&#9;for i,v in pairs(materialNames) do
&#9;&#9;materialToImageMap[v] = {}
&#9;&#9;if v == &quot;Grass&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Grass.png&quot;
&#9;&#9;elseif v == &quot;Sand&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Sand.png&quot;
&#9;&#9;elseif v == &quot;Brick&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Brick.png&quot;
&#9;&#9;elseif v == &quot;Granite&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Granite.png&quot;
&#9;&#9;elseif v == &quot;Asphalt&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Asphalt.png&quot;
&#9;&#9;elseif v == &quot;Iron&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Iron.png&quot;
&#9;&#9;elseif v == &quot;Aluminum&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Aluminum.png&quot;
&#9;&#9;elseif v == &quot;Gold&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Gold.png&quot;
&#9;&#9;elseif v == &quot;Plastic (red)&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/PlasticRed.png&quot;
&#9;&#9;elseif v == &quot;Plastic (blue)&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/PlasticBlue.png&quot;
&#9;&#9;elseif v == &quot;Plank&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Plank.png&quot;
&#9;&#9;elseif v == &quot;Log&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Log.png&quot;
&#9;&#9;elseif v == &quot;Gravel&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Gravel.png&quot;
&#9;&#9;elseif v == &quot;Cinder Block&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/CinderBlock.png&quot;
&#9;&#9;elseif v == &quot;Stone Wall&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/StoneWall.png&quot;
&#9;&#9;elseif v == &quot;Concrete&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Concrete.png&quot;
&#9;&#9;elseif v == &quot;Water&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Water.png&quot;
&#9;&#9;else materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/unknown.png&quot; -- fill in the rest here!!
&#9;&#9;end
&#9;end

&#9;local scrollFrame, scrollUp, scrollDown, recalculateScroll = t.CreateScrollingFrame(nil,&quot;grid&quot;)
&#9;scrollFrame.Size = UDim2.new(0.85,0,1,0)
&#9;scrollFrame.Position = UDim2.new(0,0,0,0)
&#9;scrollFrame.Parent = frame

&#9;scrollUp.Parent = frame
&#9;scrollUp.Visible = true
&#9;scrollUp.Position = UDim2.new(1,-19,0,0)

&#9;scrollDown.Parent = frame
&#9;scrollDown.Visible = true
&#9;scrollDown.Position = UDim2.new(1,-19,1,-17)

&#9;local function goToNewMaterial(buttonWrap, materialName)
&#9;&#9;updateMaterialChoice(materialName)
&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;selectedButton.BackgroundTransparency = 1
&#9;&#9;selectedButton = buttonWrap
&#9;end

&#9;local function createMaterialButton(name)&#9;
&#9;&#9;local buttonWrap = Instance.new(&quot;TextButton&quot;)
&#9;&#9;buttonWrap.Text = &quot;&quot;
&#9;&#9;buttonWrap.Size = UDim2.new(0,32,0,32)
&#9;&#9;buttonWrap.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;buttonWrap.BorderSizePixel = 0
&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;buttonWrap.AutoButtonColor = false
&#9;&#9;buttonWrap.Name = tostring(name)
&#9;&#9;
&#9;&#9;local imageButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;imageButton.AutoButtonColor = false
&#9;&#9;imageButton.BackgroundTransparency = 1
&#9;&#9;imageButton.Size = UDim2.new(0,30,0,30)
&#9;&#9;imageButton.Position = UDim2.new(0,1,0,1)
&#9;&#9;imageButton.Name = tostring(name)
&#9;&#9;imageButton.Parent = buttonWrap
&#9;&#9;imageButton.Image = materialToImageMap[name].Regular

&#9;&#9;local enumType = Instance.new(&quot;NumberValue&quot;)
&#9;&#9;enumType.Name = &quot;EnumType&quot;
&#9;&#9;enumType.Parent = buttonWrap
&#9;&#9;enumType.Value = 0
&#9;&#9;
&#9;&#9;imageButton.MouseEnter:connect(function()
&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;imageButton.MouseLeave:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;imageButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;goToNewMaterial(buttonWrap, tostring(name))
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;
&#9;&#9;return buttonWrap 
&#9;end

&#9;for i = 1, #materialNames do
&#9;&#9;local imageButton = createMaterialButton(materialNames[i])
&#9;&#9;
&#9;&#9;if materialNames[i] == &quot;Grass&quot; then -- always start with grass as the default
&#9;&#9;&#9;selectedButton = imageButton
&#9;&#9;&#9;imageButton.BackgroundTransparency = 0
&#9;&#9;end
&#9;&#9;
&#9;&#9;imageButton.Parent = scrollFrame
&#9;end

&#9;local forceTerrainMaterialSelection = function(newMaterialType)
&#9;&#9;if not newMaterialType then return end
&#9;&#9;if currentMaterial == newMaterialType then return end

&#9;&#9;local matName = getNameFromEnum(newMaterialType)
&#9;&#9;local buttons = scrollFrame:GetChildren()
&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (blue)&quot; and matName == &quot;Plastic (blue)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (red)&quot; and matName == &quot;Plastic (red)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if string.find(buttons[i].Name, matName) then
&#9;&#9;&#9;&#9;goToNewMaterial(buttons[i],matName)
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(function ( prop )
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;recalculateScroll()
&#9;&#9;end
&#9;end)

&#9;recalculateScroll()
&#9;return frame, terrainMaterialSelectionChanged, forceTerrainMaterialSelection
end

t.CreateLoadingFrame = function(name,size,position)
&#9;game:GetService(&quot;ContentProvider&quot;):Preload(&quot;rbxasset://ui/loadingbar.png&quot;)

&#9;local loadingFrame = Instance.new(&quot;Frame&quot;)
&#9;loadingFrame.Name = &quot;LoadingFrame&quot;
&#9;loadingFrame.Style = Enum.FrameStyle.RobloxRound

&#9;if size then loadingFrame.Size = size
&#9;else loadingFrame.Size = UDim2.new(0,300,0,160) end
&#9;if position then loadingFrame.Position = position 
&#9;else loadingFrame.Position = UDim2.new(0.5, -150, 0.5,-80) end

&#9;local loadingBar = Instance.new(&quot;Frame&quot;)
&#9;loadingBar.Name = &quot;LoadingBar&quot;
&#9;loadingBar.BackgroundColor3 = Color3.new(0,0,0)
&#9;loadingBar.BorderColor3 = Color3.new(79/255,79/255,79/255)
&#9;loadingBar.Position = UDim2.new(0,0,0,41)
&#9;loadingBar.Size = UDim2.new(1,0,0,30)
&#9;loadingBar.Parent = loadingFrame

&#9;&#9;local loadingGreenBar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;loadingGreenBar.Name = &quot;LoadingGreenBar&quot;
&#9;&#9;loadingGreenBar.Image = &quot;rbxasset://ui/loadingbar.png&quot;
&#9;&#9;loadingGreenBar.Position = UDim2.new(0,0,0,0)
&#9;&#9;loadingGreenBar.Size = UDim2.new(0,0,1,0)
&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;loadingGreenBar.Parent = loadingBar

&#9;&#9;local loadingPercent = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;loadingPercent.Name = &quot;LoadingPercent&quot;
&#9;&#9;loadingPercent.BackgroundTransparency = 1
&#9;&#9;loadingPercent.Position = UDim2.new(0,0,1,0)
&#9;&#9;loadingPercent.Size = UDim2.new(1,0,0,14)
&#9;&#9;loadingPercent.Font = Enum.Font.Arial
&#9;&#9;loadingPercent.Text = &quot;0%&quot;
&#9;&#9;loadingPercent.FontSize = Enum.FontSize.Size14
&#9;&#9;loadingPercent.TextColor3 = Color3.new(1,1,1)
&#9;&#9;loadingPercent.Parent = loadingBar

&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;cancelButton.Position = UDim2.new(0.5,-60,1,-40)
&#9;cancelButton.Size = UDim2.new(0,120,0,40)
&#9;cancelButton.Font = Enum.Font.Arial
&#9;cancelButton.FontSize = Enum.FontSize.Size18
&#9;cancelButton.TextColor3 = Color3.new(1,1,1)
&#9;cancelButton.Text = &quot;Cancel&quot;
&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButton
&#9;cancelButton.Parent = loadingFrame

&#9;local loadingName = Instance.new(&quot;TextLabel&quot;)
&#9;loadingName.Name = &quot;loadingName&quot;
&#9;loadingName.BackgroundTransparency = 1
&#9;loadingName.Size = UDim2.new(1,0,0,18)
&#9;loadingName.Position = UDim2.new(0,0,0,2)
&#9;loadingName.Font = Enum.Font.Arial
&#9;loadingName.Text = name
&#9;loadingName.TextColor3 = Color3.new(1,1,1)
&#9;loadingName.TextStrokeTransparency = 1
&#9;loadingName.FontSize = Enum.FontSize.Size18
&#9;loadingName.Parent = loadingFrame

&#9;local cancelButtonClicked = Instance.new(&quot;BindableEvent&quot;)
&#9;cancelButtonClicked.Name = &quot;CancelButtonClicked&quot;
&#9;cancelButtonClicked.Parent = cancelButton
&#9;cancelButton.MouseButton1Click:connect(function()
&#9;&#9;cancelButtonClicked:Fire()
&#9;end)

&#9;local updateLoadingGuiPercent = function(percent, tweenAction, tweenLength)
&#9;&#9;if percent and type(percent) ~= &quot;number&quot; then
&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent expects number as argument, got&quot;,type(percent),&quot;instead&quot;)
&#9;&#9;end

&#9;&#9;local newSize = nil
&#9;&#9;if percent &lt; 0 then
&#9;&#9;&#9;newSize = UDim2.new(0,0,1,0)
&#9;&#9;elseif percent &gt; 1 then
&#9;&#9;&#9;newSize = UDim2.new(1,0,1,0)
&#9;&#9;else
&#9;&#9;&#9;newSize = UDim2.new(percent,0,1,0)
&#9;&#9;end

&#9;&#9;if tweenAction then
&#9;&#9;&#9;if not tweenLength then
&#9;&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent is set to tween new percentage, but got no tween time length! Please pass this in as third argument&quot;)
&#9;&#9;&#9;end

&#9;&#9;&#9;if (newSize.X.Scale &gt; 0) then
&#9;&#9;&#9;&#9;loadingGreenBar.Visible = true
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function() 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (newSize.X.Scale &lt; 0) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end

&#9;&#9;else
&#9;&#9;&#9;loadingGreenBar.Size = newSize
&#9;&#9;&#9;loadingGreenBar.Visible = (newSize.X.Scale &gt; 0)
&#9;&#9;end
&#9;end

&#9;loadingGreenBar.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Size&quot; then
&#9;&#9;&#9;loadingPercent.Text = tostring( math.ceil(loadingGreenBar.Size.X.Scale * 100) ) .. &quot;%&quot;
&#9;&#9;end
&#9;end)

&#9;return loadingFrame, updateLoadingGuiPercent, cancelButtonClicked
end

t.CreatePluginFrame = function (name,size,position,scrollable,parent)
&#9;function createMenuButton(size,position,text,fontsize,name,parent)
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;,parent)
&#9;&#9;button.AutoButtonColor = false
&#9;&#9;button.Name = name
&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;button.Position = position
&#9;&#9;button.Size = size
&#9;&#9;button.Font = Enum.Font.ArialBold
&#9;&#9;button.FontSize = fontsize
&#9;&#9;button.Text =  text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.BorderSizePixel = 0
&#9;&#9;button.BackgroundColor3 = Color3.new(20/255,20/255,20/255)

&#9;&#9;button.MouseEnter:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;button.MouseLeave:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)

&#9;&#9;return button

&#9;end

&#9;local dragBar = Instance.new(&quot;Frame&quot;,parent)
&#9;dragBar.Name = tostring(name) .. &quot;DragBar&quot;
&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;dragBar.BorderColor3 = Color3.new(0,0,0)
&#9;if size then
&#9;&#9;dragBar.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,20)  + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;dragBar.Size = UDim2.new(0,183,0,20)
&#9;end
&#9;if position then
&#9;&#9;dragBar.Position = position
&#9;end
&#9;dragBar.Active = true
&#9;dragBar.Draggable = true
&#9;--dragBar.Visible = false
&#9;dragBar.MouseEnter:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(49/255,49/255,49/255)
&#9;end)
&#9;dragBar.MouseLeave:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;end)

&#9;-- plugin name label
&#9;local pluginNameLabel = Instance.new(&quot;TextLabel&quot;,dragBar)
&#9;pluginNameLabel.Name = &quot;BarNameLabel&quot;
&#9;pluginNameLabel.Text = &quot; &quot; .. tostring(name)
&#9;pluginNameLabel.TextColor3 = Color3.new(1,1,1)
&#9;pluginNameLabel.TextStrokeTransparency = 0
&#9;pluginNameLabel.Size = UDim2.new(1,0,1,0)
&#9;pluginNameLabel.Font = Enum.Font.ArialBold
&#9;pluginNameLabel.FontSize = Enum.FontSize.Size18
&#9;pluginNameLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;pluginNameLabel.BackgroundTransparency = 1

&#9;-- close button
&#9;local closeButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-16,0.5,-8),&quot;X&quot;,Enum.FontSize.Size14,&quot;CloseButton&quot;,dragBar)
&#9;local closeEvent = Instance.new(&quot;BindableEvent&quot;)
&#9;closeEvent.Name = &quot;CloseEvent&quot;
&#9;closeEvent.Parent = closeButton
&#9;closeButton.MouseButton1Click:connect(function ()
&#9;&#9;closeEvent:Fire()
&#9;&#9;closeButton.BackgroundTransparency = 1
&#9;end)

&#9;-- help button
&#9;local helpButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-51,0.5,-8),&quot;?&quot;,Enum.FontSize.Size14,&quot;HelpButton&quot;,dragBar)
&#9;local helpFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;helpFrame.Name = &quot;HelpFrame&quot;
&#9;helpFrame.BackgroundColor3 = Color3.new(0,0,0)
&#9;helpFrame.Size = UDim2.new(0,300,0,552)
&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;helpFrame.Active = true
&#9;helpFrame.BorderSizePixel = 0
&#9;helpFrame.Visible = false

&#9;helpButton.MouseButton1Click:connect(function(  )
&#9;&#9;helpFrame.Visible = not helpFrame.Visible
&#9;&#9;if helpFrame.Visible then
&#9;&#9;&#9;helpButton.Selected = true
&#9;&#9;&#9;helpButton.BackgroundTransparency = 0
&#9;&#9;&#9;local screenGui = getScreenGuiAncestor(helpFrame)
&#9;&#9;&#9;if screenGui then
&#9;&#9;&#9;&#9;if helpFrame.AbsolutePosition.X + helpFrame.AbsoluteSize.X &gt; screenGui.AbsoluteSize.X then --position on left hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(0,-5 - helpFrame.AbsoluteSize.X,0,0)
&#9;&#9;&#9;&#9;else -- position on right hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;helpButton.Selected = false
&#9;&#9;&#9;helpButton.BackgroundTransparency = 1
&#9;&#9;end
&#9;end)

&#9;local minimizeButton = createMenuButton(UDim2.new(0,16,0,17),UDim2.new(1,-34,0.5,-8),&quot;-&quot;,Enum.FontSize.Size14,&quot;MinimizeButton&quot;,dragBar)
&#9;minimizeButton.TextYAlignment = Enum.TextYAlignment.Top

&#9;local minimizeFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;minimizeFrame.Name = &quot;MinimizeFrame&quot;
&#9;minimizeFrame.BackgroundColor3 = Color3.new(73/255,73/255,73/255)
&#9;minimizeFrame.BorderColor3 = Color3.new(0,0,0)
&#9;minimizeFrame.Position = UDim2.new(0,0,1,0)
&#9;if size then
&#9;&#9;minimizeFrame.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,50) + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;minimizeFrame.Size = UDim2.new(0,183,0,50)
&#9;end
&#9;minimizeFrame.Visible = false

&#9;local minimizeBigButton = Instance.new(&quot;TextButton&quot;,minimizeFrame)
&#9;minimizeBigButton.Position = UDim2.new(0.5,-50,0.5,-20)
&#9;minimizeBigButton.Name = &quot;MinimizeButton&quot;
&#9;minimizeBigButton.Size = UDim2.new(0,100,0,40)
&#9;minimizeBigButton.Style = Enum.ButtonStyle.RobloxButton
&#9;minimizeBigButton.Font = Enum.Font.ArialBold
&#9;minimizeBigButton.FontSize = Enum.FontSize.Size18
&#9;minimizeBigButton.TextColor3 = Color3.new(1,1,1)
&#9;minimizeBigButton.Text = &quot;Show&quot;

&#9;local separatingLine = Instance.new(&quot;Frame&quot;,dragBar)
&#9;separatingLine.Name = &quot;SeparatingLine&quot;
&#9;separatingLine.BackgroundColor3 = Color3.new(115/255,115/255,115/255)
&#9;separatingLine.BorderSizePixel = 0
&#9;separatingLine.Position = UDim2.new(1,-18,0.5,-7)
&#9;separatingLine.Size = UDim2.new(0,1,0,14)

&#9;local otherSeparatingLine = separatingLine:clone()
&#9;otherSeparatingLine.Position = UDim2.new(1,-35,0.5,-7)
&#9;otherSeparatingLine.Parent = dragBar

&#9;local widgetContainer = Instance.new(&quot;Frame&quot;,dragBar)
&#9;widgetContainer.Name = &quot;WidgetContainer&quot;
&#9;widgetContainer.BackgroundTransparency = 1
&#9;widgetContainer.Position = UDim2.new(0,0,1,0)
&#9;widgetContainer.BorderColor3 = Color3.new(0,0,0)
&#9;if not scrollable then
&#9;&#9;widgetContainer.BackgroundTransparency = 0
&#9;&#9;widgetContainer.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;end

&#9;if size then
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = size
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,size.Y.Scale,size.Y.Offset)
&#9;&#9;end
&#9;else
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,163,0,400)
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,0,400)
&#9;&#9;end
&#9;end
&#9;if position then
&#9;&#9;widgetContainer.Position = position + UDim2.new(0,0,0,20)
&#9;end

&#9;local frame,control,verticalDragger = nil
&#9;if scrollable then
&#9;&#9;--frame for widgets
&#9;&#9;frame,control = t.CreateTrueScrollingFrame()
&#9;&#9;frame.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;frame.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;frame.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;frame.Active = true
&#9;&#9;frame.Parent = widgetContainer
&#9;&#9;control.Parent = dragBar
&#9;&#9;control.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;control.BorderSizePixel = 0
&#9;&#9;control.BackgroundTransparency = 0
&#9;&#9;control.Position = UDim2.new(1,-21,1,1)
&#9;&#9;if size then
&#9;&#9;&#9;control.Size = UDim2.new(0,21,size.Y.Scale,size.Y.Offset)
&#9;&#9;else
&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,400)
&#9;&#9;end
&#9;&#9;control:FindFirstChild(&quot;ScrollDownButton&quot;).Position = UDim2.new(0,0,1,-20)

&#9;&#9;local fakeLine = Instance.new(&quot;Frame&quot;,control)
&#9;&#9;fakeLine.Name = &quot;FakeLine&quot;
&#9;&#9;fakeLine.BorderSizePixel = 0
&#9;&#9;fakeLine.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;fakeLine.Size = UDim2.new(0,1,1,1)
&#9;&#9;fakeLine.Position = UDim2.new(1,0,0,0)

&#9;&#9;verticalDragger = Instance.new(&quot;TextButton&quot;,widgetContainer)
&#9;&#9;verticalDragger.ZIndex = 2
&#9;&#9;verticalDragger.AutoButtonColor = false
&#9;&#9;verticalDragger.Name = &quot;VerticalDragger&quot;
&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;verticalDragger.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;verticalDragger.Size = UDim2.new(1,20,0,20)
&#9;&#9;verticalDragger.Position = UDim2.new(0,0,1,0)
&#9;&#9;verticalDragger.Active = true
&#9;&#9;verticalDragger.Text = &quot;&quot;

&#9;&#9;local scrubFrame = Instance.new(&quot;Frame&quot;,verticalDragger)
&#9;&#9;scrubFrame.Name = &quot;ScrubFrame&quot;
&#9;&#9;scrubFrame.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;scrubFrame.BorderSizePixel = 0
&#9;&#9;scrubFrame.Position = UDim2.new(0.5,-5,0.5,0)
&#9;&#9;scrubFrame.Size = UDim2.new(0,10,0,1)
&#9;&#9;scrubFrame.ZIndex = 5
&#9;&#9;local scrubTwo = scrubFrame:clone()
&#9;&#9;scrubTwo.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;&#9;scrubTwo.Parent = verticalDragger
&#9;&#9;local scrubThree = scrubFrame:clone()
&#9;&#9;scrubThree.Position = UDim2.new(0.5,-5,0.5,2)
&#9;&#9;scrubThree.Parent = verticalDragger

&#9;&#9;local areaSoak = Instance.new(&quot;TextButton&quot;,getScreenGuiAncestor(parent))
&#9;&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;&#9;areaSoak.BackgroundTransparency = 1
&#9;&#9;areaSoak.BorderSizePixel = 0
&#9;&#9;areaSoak.Text = &quot;&quot;
&#9;&#9;areaSoak.ZIndex = 10
&#9;&#9;areaSoak.Visible = false
&#9;&#9;areaSoak.Active = true

&#9;&#9;local draggingVertical = false
&#9;&#9;local startYPos = nil
&#9;&#9;verticalDragger.MouseEnter:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(60/255,60/255,60/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseLeave:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseButton1Down:connect(function(x,y)
&#9;&#9;&#9;draggingVertical = true
&#9;&#9;&#9;areaSoak.Visible = true
&#9;&#9;&#9;startYPos = y
&#9;&#9;end)
&#9;&#9;areaSoak.MouseButton1Up:connect(function (  )
&#9;&#9;&#9;draggingVertical = false
&#9;&#9;&#9;areaSoak.Visible = false
&#9;&#9;end)
&#9;&#9;areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;if not draggingVertical then return end

&#9;&#9;&#9;local yDelta = y - startYPos
&#9;&#9;&#9;if not control.ScrollDownButton.Visible and yDelta &gt; 0 then
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;if (widgetContainer.Size.Y.Offset + yDelta) &lt; 150 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,150)
&#9;&#9;&#9;&#9;control.Size = UDim2.new (0,21,0,150)
&#9;&#9;&#9;&#9;return 
&#9;&#9;&#9;end 

&#9;&#9;&#9;startYPos = y

&#9;&#9;&#9;if widgetContainer.Size.Y.Offset + yDelta &gt;= 0 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,widgetContainer.Size.Y.Offset + yDelta)
&#9;&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,control.Size.Y.Offset + yDelta )
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end

&#9;local function switchMinimize()
&#9;&#9;minimizeFrame.Visible = not minimizeFrame.Visible
&#9;&#9;if scrollable then
&#9;&#9;&#9;frame.Visible = not frame.Visible
&#9;&#9;&#9;verticalDragger.Visible = not verticalDragger.Visible
&#9;&#9;&#9;control.Visible = not control.Visible
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Visible = not widgetContainer.Visible
&#9;&#9;end

&#9;&#9;if minimizeFrame.Visible then
&#9;&#9;&#9;minimizeButton.Text = &quot;+&quot;
&#9;&#9;else
&#9;&#9;&#9;minimizeButton.Text = &quot;-&quot;
&#9;&#9;end
&#9;end

&#9;minimizeBigButton.MouseButton1Click:connect(function (  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;minimizeButton.MouseButton1Click:connect(function(  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;if scrollable then
&#9;&#9;return dragBar, frame, helpFrame, closeEvent
&#9;else
&#9;&#9;return dragBar, widgetContainer, helpFrame, closeEvent
&#9;end
end

t.Help = 
&#9;function(funcNameOrFunc) 
&#9;&#9;--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
&#9;&#9;if funcNameOrFunc == &quot;CreatePropertyDropDownMenu&quot; or funcNameOrFunc == t.CreatePropertyDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreatePropertyDropDownMenu.  &quot; ..
&#9;&#9;&#9;&#9;   &quot;Arguments: (instance, propertyName, enumType).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: returns a container with a drop-down-box that is linked to the &apos;property&apos; field of &apos;instance&apos; which is of type &apos;enumType&apos;&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateDropDownMenu&quot; or funcNameOrFunc == t.CreateDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreateDropDownMenu.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (items, onItemSelected).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: Returns 2 results, a container to the gui object and a &apos;updateSelection&apos; function for external updating.  The container is a drop-down-box created around a list of items&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateMessageDialog&quot; or funcNameOrFunc == t.CreateMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button&quot;
&#9;&#9;end&#9;&#9;
&#9;&#9;if funcNameOrFunc == &quot;CreateStyledMessageDialog&quot; or funcNameOrFunc == t.CreateStyledMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateStyledMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, style, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button, &apos;style&apos; is a string, either Error, Notify or Confirm&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;GetFontHeight&quot; or funcNameOrFunc == t.GetFontHeight then
&#9;&#9;&#9;return &quot;Function GetFontHeight.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (font, fontSize). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: returns the size in pixels of the given font + fontSize&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;LayoutGuiObjects&quot; or funcNameOrFunc == t.LayoutGuiObjects then
&#9;&#9;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateScrollingFrame&quot; or funcNameOrFunc == t.CreateScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (orderList, style) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 4 objects, (scrollFrame, scrollUpButton, scrollDownButton, recalculateFunction).  &apos;scrollFrame&apos; can be filled with GuiObjects.  It will lay them out and allow scrollUpButton/scrollDownButton to interact with them.  Orderlist is optional (and specifies the order to layout the children.  Without orderlist, it uses the children order. style is also optional, and allows for a &apos;grid&apos; styling if style is passed &apos;grid&apos; as a string.  recalculateFunction can be called when a relayout is needed (when orderList changes)&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTrueScrollingFrame&quot; or funcNameOrFunc == t.CreateTrueScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateTrueScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (nil) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (scrollFrame, controlFrame).  &apos;scrollFrame&apos; can be filled with GuiObjects, and they will be clipped if not inside the frame&apos;s bounds. controlFrame has children scrollup and scrolldown, as well as a slider.  controlFrame can be parented to any guiobject and it will readjust itself to fit.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;AutoTruncateTextObject&quot; or funcNameOrFunc == t.AutoTruncateTextObject then
&#9;&#9;&#9;return &quot;Function AutoTruncateTextObject.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (textLabel) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (textLabel, changeText).  The &apos;textLabel&apos; input is modified to automatically truncate text (with ellipsis), if it gets too small to fit.  &apos;changeText&apos; is a function that can be used to change the text, it takes 1 string as an argument&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSlider&quot; or funcNameOrFunc == t.CreateSlider then
&#9;&#9;&#9;return &quot;Function CreateSlider.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateLoadingFrame&quot; or funcNameOrFunc == t.CreateLoadingFrame then
&#9;&#9;&#9;return &quot;Function CreateLoadingFrame.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (name, size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Creates a gui that can be manipulated to show progress for a particular action.  Name appears above the loading bar, and size and position are udim2 values (both size and position are optional arguments).  Returns 3 arguments, the first being the gui created. The second being updateLoadingGuiPercent, which is a bindable function.  This function takes one argument (two optionally), which should be a number between 0 and 1, representing the percentage the loading gui should be at.  The second argument to this function is a boolean value that if set to true will tween the current percentage value to the new percentage value, therefore our third argument is how long this tween should take. Our third returned argument is a BindableEvent, that when fired means that someone clicked the cancel button on the dialog.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTerrainMaterialSelector&quot; or funcNameOrFunc == t.CreateTerrainMaterialSelector then
&#9;&#9;&#9;return &quot;Function CreateTerrainMaterialSelector.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Size and position are UDim2 values that specifies the selector&apos;s size and position.  Both size and position are optional arguments. This method returns 3 objects (terrainSelectorGui, terrainSelected, forceTerrainSelection).  terrainSelectorGui is just the gui object that we generate with this function, parent it as you like. TerrainSelected is a BindableEvent that is fired whenever a new terrain type is selected in the gui.  ForceTerrainSelection is a function that takes an argument of Enum.CellMaterial and will force the gui to show that material as currently selected.&quot;
&#9;&#9;end
&#9;end

--RBXGUI END
&#9;
-- This script creates almost all gui elements found in the backpack (warning: there are a lot!)
-- TODO: automate this process

local gui = script.Parent

-- A couple of necessary functions
local function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end
local function waitForProperty(instance, property)
&#9;while not instance[property] do
&#9;&#9;instance.Changed:wait()
&#9;end
end

waitForChild(game,&quot;Players&quot;)
waitForProperty(game.Players,&quot;LocalPlayer&quot;)
local player = game.Players.LocalPlayer

-- First up is the current loadout
local CurrentLoadout = Instance.new(&quot;Frame&quot;)
CurrentLoadout.Name = &quot;CurrentLoadout&quot;
CurrentLoadout.Position = UDim2.new(0.5, -170, 1, -85)
CurrentLoadout.Size = UDim2.new(0, 480, 0, 48)
CurrentLoadout.BackgroundTransparency = 1

CurrentLoadout.Parent = gui

local Debounce = Instance.new(&quot;BoolValue&quot;)
Debounce.Name = &quot;Debounce&quot;

Debounce.Parent = CurrentLoadout

for i = 0, 9 do
&#9;local slotFrame = Instance.new(&quot;Frame&quot;)

&#9;slotFrame.BackgroundColor3 = Color3.new(0,0,0)
&#9;slotFrame.BackgroundTransparency = 1
&#9;slotFrame.BorderColor3 = Color3.new(1,1,1)
&#9;slotFrame.Name = &quot;Slot&quot; .. tostring(i)
&#9;if i == 0 then
&#9;&#9;slotFrame.Position = UDim2.new(0.9,0,0,0)
&#9;else
&#9;&#9;slotFrame.Position = UDim2.new((i - 1) * 0.1,0,0,0)
&#9;end
&#9;slotFrame.Size = UDim2.new(0.1,0,1,0)
&#9;slotFrame.Parent = CurrentLoadout
end

local TempSlot = Instance.new(&quot;ImageButton&quot;)
TempSlot.Name = &quot;TempSlot&quot;
TempSlot.Active = true
TempSlot.Size = UDim2.new(1,0,1,0)
TempSlot.Style = Enum.ButtonStyle.RobloxButton
TempSlot.Visible = false

TempSlot.Parent = CurrentLoadout

&#9;-- TempSlot Children
&#9;local GearReference = Instance.new(&quot;ObjectValue&quot;)
&#9;GearReference.Name = &quot;GearReference&quot;

&#9;GearReference.Parent = TempSlot
&#9;
&#9;local ToolTipLabel = Instance.new(&quot;TextLabel&quot;)
&#9;ToolTipLabel.Name = &quot;ToolTipLabel&quot;
&#9;
&#9;ToolTipLabel.Text = &quot;&quot;
&#9;ToolTipLabel.BackgroundTransparency = 0.5
&#9;ToolTipLabel.BorderSizePixel = 0
&#9;ToolTipLabel.Visible = false
&#9;ToolTipLabel.TextColor3 = Color3.new(1,1,1)
&#9;ToolTipLabel.BackgroundColor3 = Color3.new(0,0,0)
&#9;ToolTipLabel.TextStrokeTransparency = 0
&#9;ToolTipLabel.Font = Enum.Font.ArialBold
&#9;ToolTipLabel.FontSize = Enum.FontSize.Size14
&#9;--ToolTipLabel.TextWrap = true
&#9;ToolTipLabel.Size = UDim2.new(1,60,0,20)
&#9;ToolTipLabel.Position = UDim2.new(0,-30,0,-30)
&#9;ToolTipLabel.Parent = TempSlot

&#9;local Kill = Instance.new(&quot;BoolValue&quot;)
&#9;Kill.Name = &quot;Kill&quot;

&#9;Kill.Parent = TempSlot

&#9;local GearImage = Instance.new(&quot;ImageLabel&quot;)
&#9;GearImage.Name = &quot;GearImage&quot;
&#9;GearImage.BackgroundTransparency = 1
&#9;GearImage.Position = UDim2.new(0,-7,0,-7)
&#9;GearImage.Size = UDim2.new(1,14,1,14)
&#9;GearImage.ZIndex = 2

&#9;GearImage.Parent = TempSlot

&#9;local SlotNumber = Instance.new(&quot;TextLabel&quot;)
&#9;SlotNumber.Name = &quot;SlotNumber&quot;
&#9;SlotNumber.BackgroundTransparency = 1
&#9;SlotNumber.BorderSizePixel = 0
&#9;SlotNumber.Font = Enum.Font.ArialBold
&#9;SlotNumber.FontSize = Enum.FontSize.Size18
&#9;SlotNumber.Position = UDim2.new(0,-7,0,-7)
&#9;SlotNumber.Size = UDim2.new(0,10,0,15)
&#9;SlotNumber.TextColor3 = Color3.new(1,1,1)
&#9;SlotNumber.TextTransparency = 0
&#9;SlotNumber.TextXAlignment = Enum.TextXAlignment.Left
&#9;SlotNumber.TextYAlignment = Enum.TextYAlignment.Bottom
&#9;SlotNumber.ZIndex = 4
&#9;
&#9;SlotNumber.Parent = TempSlot
&#9;
&#9;local SlotNumberDownShadow = SlotNumber:clone()
&#9;SlotNumberDownShadow.Name = &quot;SlotNumberDownShadow&quot;
&#9;SlotNumberDownShadow.TextColor3 = Color3.new(0,0,0)
&#9;SlotNumberDownShadow.ZIndex = 3
&#9;SlotNumberDownShadow.Position = UDim2.new(0,-6,0,-6)
&#9;SlotNumberDownShadow.Parent = TempSlot
&#9;
&#9;local SlotNumberUpShadow = SlotNumberDownShadow:clone()
&#9;SlotNumberUpShadow.Name = &quot;SlotNumberUpShadow&quot;
&#9;SlotNumberUpShadow.Position = UDim2.new(0,-8,0,-8)
&#9;SlotNumberUpShadow.Parent = TempSlot

&#9;local GearText = Instance.new(&quot;TextLabel&quot;)
&#9;
&#9;GearText.Name = &quot;GearText&quot;
&#9;GearText.BackgroundTransparency = 1
&#9;GearText.Font = Enum.Font.Arial
&#9;GearText.FontSize = Enum.FontSize.Size14
&#9;GearText.Position = UDim2.new(0,-8,0,-8)
&#9;GearText.ZIndex = 2
&#9;GearText.Size = UDim2.new(1,16,1,16)
&#9;GearText.Text = &quot;&quot;
&#9;GearText.TextColor3 = Color3.new(1,1,1)
&#9;GearText.TextWrap = true
&#9;GearText.Parent = TempSlot

--- Great, now lets make the inventory!

local Backpack = Instance.new(&quot;Frame&quot;)

Backpack.Visible = false
Backpack.Name = &quot;Backpack&quot;
Backpack.Position = UDim2.new(0.5,0,0.5,0)
Backpack.BackgroundColor3 = Color3.new(0,0,0)
Backpack.BackgroundTransparency = 0.08
Backpack.BorderSizePixel = 0
Backpack.Parent = gui
Backpack.Active = true

&#9;-- Backpack Children
&#9;local SwapSlot = Instance.new(&quot;BoolValue&quot;)
&#9;
&#9;SwapSlot.Name = &quot;SwapSlot&quot;
&#9;SwapSlot.Parent = Backpack
&#9;&#9;
&#9;&#9;-- SwapSlot Children
&#9;&#9;local Slot = Instance.new(&quot;IntValue&quot;)
&#9;
&#9;&#9;Slot.Name = &quot;Slot&quot;
&#9;&#9;Slot.Parent = SwapSlot
&#9;&#9;
&#9;&#9;local GearButton = Instance.new(&quot;ObjectValue&quot;)
&#9;&#9;
&#9;&#9;GearButton.Name = &quot;GearButton&quot;
&#9;&#9;GearButton.Parent = SwapSlot
&#9;
&#9;local Tabs = Instance.new(&quot;Frame&quot;)
&#9;Tabs.Name = &quot;Tabs&quot;
&#9;Tabs.Visible = true
&#9;
&#9;Tabs.BackgroundColor3 = Color3.new(0,0,0)
&#9;Tabs.BackgroundTransparency = 0.08
&#9;Tabs.BorderSizePixel = 0
&#9;Tabs.Position = UDim2.new(0,0,-0.1,-4)
&#9;Tabs.Size = UDim2.new(1,0,0.1,4)
&#9;Tabs.Parent = Backpack
&#9;
&#9;&#9;-- Tabs Children
&#9;&#9;
&#9;&#9;local tabLine = Instance.new(&quot;Frame&quot;)
&#9;&#9;
&#9;&#9;tabLine.Name = &quot;TabLine&quot;
&#9;&#9;tabLine.BackgroundColor3 = Color3.new(53/255, 53/255, 53/255)
&#9;&#9;tabLine.BorderSizePixel = 0
&#9;&#9;tabLine.Position = UDim2.new(0,5,1,-4)
&#9;&#9;tabLine.Size = UDim2.new(1,-10,0,4)
&#9;&#9;tabLine.ZIndex = 2
&#9;&#9;tabLine.Parent = Tabs
&#9;&#9;
&#9;&#9;local InventoryButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;
&#9;&#9;InventoryButton.Name = &quot;InventoryButton&quot;
&#9;&#9;InventoryButton.Size = UDim2.new(0,60,0,30)
&#9;&#9;InventoryButton.Position = UDim2.new(0,7,1,-31)
&#9;&#9;InventoryButton.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;InventoryButton.BorderColor3 = Color3.new(1,1,1)
&#9;&#9;InventoryButton.Font = Enum.Font.ArialBold
&#9;&#9;InventoryButton.FontSize = Enum.FontSize.Size18
&#9;&#9;InventoryButton.Text = &quot;Gear&quot;
&#9;&#9;InventoryButton.AutoButtonColor = false
&#9;&#9;InventoryButton.TextColor3 = Color3.new(0,0,0)
&#9;&#9;InventoryButton.Selected = true
&#9;&#9;InventoryButton.Active = true
&#9;&#9;InventoryButton.ZIndex = 3
&#9;&#9;InventoryButton.Parent = Tabs
&#9;&#9;&#9;
&#9;&#9;local closeButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;
&#9;&#9;closeButton.Name = &quot;CloseButton&quot;
&#9;&#9;closeButton.Font = Enum.Font.ArialBold
&#9;&#9;closeButton.FontSize = Enum.FontSize.Size24
&#9;&#9;closeButton.Position = UDim2.new(1,-33,0,4)
&#9;&#9;closeButton.Size = UDim2.new(0,30,0,30)
&#9;&#9;closeButton.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;closeButton.Text = &quot;&quot;
&#9;&#9;closeButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;closeButton.Parent = Tabs
&#9;&#9;closeButton.Modal = true
&#9;&#9;
&#9;&#9;&#9;--closeButton child
&#9;&#9;&#9;local XImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;XImage.Name = &quot;XImage&quot;
&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=75547445&quot;)
&#9;&#9;&#9;XImage.Image = &quot;http://www.roblox.com/asset/?id=75547445&quot;  --TODO: move to rbxasset
&#9;&#9;&#9;XImage.BackgroundTransparency = 1
&#9;&#9;&#9;XImage.Position = UDim2.new(-.25,-1,-.25,-1)
&#9;&#9;&#9;XImage.Size = UDim2.new(1.5,2,1.5,2)
&#9;&#9;&#9;XImage.ZIndex = 2
&#9;&#9;&#9;XImage.Parent = closeButton
&#9;&#9;&#9;
&#9;&#9;-- Generic Search gui used across backpack&#9;
&#9;&#9;local SearchFrame = Instance.new(&quot;Frame&quot;)
&#9;
&#9;&#9;SearchFrame.Name = &quot;SearchFrame&quot;
&#9;&#9;SearchFrame.BackgroundTransparency = 1
&#9;&#9;SearchFrame.Position = UDim2.new(1,-220,0,2)
&#9;&#9;SearchFrame.Size = UDim2.new(0,220,0,24)
&#9;&#9;SearchFrame.Parent = Backpack
&#9;&#9;
&#9;&#9;&#9;-- SearchFrame Children
&#9;&#9;&#9;local SearchButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;
&#9;&#9;&#9;SearchButton.Name = &quot;SearchButton&quot;
&#9;&#9;&#9;SearchButton.Size = UDim2.new(0,25,0,25)
&#9;&#9;&#9;SearchButton.BackgroundTransparency = 1
&#9;&#9;&#9;SearchButton.Image = &quot;rbxasset://textures/ui/SearchIcon.png&quot;
&#9;&#9;&#9;SearchButton.Parent = SearchFrame
&#9;&#9;&#9;
&#9;&#9;&#9;local SearchBoxFrame = Instance.new(&quot;TextButton&quot;)
&#9;&#9;
&#9;&#9;&#9;SearchBoxFrame.Position = UDim2.new(0,25,0,0)
&#9;&#9;&#9;SearchBoxFrame.Size = UDim2.new(1,-28,0,26)
&#9;&#9;&#9;SearchBoxFrame.Name = &quot;SearchBoxFrame&quot;
&#9;&#9;&#9;SearchBoxFrame.Text = &quot;&quot;
&#9;&#9;&#9;SearchBoxFrame.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;&#9;SearchBoxFrame.Parent = SearchFrame
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- SearchBoxFrame Children
&#9;&#9;&#9;&#9;local SearchBox = Instance.new(&quot;TextBox&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;SearchBox.Name = &quot;SearchBox&quot;
&#9;&#9;&#9;&#9;SearchBox.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;SearchBox.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;SearchBox.FontSize = Enum.FontSize.Size12
&#9;&#9;&#9;&#9;SearchBox.Position = UDim2.new(0,-5,0,-5)
&#9;&#9;&#9;&#9;SearchBox.Size = UDim2.new(1,10,1,10)
&#9;&#9;&#9;&#9;SearchBox.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;SearchBox.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;SearchBox.ZIndex = 2
&#9;&#9;&#9;&#9;SearchBox.TextWrap = true
&#9;&#9;&#9;&#9;SearchBox.Text = &quot;Search...&quot;
&#9;&#9;&#9;&#9;SearchBox.Parent = SearchBoxFrame
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;
&#9;&#9;&#9;local ResetButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;ResetButton.Visible = false
&#9;&#9;&#9;ResetButton.Name = &quot;ResetButton&quot;
&#9;&#9;&#9;ResetButton.Position = UDim2.new(1,-26,0,3)
&#9;&#9;&#9;ResetButton.Size = UDim2.new(0,20,0,20)
&#9;&#9;&#9;ResetButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;&#9;ResetButton.Text = &quot;X&quot;
&#9;&#9;&#9;ResetButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;ResetButton.Font = Enum.Font.ArialBold
&#9;&#9;&#9;ResetButton.FontSize = Enum.FontSize.Size18
&#9;&#9;&#9;ResetButton.ZIndex = 3
&#9;&#9;&#9;ResetButton.Parent = SearchFrame
&#9;&#9;
------------------------------- GEAR -------------------------------------------------------
&#9;local Gear = Instance.new(&quot;Frame&quot;)
&#9;Gear.Name = &quot;Gear&quot;

&#9;Gear.BackgroundTransparency = 1
&#9;Gear.Size  = UDim2.new(1,0,1,0)
&#9;Gear.Parent = Backpack

&#9;&#9;-- Gear Children
&#9;&#9;local AssetsList = Instance.new(&quot;Frame&quot;)
&#9;&#9;
&#9;&#9;AssetsList.Name = &quot;AssetsList&quot;
&#9;&#9;AssetsList.BackgroundTransparency = 1
&#9;&#9;AssetsList.Size = UDim2.new(0.2,0,1,0)
&#9;&#9;AssetsList.Style = Enum.FrameStyle.RobloxSquare
&#9;&#9;AssetsList.Visible = false
&#9;&#9;AssetsList.Parent = Gear
&#9;&#9;&#9;
&#9;&#9;local GearGrid = Instance.new(&quot;Frame&quot;)

&#9;&#9;GearGrid.Name = &quot;GearGrid&quot;
&#9;&#9;GearGrid.Size = UDim2.new(0.69,0,1,0)
&#9;&#9;GearGrid.BackgroundTransparency = 1
&#9;&#9;GearGrid.Parent = Gear
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;
&#9;&#9;&#9;local GearButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;
&#9;&#9;&#9;GearButton.Visible = false
&#9;&#9;&#9;GearButton.Name = &quot;GearButton&quot;
&#9;&#9;&#9;GearButton.Size = UDim2.new(0,64,0,64)
&#9;&#9;&#9;GearButton.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;&#9;GearButton.Parent = GearGrid

&#9;&#9;&#9;&#9;-- GearButton Children
&#9;&#9;&#9;&#9;local GearReference = Instance.new(&quot;ObjectValue&quot;)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;GearReference.Name = &quot;GearReference&quot;
&#9;&#9;&#9;&#9;GearReference.Parent = GearButton
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local GreyOutButton = Instance.new(&quot;Frame&quot;)
&#9;&#9;
&#9;&#9;&#9;&#9;GreyOutButton.Name = &quot;GreyOutButton&quot;
&#9;&#9;&#9;&#9;GreyOutButton.BackgroundTransparency = 0.5
&#9;&#9;&#9;&#9;GreyOutButton.Size = UDim2.new(1,0,1,0)
&#9;&#9;&#9;&#9;GreyOutButton.Active = true
&#9;&#9;&#9;&#9;GreyOutButton.Visible = false
&#9;&#9;&#9;&#9;GreyOutButton.ZIndex = 3
&#9;&#9;&#9;&#9;GreyOutButton.Parent = GearButton
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local GearText = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;GearText.Name = &quot;GearText&quot;
&#9;&#9;&#9;&#9;GearText.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;GearText.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;GearText.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;&#9;GearText.Position = UDim2.new(0,-8,0,-8)
&#9;&#9;&#9;&#9;GearText.Size = UDim2.new(1,16,1,16)
&#9;&#9;&#9;&#9;GearText.Text = &quot;&quot;
&#9;&#9;&#9;&#9;GearText.ZIndex = 2
&#9;&#9;&#9;&#9;GearText.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;GearText.TextWrap = true
&#9;&#9;&#9;&#9;GearText.Parent = GearButton

&#9;&#9;local GearGridScrollingArea = Instance.new(&quot;Frame&quot;)

&#9;&#9;GearGridScrollingArea.Name = &quot;GearGridScrollingArea&quot;
&#9;&#9;GearGridScrollingArea.Position = UDim2.new(0.7,0,0,35)
&#9;&#9;GearGridScrollingArea.Size = UDim2.new(0,17,1,-45)
&#9;&#9;GearGridScrollingArea.BackgroundTransparency = 1
&#9;&#9;GearGridScrollingArea.Parent = Gear

&#9;&#9;local GearLoadouts = Instance.new(&quot;Frame&quot;)
&#9;&#9;
&#9;&#9;GearLoadouts.Name = &quot;GearLoadouts&quot;
&#9;&#9;GearLoadouts.BackgroundTransparency = 1
&#9;&#9;GearLoadouts.Position = UDim2.new(0.7,23,0.5,1)
&#9;&#9;GearLoadouts.Size = UDim2.new(0.3,-23,0.5,-1)
&#9;&#9;GearLoadouts.Parent = Gear
&#9;&#9;GearLoadouts.Visible = false
&#9;&#9;
&#9;&#9;&#9;-- GearLoadouts Children
&#9;&#9;&#9;local GearLoadoutsHeader = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;GearLoadoutsHeader.Name = &quot;GearLoadoutsHeader&quot;
&#9;&#9;&#9;GearLoadoutsHeader.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;GearLoadoutsHeader.BackgroundTransparency = 0.2
&#9;&#9;&#9;GearLoadoutsHeader.BorderColor3 = Color3.new(1,0,0)
&#9;&#9;&#9;GearLoadoutsHeader.Size = UDim2.new(1,2,0.15,-1)
&#9;&#9;&#9;GearLoadoutsHeader.Parent = GearLoadouts

&#9;&#9;&#9;&#9;-- GearLoadoutsHeader Children
&#9;&#9;&#9;&#9;local LoadoutsHeaderText = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;LoadoutsHeaderText.Name = &quot;LoadoutsHeaderText&quot;
&#9;&#9;&#9;&#9;LoadoutsHeaderText.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;LoadoutsHeaderText.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;LoadoutsHeaderText.FontSize = Enum.FontSize.Size18
&#9;&#9;&#9;&#9;LoadoutsHeaderText.Size = UDim2.new(1,0,1,0)
&#9;&#9;&#9;&#9;LoadoutsHeaderText.Text = &quot;Loadouts&quot;
&#9;&#9;&#9;&#9;LoadoutsHeaderText.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;LoadoutsHeaderText.Parent = GearLoadoutsHeader
&#9;
&#9;&#9;&#9;&#9;local GearLoadoutsScrollingArea = GearGridScrollingArea:clone()
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;GearLoadoutsScrollingArea.Name = &quot;GearLoadoutsScrollingArea&quot;
&#9;&#9;&#9;&#9;GearLoadoutsScrollingArea.Position = UDim2.new(1,-15,0.15,2)
&#9;&#9;&#9;&#9;GearLoadoutsScrollingArea.Size = UDim2.new(0,17,0.85,-2)
&#9;&#9;&#9;&#9;GearLoadoutsScrollingArea.Parent = GearLoadouts

&#9;&#9;&#9;&#9;local LoadoutsList = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;LoadoutsList.Name = &quot;LoadoutsList&quot;
&#9;&#9;&#9;&#9;LoadoutsList.Position = UDim2.new(0,0,0.15,2)
&#9;&#9;&#9;&#9;LoadoutsList.Size = UDim2.new(1,-17,0.85,-2)
&#9;&#9;&#9;&#9;LoadoutsList.Style = Enum.FrameStyle.RobloxSquare
&#9;&#9;&#9;&#9;LoadoutsList.Parent = GearLoadouts
&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;local GearPreview = Instance.new(&quot;Frame&quot;)
&#9;&#9;
&#9;&#9;GearPreview.Name = &quot;GearPreview&quot;
&#9;&#9;GearPreview.Position = UDim2.new(0.7,23,0,0)
&#9;&#9;GearPreview.Size = UDim2.new(0.3,-28,0.5,-1)
&#9;&#9;GearPreview.BackgroundTransparency = 1
&#9;&#9;GearPreview.ZIndex = 7
&#9;&#9;GearPreview.Parent = Gear
&#9;&#9;
&#9;&#9;&#9;-- GearPreview Children
&#9;&#9;&#9;local GearStats = Instance.new(&quot;Frame&quot;)
&#9;&#9;
&#9;&#9;&#9;GearStats.Name = &quot;GearStats&quot;
&#9;&#9;&#9;GearStats.BackgroundTransparency = 1
&#9;&#9;&#9;GearStats.Position = UDim2.new(0,0,0.75,0)
&#9;&#9;&#9;GearStats.Size = UDim2.new(1,0,0.25,0)
&#9;&#9;&#9;GearStats.ZIndex = 8
&#9;&#9;&#9;GearStats.Parent = GearPreview
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- GearStats Children
&#9;&#9;&#9;&#9;local GearName = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;GearName.Name = &quot;GearName&quot;
&#9;&#9;&#9;&#9;GearName.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;GearName.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;GearName.FontSize = Enum.FontSize.Size18
&#9;&#9;&#9;&#9;GearName.Position = UDim2.new(0,-3,0,0)
&#9;&#9;&#9;&#9;GearName.Size = UDim2.new(1,6,1,5)
&#9;&#9;&#9;&#9;GearName.Text = &quot;&quot;
&#9;&#9;&#9;&#9;GearName.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;GearName.TextWrap = true
&#9;&#9;&#9;&#9;GearName.ZIndex = 9
&#9;&#9;&#9;&#9;GearName.Parent = GearStats
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;local GearImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;GearImage.Name = &quot;GearImage&quot;
&#9;&#9;&#9;GearImage.Image = &quot;&quot;
&#9;&#9;&#9;GearImage.BackgroundTransparency = 1
&#9;&#9;&#9;GearImage.Position = UDim2.new(0.125,0,0,0)
&#9;&#9;&#9;GearImage.Size = UDim2.new(0.75,0,0.75,0)
&#9;&#9;&#9;GearImage.ZIndex = 8
&#9;&#9;&#9;GearImage.Parent = GearPreview
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;--GearImage Children
&#9;&#9;&#9;&#9;local GearIcons = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;GearIcons.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;GearIcons.BackgroundTransparency = 0.5
&#9;&#9;&#9;&#9;GearIcons.BorderSizePixel = 0
&#9;&#9;
&#9;&#9;&#9;&#9;GearIcons.Name = &quot;GearIcons&quot;
&#9;&#9;&#9;&#9;GearIcons.Position = UDim2.new(0.4,2,0.85,-2)
&#9;&#9;&#9;&#9;GearIcons.Size = UDim2.new(0.6,0,0.15,0)
&#9;&#9;&#9;&#9;GearIcons.Visible = false
&#9;&#9;&#9;&#9;GearIcons.ZIndex = 9
&#9;&#9;&#9;&#9;GearIcons.Parent = GearImage
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- GearIcons Children
&#9;&#9;&#9;&#9;&#9;local GenreImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;
&#9;&#9;&#9;&#9;&#9;GenreImage.Name = &quot;GenreImage&quot;
&#9;&#9;&#9;&#9;&#9;GenreImage.BackgroundColor3 = Color3.new(102/255,153/255,1)
&#9;&#9;&#9;&#9;&#9;GenreImage.BackgroundTransparency = 0.5
&#9;&#9;&#9;&#9;&#9;GenreImage.BorderSizePixel = 0
&#9;&#9;&#9;&#9;&#9;GenreImage.Size = UDim2.new(0.25,0,1,0)
&#9;&#9;&#9;&#9;&#9;GenreImage.Parent = GearIcons
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;local AttributeOneImage = GenreImage:clone()
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;AttributeOneImage.Name = &quot;AttributeOneImage&quot;
&#9;&#9;&#9;&#9;&#9;AttributeOneImage.BackgroundColor3 = Color3.new(1,51/255,0)
&#9;&#9;&#9;&#9;&#9;AttributeOneImage.Position = UDim2.new(0.25,0,0,0)
&#9;&#9;&#9;&#9;&#9;AttributeOneImage.Parent = GearIcons
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;local AttributeTwoImage = GenreImage:clone()
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;AttributeTwoImage.Name = &quot;AttributeTwoImage&quot;
&#9;&#9;&#9;&#9;&#9;AttributeTwoImage.BackgroundColor3 = Color3.new(153/255,1,153/255)
&#9;&#9;&#9;&#9;&#9;AttributeTwoImage.Position = UDim2.new(0.5,0,0,0)
&#9;&#9;&#9;&#9;&#9;AttributeTwoImage.Parent = GearIcons
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;local AttributeThreeImage = GenreImage:clone()
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;AttributeThreeImage.Name = &quot;AttributeThreeImage&quot;
&#9;&#9;&#9;&#9;&#9;AttributeThreeImage.BackgroundColor3 = Color3.new(0,0.5,0.5)
&#9;&#9;&#9;&#9;&#9;AttributeThreeImage.Position = UDim2.new(0.75,0,0,0)
&#9;&#9;&#9;&#9;&#9;AttributeThreeImage.Parent = GearIcons
&#9;&#9;&#9;&#9;&#9;
------------------------------- WARDROBE -------------------------------------------------------


&#9;
local t = {}

local function ScopedConnect(parentInstance, instance, event, signalFunc, syncFunc, removeFunc)
&#9;local eventConnection = nil

&#9;--Connection on parentInstance is scoped by parentInstance (when destroyed, it goes away)
&#9;local tryConnect = function()
&#9;&#9;if game:IsAncestorOf(parentInstance) then
&#9;&#9;&#9;--Entering the world, make sure we are connected/synced
&#9;&#9;&#9;if not eventConnection then
&#9;&#9;&#9;&#9;eventConnection = instance[event]:connect(signalFunc)
&#9;&#9;&#9;&#9;if syncFunc then syncFunc() end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;--Probably leaving the world, so disconnect for now
&#9;&#9;&#9;if eventConnection then
&#9;&#9;&#9;&#9;eventConnection:disconnect()
&#9;&#9;&#9;&#9;if removeFunc then removeFunc() end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;--Hook it up to ancestryChanged signal
&#9;local connection = parentInstance.AncestryChanged:connect(tryConnect)
&#9;
&#9;--Now connect us if we&apos;re already in the world
&#9;tryConnect()
&#9;
&#9;return connection
end

local function getScreenGuiAncestor(instance)
&#9;local localInstance = instance
&#9;while localInstance and not localInstance:IsA(&quot;ScreenGui&quot;) do
&#9;&#9;localInstance = localInstance.Parent
&#9;end
&#9;return localInstance
end

local function CreateButtons(frame, buttons, yPos, ySize)
&#9;local buttonNum = 1
&#9;local buttonObjs = {}
&#9;for i, obj in ipairs(buttons) do 
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot; .. buttonNum
&#9;&#9;button.Font = Enum.Font.Arial
&#9;&#9;button.FontSize = Enum.FontSize.Size18
&#9;&#9;button.AutoButtonColor = true
&#9;&#9;button.Modal = true
&#9;&#9;if obj[&quot;Style&quot;] then
&#9;&#9;&#9;button.Style = obj.Style
&#9;&#9;else
&#9;&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;end
&#9;&#9;if obj[&quot;ZIndex&quot;] then
&#9;&#9;&#9;button.ZIndex = obj.ZIndex
&#9;&#9;end
&#9;&#9;button.Text = obj.Text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.MouseButton1Click:connect(obj.Function)
&#9;&#9;button.Parent = frame
&#9;&#9;buttonObjs[buttonNum] = button

&#9;&#9;buttonNum = buttonNum + 1
&#9;end
&#9;local numButtons = buttonNum-1

&#9;if numButtons == 1 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.35, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.4,0,ySize.Scale, ySize.Offset)
&#9;elseif numButtons == 2 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.1, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.8/3,0, ySize.Scale, ySize.Offset)

&#9;&#9;frame.Button2.Position = UDim2.new(0.55, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button2.Size = UDim2.new(.35,0, ySize.Scale, ySize.Offset)
&#9;elseif numButtons &gt;= 3 then
&#9;&#9;local spacing = .1 / numButtons
&#9;&#9;local buttonSize = .9 / numButtons

&#9;&#9;buttonNum = 1
&#9;&#9;while buttonNum &lt;= numButtons do
&#9;&#9;&#9;buttonObjs[buttonNum].Position = UDim2.new(spacing*buttonNum + (buttonNum-1) * buttonSize, 0, yPos.Scale, yPos.Offset)
&#9;&#9;&#9;buttonObjs[buttonNum].Size = UDim2.new(buttonSize, 0, ySize.Scale, ySize.Offset)
&#9;&#9;&#9;buttonNum = buttonNum + 1
&#9;&#9;end
&#9;end
end

local function setSliderPos(newAbsPosX,slider,sliderPosition,bar,steps)

&#9;local newStep = steps - 1 --otherwise we really get one more step than we want
&#9;local relativePosX = math.min(1, math.max(0, (newAbsPosX - bar.AbsolutePosition.X) / bar.AbsoluteSize.X ))
&#9;local wholeNum, remainder = math.modf(relativePosX * newStep)
&#9;if remainder &gt; 0.5 then
&#9;&#9;wholeNum = wholeNum + 1
&#9;end
&#9;relativePosX = wholeNum/newStep

&#9;local result = math.ceil(relativePosX * newStep)
&#9;if sliderPosition.Value ~= (result + 1) then --only update if we moved a step
&#9;&#9;sliderPosition.Value = result + 1
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end
&#9;
end

local function cancelSlide(areaSoak)
&#9;areaSoak.Visible = false
&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
end

t.CreateStyledMessageDialog = function(title, message, style, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0, 165)
&#9;frame.Position = UDim2.new(0.25, 0, 0.5, -72.5)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound&#9;
&#9;
&#9;local styleImage = Instance.new(&quot;ImageLabel&quot;)
&#9;styleImage.Name = &quot;StyleImage&quot;
&#9;styleImage.BackgroundTransparency = 1
&#9;styleImage.Position = UDim2.new(0,5,0,15)
&#9;if style == &quot;error&quot; or style == &quot;Error&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42565285&quot;
&#9;elseif style == &quot;notify&quot; or style == &quot;Notify&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42604978&quot;
&#9;elseif style == &quot;confirm&quot; or style == &quot;Confirm&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 74, 0, 76)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42557901&quot;
&#9;else
&#9;&#9;return t.CreateMessageDialog(title,message,buttons)
&#9;end
&#9;styleImage.Parent = frame
&#9;
&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.TextStrokeTransparency = 0
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 80, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, -80, 0, 40)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextStrokeTransparency = 0
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 80, 0, 45)
&#9;messageLabel.Size = UDim2.new(0.95, -80, 0, 55)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0, 105), UDim.new(0, 40) )

&#9;return frame
end

t.CreateMessageDialog = function(title, message, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0.5, 0)
&#9;frame.Position = UDim2.new(0.25, 0, 0.25, 0)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound

&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 0, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, 0, 0.15, 0)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 0, 0.175, 0)
&#9;messageLabel.Size = UDim2.new(0.95, 0, .55, 0)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0.8,0), UDim.new(0.15, 0))

&#9;return frame
end

t.CreateDropDownMenu = function(items, onSelect, forRoblox, whiteSkin, baseZ)
&#9;local baseZIndex = 0
&#9;if (type(baseZ) == &quot;number&quot;) then
&#9;&#9;baseZIndex = baseZ
&#9;end
&#9;local width = UDim.new(0, 100)
&#9;local height = UDim.new(0, 32)

&#9;local xPos = 0.055
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;local textColor = Color3.new(1,1,1)
&#9;if (whiteSkin) then
&#9;&#9;textColor = Color3.new(0.5, 0.5, 0.5)
&#9;end
&#9;frame.Name = &quot;DropDownMenu&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(width, height)

&#9;local dropDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;dropDownMenu.Name = &quot;DropDownMenuButton&quot;
&#9;dropDownMenu.TextWrap = true
&#9;dropDownMenu.TextColor3 = textColor
&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;dropDownMenu.Font = Enum.Font.ArialBold
&#9;dropDownMenu.FontSize = Enum.FontSize.Size18
&#9;dropDownMenu.TextXAlignment = Enum.TextXAlignment.Left
&#9;dropDownMenu.TextYAlignment = Enum.TextYAlignment.Center
&#9;dropDownMenu.BackgroundTransparency = 1
&#9;dropDownMenu.AutoButtonColor = true
&#9;if (whiteSkin) then
&#9;&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
&#9;else
&#9;&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;end
&#9;dropDownMenu.Size = UDim2.new(1,0,1,0)
&#9;dropDownMenu.Parent = frame
&#9;dropDownMenu.ZIndex = 2 + baseZIndex

&#9;local dropDownIcon = Instance.new(&quot;ImageLabel&quot;)
&#9;dropDownIcon.Name = &quot;Icon&quot;
&#9;dropDownIcon.Active = false
&#9;if (whiteSkin) then
&#9;&#9;dropDownIcon.Image = &quot;rbxasset://textures/ui/dropdown_arrow.png&quot;
&#9;&#9;dropDownIcon.Size = UDim2.new(0,16,0,12)
&#9;&#9;dropDownIcon.Position = UDim2.new(1,-17,0.5, -6)
&#9;else
&#9;&#9;dropDownIcon.Image = &quot;http://www.roblox.com/asset/?id=45732894&quot;
&#9;&#9;dropDownIcon.Size = UDim2.new(0,11,0,6)
&#9;&#9;dropDownIcon.Position = UDim2.new(1,-11,0.5, -2)
&#9;end
&#9;dropDownIcon.BackgroundTransparency = 1
&#9;dropDownIcon.Parent = dropDownMenu
&#9;dropDownIcon.ZIndex = 2 + baseZIndex
&#9;
&#9;local itemCount = #items
&#9;local dropDownItemCount = #items
&#9;local useScrollButtons = false
&#9;if dropDownItemCount &gt; 6 then
&#9;&#9;useScrollButtons = true
&#9;&#9;dropDownItemCount = 6
&#9;end
&#9;
&#9;local droppedDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;droppedDownMenu.Name = &quot;List&quot;
&#9;droppedDownMenu.Text = &quot;&quot;
&#9;droppedDownMenu.BackgroundTransparency = 1
&#9;--droppedDownMenu.AutoButtonColor = true
&#9;if (whiteSkin) then
&#9;&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
&#9;else
&#9;&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;end
&#9;droppedDownMenu.Visible = false
&#9;droppedDownMenu.Active = true&#9;--Blocks clicks
&#9;droppedDownMenu.Position = UDim2.new(0,0,0,0)
&#9;droppedDownMenu.Size = UDim2.new(1,0, (1 + dropDownItemCount)*.8, 0)
&#9;droppedDownMenu.Parent = frame
&#9;droppedDownMenu.ZIndex = 2 + baseZIndex

&#9;local choiceButton = Instance.new(&quot;TextButton&quot;)
&#9;choiceButton.Name = &quot;ChoiceButton&quot;
&#9;choiceButton.BackgroundTransparency = 1
&#9;choiceButton.BorderSizePixel = 0
&#9;choiceButton.Text = &quot;ReplaceMe&quot;
&#9;choiceButton.TextColor3 = textColor
&#9;choiceButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;choiceButton.TextYAlignment = Enum.TextYAlignment.Center
&#9;choiceButton.BackgroundColor3 = Color3.new(1, 1, 1)
&#9;choiceButton.Font = Enum.Font.Arial
&#9;choiceButton.FontSize = Enum.FontSize.Size18
&#9;if useScrollButtons then
&#9;&#9;choiceButton.Size = UDim2.new(1,-13, .8/((dropDownItemCount + 1)*.8),0) 
&#9;else
&#9;&#9;choiceButton.Size = UDim2.new(1, 0, .8/((dropDownItemCount + 1)*.8),0) 
&#9;end
&#9;choiceButton.TextWrap = true
&#9;choiceButton.ZIndex = 2 + baseZIndex

&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = true
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 3 + baseZIndex

&#9;local dropDownSelected = false

&#9;local scrollUpButton 
&#9;local scrollDownButton
&#9;local scrollMouseCount = 0

&#9;local setZIndex = function(baseZIndex)
&#9;&#9;droppedDownMenu.ZIndex = baseZIndex +1
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex + 2
&#9;&#9;&#9;&#9;elseif child.Name == &quot;ClickCaptureButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollBarPosition = 1
&#9;local updateScroll = function()
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.Active = scrollBarPosition &gt; 1 
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.Active = scrollBarPosition + dropDownItemCount &lt;= itemCount 
&#9;&#9;end

&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if not children then return end

&#9;&#9;local childNum = 1&#9;&#9;&#9;
&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;if childNum &lt; scrollBarPosition or childNum &gt;= scrollBarPosition + dropDownItemCount then
&#9;&#9;&#9;&#9;&#9;obj.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;obj.Position = UDim2.new(0,0,((childNum-scrollBarPosition+1)*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;&#9;&#9;&#9;obj.Visible = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;obj.TextColor3 = textColor
&#9;&#9;&#9;&#9;obj.BackgroundTransparency = 1

&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;local toggleVisibility = function()
&#9;&#9;dropDownSelected = not dropDownSelected

&#9;&#9;areaSoak.Visible = not areaSoak.Visible
&#9;&#9;dropDownMenu.Visible = not dropDownSelected
&#9;&#9;droppedDownMenu.Visible = dropDownSelected
&#9;&#9;if dropDownSelected then
&#9;&#9;&#9;setZIndex(4 + baseZIndex)
&#9;&#9;else
&#9;&#9;&#9;setZIndex(2 + baseZIndex)
&#9;&#9;end
&#9;&#9;if useScrollButtons then
&#9;&#9;&#9;updateScroll()
&#9;&#9;end
&#9;end
&#9;droppedDownMenu.MouseButton1Click:connect(toggleVisibility)

&#9;local updateSelection = function(text)
&#9;&#9;local foundItem = false
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;local childNum = 1
&#9;&#9;if children then
&#9;&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;if obj.Text == text then
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;&#9;foundItem = true&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;scrollBarPosition = childNum&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;obj.TextColor3 = Color3.new(90/255,142/255,233/255)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;obj.TextColor3 = textColor
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if not text then
&#9;&#9;&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;&#9;&#9;scrollBarPosition = 1
&#9;&#9;else
&#9;&#9;&#9;if not foundItem then
&#9;&#9;&#9;&#9;error(&quot;Invalid Selection Update -- &quot; .. text)
&#9;&#9;&#9;end

&#9;&#9;&#9;if scrollBarPosition + dropDownItemCount &gt; itemCount + 1 then
&#9;&#9;&#9;&#9;scrollBarPosition = itemCount - dropDownItemCount + 1
&#9;&#9;&#9;end

&#9;&#9;&#9;dropDownMenu.Text = text
&#9;&#9;end
&#9;end
&#9;
&#9;local function scrollDown()
&#9;&#9;if scrollBarPosition + dropDownItemCount &lt;= itemCount then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition + 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;local function scrollUp()
&#9;&#9;if scrollBarPosition &gt; 1 then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition - 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;
&#9;if useScrollButtons then
&#9;&#9;--Make some scroll buttons
&#9;&#9;scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;&#9;scrollUpButton.BackgroundTransparency = 1
&#9;&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollUpButton.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;scrollUpButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;
&#9;&#9;&#9;&#9;scrollUp()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollUp() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)

&#9;&#9;scrollUpButton.Parent = droppedDownMenu

&#9;&#9;scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;&#9;scrollDownButton.BackgroundTransparency = 1
&#9;&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollDownButton.Position = UDim2.new(1,-11,1,-11)
&#9;&#9;scrollDownButton.Parent = droppedDownMenu
&#9;&#9;scrollDownButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1

&#9;&#9;&#9;&#9;scrollDown()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollDown() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)&#9;

&#9;&#9;local scrollbar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;&#9;scrollbar.BackgroundTransparency = 1
&#9;&#9;scrollbar.Size = UDim2.new(0, 18, (dropDownItemCount*.8)/((dropDownItemCount+1)*.8), -(17) - 11 - 4)
&#9;&#9;scrollbar.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),17+2)
&#9;&#9;scrollbar.Parent = droppedDownMenu
&#9;end

&#9;for i,item in ipairs(items) do
&#9;&#9;-- needed to maintain local scope for items in event listeners below
&#9;&#9;local button = choiceButton:clone()
&#9;&#9;if forRoblox then
&#9;&#9;
&#9;&#9;end&#9;&#9;
&#9;&#9;button.Text = item
&#9;&#9;button.Parent = droppedDownMenu
&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;button.TextColor3 = textColor
&#9;&#9;end

&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 1

&#9;&#9;&#9;updateSelection(item)
&#9;&#9;&#9;onSelect(item)

&#9;&#9;&#9;toggleVisibility()
&#9;&#9;end)
&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;--Add Highlight&#9;
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)

&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)
&#9;end

&#9;--This does the initial layout of the buttons&#9;
&#9;updateScroll()
&#9;
&#9;frame.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(frame)
&#9;&#9;end
&#9;end)

&#9;dropDownMenu.MouseButton1Click:connect(toggleVisibility)
&#9;areaSoak.MouseButton1Click:connect(toggleVisibility)
&#9;return frame, updateSelection
end

t.CreatePropertyDropDownMenu = function(instance, property, enum)

&#9;local items = enum:GetEnumItems()
&#9;local names = {}
&#9;local nameToItem = {}
&#9;for i,obj in ipairs(items) do
&#9;&#9;names[i] = obj.Name
&#9;&#9;nameToItem[obj.Name] = obj
&#9;end

&#9;local frame
&#9;local updateSelection
&#9;frame, updateSelection = t.CreateDropDownMenu(names, function(text) instance[property] = nameToItem[text] end)

&#9;ScopedConnect(frame, instance, &quot;Changed&quot;, 
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == property then
&#9;&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;&#9;end
&#9;&#9;end,
&#9;&#9;function()
&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;end)

&#9;return frame
end

t.GetFontHeight = function(font, fontSize)
&#9;if font == nil or fontSize == nil then
&#9;&#9;error(&quot;Font and FontSize must be non-nil&quot;)
&#9;end

&#9;if font == Enum.Font.Legacy then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 15
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 17
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 21
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 27
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 54
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 72
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;elseif font == Enum.Font.Arial or font == Enum.Font.ArialBold then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 8
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 9
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 10
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 11
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 24
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 48
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;error(&quot;Unknown Font &quot; .. font)
&#9;end
end

local function layoutGuiObjectsHelper(frame, guiObjects, settingsTable)
&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;local pixelsRemaining = frame.AbsoluteSize.Y
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if child:IsA(&quot;TextLabel&quot;) or child:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;local isLabel = child:IsA(&quot;TextLabel&quot;)
&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;end
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, pixelsRemaining)

&#9;&#9;&#9;if child.TextFits and child.TextBounds.Y &lt; pixelsRemaining then
&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextLabelSizePadY&quot;])
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextButtonSizePadY&quot;])
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;while not child.TextFits do
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.AbsoluteSize.Y + 1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y&#9;&#9;

&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;pixelsRemaining = -1
&#9;&#9;&#9;end&#9;&#9;&#9;

&#9;&#9;else
&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;child.Visible = (pixelsRemaining &gt;= 0)
&#9;&#9;end
&#9;end
end

t.LayoutGuiObjects = function(frame, guiObjects, settingsTable)
&#9;if not frame:IsA(&quot;GuiObject&quot;) then
&#9;&#9;error(&quot;Frame must be a GuiObject&quot;)
&#9;end
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if not child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements that are layed out must be of type GuiObject&quot;)
&#9;&#9;end
&#9;end

&#9;if not settingsTable then
&#9;&#9;settingsTable = {}
&#9;end

&#9;if not settingsTable[&quot;TextLabelSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelSizePadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextLabelPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelPositionPadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextButtonSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonSizePadY&quot;] = 12
&#9;end
&#9;if not settingsTable[&quot;TextButtonPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonPositionPadY&quot;] = 2
&#9;end

&#9;--Wrapper frame takes care of styled objects
&#9;local wrapperFrame = Instance.new(&quot;Frame&quot;)
&#9;wrapperFrame.Name = &quot;WrapperFrame&quot;
&#9;wrapperFrame.BackgroundTransparency = 1
&#9;wrapperFrame.Size = UDim2.new(1,0,1,0)
&#9;wrapperFrame.Parent = frame

&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;child.Parent = wrapperFrame
&#9;end

&#9;local recalculate = function()
&#9;&#9;wait()
&#9;&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
&#9;end
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(recalculate)

&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
end


t.CreateSlider = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 4
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local bar = Instance.new(&quot;TextButton&quot;)
&#9;bar.Text = &quot;&quot;
&#9;bar.AutoButtonColor = false
&#9;bar.Name = &quot;Bar&quot;
&#9;bar.BackgroundColor3 = Color3.new(0,0,0)
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width,0,5)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,5)
&#9;end
&#9;bar.BorderColor3 = Color3.new(95/255,95/255,95/255)
&#9;bar.ZIndex = 2
&#9;bar.Parent = sliderGui
&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end
&#9;
&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/Slider.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-10)
&#9;slider.Size = UDim2.new(0,20,0,20)
&#9;slider.ZIndex = 3
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)
&#9;
&#9;return sliderGui, sliderPosition, sliderSteps

end



t.CreateSliderNew = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 6
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local sliderBarImgHeight = 7
&#9;local sliderBarCapImgWidth = 4

&#9;local bar = Instance.new(&quot;ImageButton&quot;)
&#9;bar.BackgroundTransparency = 1
&#9;bar.Image = &quot;rbxasset://textures/ui/Slider-BKG-Center.png&quot;
&#9;bar.Name = &quot;Bar&quot;
&#9;local displayWidth = 200
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width - (sliderBarCapImgWidth * 2),0,sliderBarImgHeight)
&#9;&#9;displayWidth = width - (sliderBarCapImgWidth * 2)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,sliderBarImgHeight)
&#9;end
&#9;bar.ZIndex = 3
&#9;bar.Parent = sliderGui&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end

&#9;local barLeft = bar:clone()
&#9;barLeft.Name = &quot;BarLeft&quot;
&#9;barLeft.Image = &quot;rbxasset://textures/ui/Slider-BKG-Left-Cap.png&quot;
&#9;barLeft.Size = UDim2.new(0, sliderBarCapImgWidth, 0, sliderBarImgHeight)
&#9;barLeft.Position = UDim2.new(position.X.Scale, position.X.Offset - sliderBarCapImgWidth, position.Y.Scale, position.Y.Offset)
&#9;barLeft.Parent = sliderGui&#9;
&#9;barLeft.ZIndex = 3

&#9;local barRight = barLeft:clone()
&#9;barRight.Name = &quot;BarRight&quot;
&#9;barRight.Image = &quot;rbxasset://textures/ui/Slider-BKG-Right-Cap.png&quot;
&#9;barRight.Position = UDim2.new(position.X.Scale, position.X.Offset + displayWidth, position.Y.Scale, position.Y.Offset)
&#9;barRight.Parent = sliderGui&#9;

&#9;local fillLeft = barLeft:clone()
&#9;fillLeft.Name = &quot;FillLeft&quot;
&#9;fillLeft.Image = &quot;rbxasset://textures/ui/Slider-Fill-Left-Cap.png&quot;
&#9;fillLeft.Parent = sliderGui&#9;
&#9;fillLeft.ZIndex = 4

&#9;local fill = fillLeft:clone()
&#9;fill.Name = &quot;Fill&quot;
&#9;fill.Image = &quot;rbxasset://textures/ui/Slider-Fill-Center.png&quot;
&#9;fill.Parent = bar&#9;
&#9;fill.ZIndex = 4
&#9;fill.Position = UDim2.new(0, 0, 0, 0)
&#9;fill.Size = UDim2.new(0.5, 0, 1, 0)


--&#9;bar.Visible = false

&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/slider_new_tab.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-14)
&#9;slider.Size = UDim2.new(0,28,0,28)
&#9;slider.ZIndex = 5
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;&#9;fill.Size = UDim2.new(relativePosX, 0, 1, 0)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)

&#9;return sliderGui, sliderPosition, sliderSteps

end





t.CreateTrueScrollingFrame = function()
&#9;local lowY = nil
&#9;local highY = nil
&#9;
&#9;local dragCon = nil
&#9;local upCon = nil

&#9;local internalChange = false

&#9;local descendantsChangeConMap = {}

&#9;local scrollingFrame = Instance.new(&quot;Frame&quot;)
&#9;scrollingFrame.Name = &quot;ScrollingFrame&quot;
&#9;scrollingFrame.Active = true
&#9;scrollingFrame.Size = UDim2.new(1,0,1,0)
&#9;scrollingFrame.ClipsDescendants = true

&#9;local controlFrame = Instance.new(&quot;Frame&quot;)
&#9;controlFrame.Name = &quot;ControlFrame&quot;
&#9;controlFrame.BackgroundTransparency = 1
&#9;controlFrame.Size = UDim2.new(0,18,1,0)
&#9;controlFrame.Position = UDim2.new(1,-20,0,0)
&#9;controlFrame.Parent = scrollingFrame
&#9;
&#9;local scrollBottom = Instance.new(&quot;BoolValue&quot;)
&#9;scrollBottom.Value = false
&#9;scrollBottom.Name = &quot;ScrollBottom&quot;
&#9;scrollBottom.Parent = controlFrame
&#9;
&#9;local scrollUp = Instance.new(&quot;BoolValue&quot;)
&#9;scrollUp.Value = false
&#9;scrollUp.Name = &quot;scrollUp&quot;
&#9;scrollUp.Parent = controlFrame

&#9;local scrollUpButton = Instance.new(&quot;TextButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.Text = &quot;&quot;
&#9;scrollUpButton.AutoButtonColor = false
&#9;scrollUpButton.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollUpButton.BorderColor3 = Color3.new(1,1,1)
&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;scrollUpButton.Size = UDim2.new(0,18,0,18)
&#9;scrollUpButton.ZIndex = 2
&#9;scrollUpButton.Parent = controlFrame
&#9;for i = 1, 6 do
&#9;&#9;local triFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;triFrame.BorderColor3 = Color3.new(1,1,1)
&#9;&#9;triFrame.Name = &quot;tri&quot; .. tostring(i)
&#9;&#9;triFrame.ZIndex = 3
&#9;&#9;triFrame.BackgroundTransparency = 0.5
&#9;&#9;triFrame.Size = UDim2.new(0,12 - ((i -1) * 2),0,0)
&#9;&#9;triFrame.Position = UDim2.new(0,3 + (i -1),0.5,2 - (i -1))
&#9;&#9;triFrame.Parent = scrollUpButton
&#9;end
&#9;scrollUpButton.MouseEnter:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.1
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollUpButton.MouseLeave:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)

&#9;local scrollDownButton = scrollUpButton:clone()
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.Position = UDim2.new(0,0,1,-18)
&#9;local downChildren = scrollDownButton:GetChildren()
&#9;for i = 1, #downChildren do
&#9;&#9;downChildren[i].Position = UDim2.new(0,3 + (i -1),0.5,-2 + (i - 1))
&#9;end
&#9;scrollDownButton.MouseEnter:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.1
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.MouseLeave:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.5
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.Parent = controlFrame
&#9;
&#9;local scrollTrack = Instance.new(&quot;Frame&quot;)
&#9;scrollTrack.Name = &quot;ScrollTrack&quot;
&#9;scrollTrack.BackgroundTransparency = 1
&#9;scrollTrack.Size = UDim2.new(0,18,1,-38)
&#9;scrollTrack.Position = UDim2.new(0,0,0,19)
&#9;scrollTrack.Parent = controlFrame

&#9;local scrollbar = Instance.new(&quot;TextButton&quot;)
&#9;scrollbar.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollbar.BorderColor3 = Color3.new(1,1,1)
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.AutoButtonColor = false
&#9;scrollbar.Text = &quot;&quot;
&#9;scrollbar.Active = true
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.ZIndex = 2
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.Size = UDim2.new(0, 18, 0.1, 0)
&#9;scrollbar.Position = UDim2.new(0,0,0,0)
&#9;scrollbar.Parent = scrollTrack

&#9;local scrollNub = Instance.new(&quot;Frame&quot;)
&#9;scrollNub.Name = &quot;ScrollNub&quot;
&#9;scrollNub.BorderColor3 = Color3.new(1,1,1)
&#9;scrollNub.Size = UDim2.new(0,10,0,0)
&#9;scrollNub.Position = UDim2.new(0.5,-5,0.5,0)
&#9;scrollNub.ZIndex = 2
&#9;scrollNub.BackgroundTransparency = 0.5
&#9;scrollNub.Parent = scrollbar

&#9;local newNub = scrollNub:clone()
&#9;newNub.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;newNub.Parent = scrollbar
&#9;
&#9;local lastNub = scrollNub:clone()
&#9;lastNub.Position = UDim2.new(0.5,-5,0.5,2)
&#9;lastNub.Parent = scrollbar

&#9;scrollbar.MouseEnter:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.1
&#9;&#9;scrollNub.BackgroundTransparency = 0.1
&#9;&#9;newNub.BackgroundTransparency = 0.1
&#9;&#9;lastNub.BackgroundTransparency = 0.1
&#9;end)
&#9;scrollbar.MouseLeave:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.5
&#9;&#9;scrollNub.BackgroundTransparency = 0.5
&#9;&#9;newNub.BackgroundTransparency = 0.5
&#9;&#9;lastNub.BackgroundTransparency = 0.5
&#9;end)

&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10
&#9;
&#9;local function positionScrollBar(x,y,offset)
&#9;&#9;local oldPos = scrollbar.Position

&#9;&#9;if y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;
&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y

&#9;&#9;if y &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;local newScaleYPos = (y - scrollTrack.AbsolutePosition.y - offset)/scrollTrack.AbsoluteSize.y
&#9;&#9;if newScaleYPos + relativeSize &gt; 1 then
&#9;&#9;&#9;newScaleYPos = 1 - relativeSize
&#9;&#9;&#9;scrollBottom.Value = true
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;elseif newScaleYPos &lt;= 0 then
&#9;&#9;&#9;newScaleYPos = 0
&#9;&#9;&#9;scrollUp.Value = true
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;else
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;end
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,newScaleYPos,0)
&#9;&#9;
&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;end

&#9;local function drillDownSetHighLow(instance)
&#9;&#9;if not instance or not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if instance == controlFrame then return end
&#9;&#9;if instance:IsDescendantOf(controlFrame) then return end
&#9;&#9;if not instance.Visible then return end

&#9;&#9;if lowY and lowY &gt; instance.AbsolutePosition.Y then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;elseif not lowY then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;end
&#9;&#9;if highY and highY &lt; (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;local children = instance:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;drillDownSetHighLow(children[i])
&#9;&#9;end
&#9;end

&#9;local function resetHighLow()
&#9;&#9;local firstChildren = scrollingFrame:GetChildren()

&#9;&#9;for i = 1, #firstChildren do
&#9;&#9;&#9;drillDownSetHighLow(firstChildren[i])
&#9;&#9;end
&#9;end

&#9;local function recalculate()
&#9;&#9;internalChange = true

&#9;&#9;local percentFrame = 0
&#9;&#9;if scrollbar.Position.Y.Scale &gt; 0 then
&#9;&#9;&#9;if scrollbar.Visible then
&#9;&#9;&#9;&#9;percentFrame = scrollbar.Position.Y.Scale/((scrollTrack.AbsoluteSize.Y - scrollbar.AbsoluteSize.Y)/scrollTrack.AbsoluteSize.Y)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;percentFrame = 0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if percentFrame &gt; 0.99 then percentFrame = 1 end

&#9;&#9;local hiddenYAmount = (scrollingFrame.AbsoluteSize.Y - (highY - lowY)) * percentFrame
&#9;&#9;
&#9;&#9;local guiChildren = scrollingFrame:GetChildren()
&#9;&#9;for i = 1, #guiChildren do
&#9;&#9;&#9;if guiChildren[i] ~= controlFrame then
&#9;&#9;&#9;&#9;guiChildren[i].Position = UDim2.new(guiChildren[i].Position.X.Scale,guiChildren[i].Position.X.Offset,
&#9;&#9;&#9;&#9;&#9;0, math.ceil(guiChildren[i].AbsolutePosition.Y) - math.ceil(lowY) + hiddenYAmount)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()
&#9;&#9;internalChange = false
&#9;end

&#9;local function setSliderSizeAndPosition()
&#9;&#9;if not highY or not lowY then return end

&#9;&#9;local totalYSpan = math.abs(highY - lowY)
&#9;&#9;if totalYSpan == 0 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false

&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;local percentShown = scrollingFrame.AbsoluteSize.Y/totalYSpan
&#9;&#9;if percentShown &gt;= 1 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false
&#9;&#9;&#9;recalculate()
&#9;&#9;else
&#9;&#9;&#9;scrollbar.Visible = true
&#9;&#9;&#9;scrollDownButton.Visible = true
&#9;&#9;&#9;scrollUpButton.Visible = true

&#9;&#9;&#9;scrollbar.Size = UDim2.new(scrollbar.Size.X.Scale,scrollbar.Size.X.Offset,percentShown,0)
&#9;&#9;end

&#9;&#9;local percentPosition = (scrollingFrame.AbsolutePosition.Y - lowY)/totalYSpan
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,percentPosition,-scrollbar.AbsoluteSize.X/2)

&#9;&#9;if scrollbar.AbsolutePosition.y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;end

&#9;&#9;if (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.Y) &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;end
&#9;end
&#9;
&#9;local buttonScrollAmountPixels = 7
&#9;local reentrancyGuardScrollUp = false
&#9;local function doScrollUp()
&#9;&#9;if reentrancyGuardScrollUp then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollUp = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y - buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollUp = false
&#9;end
&#9;
&#9;local reentrancyGuardScrollDown = false
&#9;local function doScrollDown()
&#9;&#9;if reentrancyGuardScrollDown then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollDown = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y + buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollDown = false
&#9;end

&#9;local function scrollUp(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollbar.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function scrollDown(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;scrollbar.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollbar.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollbar.AbsolutePosition.y
&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;local prevY = y
&#9;&#9;&#9;local reentrancyGuardMouseScroll = false
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;if reentrancyGuardMouseScroll then return end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = true
&#9;&#9;&#9;&#9;&#9;if positionScrollBar(x,y,mouseOffset) then
&#9;&#9;&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = false
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(function()
&#9;&#9;scrollUp()
&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)

&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(function()
&#9;&#9; scrollDown()
&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;
&#9;local function heightCheck(instance)
&#9;&#9;if highY and (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) &gt; highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;setSliderSizeAndPosition()
&#9;end
&#9;
&#9;local function highLowRecheck()
&#9;&#9;local oldLowY = lowY
&#9;&#9;local oldHighY = highY
&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()

&#9;&#9;if (lowY ~= oldLowY) or (highY ~= oldHighY) then
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end

&#9;local function descendantChanged(this, prop)
&#9;&#9;if internalChange then return end
&#9;&#9;if not this.Visible then return end

&#9;&#9;if prop == &quot;Size&quot; or prop == &quot;Position&quot; then
&#9;&#9;&#9;wait()
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end
&#9;end

&#9;scrollingFrame.DescendantAdded:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end

&#9;&#9;if instance.Visible then
&#9;&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end

&#9;&#9;descendantsChangeConMap[instance] = instance.Changed:connect(function(prop) descendantChanged(instance, prop) end)
&#9;end)

&#9;scrollingFrame.DescendantRemoving:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if descendantsChangeConMap[instance] then
&#9;&#9;&#9;descendantsChangeConMap[instance]:disconnect()
&#9;&#9;&#9;descendantsChangeConMap[instance] = nil
&#9;&#9;end
&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;highLowRecheck()
&#9;end)
&#9;
&#9;scrollingFrame.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;if not highY or not lowY then return end

&#9;&#9;&#9;highLowRecheck()
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end)

&#9;return scrollingFrame, controlFrame
end

t.CreateScrollingFrame = function(orderList,scrollStyle)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;ScrollingFrame&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(1,0,1,0)
&#9;
&#9;local scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.BackgroundTransparency = 1
&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 

&#9;
&#9;local scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.BackgroundTransparency = 1
&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;
&#9;local scrollbar = Instance.new(&quot;ImageButton&quot;)
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;scrollbar.BackgroundTransparency = 1
&#9;scrollbar.Size = UDim2.new(0, 18, 0, 150)

&#9;local scrollStamp = 0
&#9;&#9;
&#9;local scrollDrag = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDrag.Image = &quot;http://www.roblox.com/asset/?id=61367186&quot;
&#9;scrollDrag.Size = UDim2.new(1, 0, 0, 16)
&#9;scrollDrag.BackgroundTransparency = 1
&#9;scrollDrag.Name = &quot;ScrollDrag&quot;
&#9;scrollDrag.Active = true
&#9;scrollDrag.Parent = scrollbar
&#9;
&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10

&#9;local style = &quot;simple&quot;
&#9;if scrollStyle and tostring(scrollStyle) then
&#9;&#9;style = scrollStyle
&#9;end
&#9;
&#9;local scrollPosition = 1
&#9;local rowSize = 0
&#9;local howManyDisplayed = 0
&#9;&#9;
&#9;local layoutGridScrollBar = function()
&#9;&#9;howManyDisplayed = 0
&#9;&#9;local guiObjects = {}
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;
&#9;&#9;local totalPixelsY = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemainingY = frame.AbsoluteSize.Y
&#9;&#9;
&#9;&#9;local totalPixelsX  = frame.AbsoluteSize.X
&#9;&#9;
&#9;&#9;local xCounter = 0
&#9;&#9;local rowSizeCounter = 0
&#9;&#9;local setRowSize = true

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;
&#9;&#9;local currentRowY = 0

&#9;&#9;pos = scrollPosition
&#9;&#9;--count up from current scroll position to fill out grid
&#9;&#9;while pos &lt;= #guiObjects and pixelsBelowScrollbar &lt; totalPixelsY do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;--previous pos was the end of a row
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;end
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos + 1
&#9;&#9;end
&#9;&#9;--Count wherever current row left off
&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;currentRowY = 0
&#9;&#9;
&#9;&#9;pos = scrollPosition - 1
&#9;&#9;xCounter = 0
&#9;&#9;
&#9;&#9;--objects with varying X,Y dimensions can rarely cause minor errors
&#9;&#9;--rechecking every new scrollPosition is necessary to avoid 100% of errors
&#9;&#9;
&#9;&#9;--count backwards from current scrollPosition to see if we can add more rows
&#9;&#9;while pixelsBelowScrollbar + currentRowY &lt; totalPixelsY and pos &gt;= 1 do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;rowSizeCounter = rowSizeCounter + 1
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;rowSizeCounter = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= rowSize then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1 
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - rowSize
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end

&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end
&#9;&#9;
&#9;&#9;--Do check last time if pos = 0
&#9;&#9;if (pos == 0) and (pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY) then
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;end

&#9;&#9;xCounter = 0
&#9;&#9;--pos = scrollPosition
&#9;&#9;rowSizeCounter = 0
&#9;&#9;setRowSize = true
&#9;&#9;local lastChildSize = 0
&#9;&#9;
&#9;&#9;local xOffset,yOffset = 0
&#9;&#9;if guiObjects[1] then
&#9;&#9;&#9;yOffset = math.ceil(math.floor(math.fmod(totalPixelsY,guiObjects[1].AbsoluteSize.X))/2)
&#9;&#9;&#9;xOffset = math.ceil(math.floor(math.fmod(totalPixelsX,guiObjects[1].AbsoluteSize.Y))/2)
&#9;&#9;end
&#9;&#9;
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemainingY &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;if setRowSize then rowSizeCounter = rowSizeCounter + 1 end
&#9;&#9;&#9;&#9;&#9;if xCounter + child.AbsoluteSize.X &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;&#9;&#9;if setRowSize then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;setRowSize = false
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;xCounter = 0
&#9;&#9;&#9;&#9;&#9;&#9;pixelsRemainingY = pixelsRemainingY - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale,xCounter + xOffset, 0, totalPixelsY - pixelsRemainingY + yOffset)
&#9;&#9;&#9;&#9;&#9;xCounter = xCounter + child.AbsoluteSize.X
&#9;&#9;&#9;&#9;&#9;child.Visible = ((pixelsRemainingY - child.AbsoluteSize.Y) &gt;= 0)
&#9;&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;lastChildSize = child.AbsoluteSize&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;if lastChildSize == 0 then 
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;else
&#9;&#9;&#9;scrollDownButton.Active = ((pixelsRemainingY - lastChildSize.Y) &lt; 0)
&#9;&#9;end
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end



&#9;local layoutSimpleScrollBar = function()
&#9;&#9;local guiObjects = {}&#9;
&#9;&#9;howManyDisplayed = 0
&#9;&#9;
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemaining = frame.AbsoluteSize.Y

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;while pixelsBelowScrollbar &lt; totalPixels and pos &gt;= 1 do
&#9;&#9;&#9;if pos &gt;= scrollPosition then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y &lt;= totalPixels then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= 1 then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--local (&quot;Backing up ScrollPosition from -- &quot; ..scrollPosition)
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end

&#9;&#9;pos = scrollPosition
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemaining &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if  (pixelsRemaining &gt;= 0) then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;scrollDownButton.Active = (pixelsRemaining &lt; 0)
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end
&#9;
&#9;&#9;
&#9;local moveDragger = function()&#9;
&#9;&#9;local guiObjects = 0
&#9;&#9;local children = frame:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;if not scrollDrag.Parent then return end
&#9;&#9;
&#9;&#9;local dragSizeY = scrollDrag.Parent.AbsoluteSize.y * (1/(guiObjects - howManyDisplayed + 1))
&#9;&#9;if dragSizeY &lt; 16 then dragSizeY = 16 end
&#9;&#9;scrollDrag.Size = UDim2.new(scrollDrag.Size.X.Scale,scrollDrag.Size.X.Offset,scrollDrag.Size.Y.Scale,dragSizeY)

&#9;&#9;local relativeYPos = (scrollPosition - 1)/(guiObjects - (howManyDisplayed))
&#9;&#9;if relativeYPos &gt; 1 then relativeYPos = 1
&#9;&#9;elseif relativeYPos &lt; 0 then relativeYPos = 0 end
&#9;&#9;local absYPos = 0
&#9;&#9;
&#9;&#9;if relativeYPos ~= 0 then
&#9;&#9;&#9;absYPos = (relativeYPos * scrollbar.AbsoluteSize.y) - (relativeYPos * scrollDrag.AbsoluteSize.y)
&#9;&#9;end
&#9;&#9;
&#9;&#9;scrollDrag.Position = UDim2.new(scrollDrag.Position.X.Scale,scrollDrag.Position.X.Offset,scrollDrag.Position.Y.Scale,absYPos)
&#9;end

&#9;local reentrancyGuard = false
&#9;local recalculate = function()
&#9;&#9;if reentrancyGuard then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;reentrancyGuard = true
&#9;&#9;wait()
&#9;&#9;local success, err = nil
&#9;&#9;if style == &quot;grid&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutGridScrollBar() end)
&#9;&#9;elseif style == &quot;simple&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutSimpleScrollBar() end)
&#9;&#9;end
&#9;&#9;if not success then print(err) end
&#9;&#9;moveDragger()
&#9;&#9;reentrancyGuard = false
&#9;end
&#9;
&#9;local doScrollUp = function()
&#9;&#9;scrollPosition = (scrollPosition) - rowSize
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;recalculate(nil)
&#9;end
&#9;
&#9;local doScrollDown = function()
&#9;&#9;scrollPosition = (scrollPosition) + rowSize
&#9;&#9;recalculate(nil)
&#9;end

&#9;local scrollUp = function(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollDrag.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollDown = function(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollDrag.AbsolutePosition.y + scrollDrag.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local y = 0
&#9;scrollDrag.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollDrag.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollDrag.AbsolutePosition.y
&#9;&#9;&#9;local dragCon
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;local barAbsPos = scrollbar.AbsolutePosition.y
&#9;&#9;&#9;&#9;local barAbsSize = scrollbar.AbsoluteSize.y
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local dragAbsSize = scrollDrag.AbsoluteSize.y
&#9;&#9;&#9;&#9;local barAbsOne = barAbsPos + barAbsSize - dragAbsSize
&#9;&#9;&#9;&#9;y = y - mouseOffset
&#9;&#9;&#9;&#9;y = y &lt; barAbsPos and barAbsPos or y &gt; barAbsOne and barAbsOne or y
&#9;&#9;&#9;&#9;y = y - barAbsPos
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local guiObjects = 0
&#9;&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local doublePercent = y/(barAbsSize-dragAbsSize)
&#9;&#9;&#9;&#9;local rowDiff = rowSize
&#9;&#9;&#9;&#9;local totalScrollCount = guiObjects - (howManyDisplayed - 1)
&#9;&#9;&#9;&#9;local newScrollPosition = math.floor((doublePercent * totalScrollCount) + 0.5) + rowDiff
&#9;&#9;&#9;&#9;if newScrollPosition &lt; scrollPosition then
&#9;&#9;&#9;&#9;&#9;rowDiff = -rowDiff
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if newScrollPosition &lt; 1 then
&#9;&#9;&#9;&#9;&#9;newScrollPosition = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;scrollPosition = newScrollPosition
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollUp()
&#9;&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)


&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollDown()&#9;
&#9;&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollbar.MouseButton1Down:connect(
&#9;&#9;function(x,y)
&#9;&#9;&#9;if y &gt; (scrollDrag.AbsoluteSize.y + scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollDown(y)
&#9;&#9;&#9;elseif y &lt; (scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollUp(y)
&#9;&#9;&#9;end
&#9;&#9;end)


&#9;frame.ChildAdded:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)

&#9;frame.ChildRemoved:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(function() recalculate(nil) end)

&#9;return frame, scrollUpButton, scrollDownButton, recalculate, scrollbar
end
local function binaryGrow(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local biggestLegal = min

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (biggestLegal == nil or biggestLegal &lt; mid) then
&#9;&#9;&#9;biggestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--Try growing
&#9;&#9;&#9;min = mid + 1
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, shrink
&#9;&#9;&#9;max = mid - 1
&#9;&#9;end
&#9;end
&#9;return biggestLegal
end


local function binaryShrink(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local smallestLegal = max

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (smallestLegal == nil or smallestLegal &gt; mid) then
&#9;&#9;&#9;smallestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--It fits, shrink
&#9;&#9;&#9;max = mid - 1&#9;&#9;&#9;
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, grow
&#9;&#9;&#9;min = mid + 1
&#9;&#9;end
&#9;end
&#9;return smallestLegal
end


local function getGuiOwner(instance)
&#9;while instance ~= nil do
&#9;&#9;if instance:IsA(&quot;ScreenGui&quot;) or instance:IsA(&quot;BillboardGui&quot;)  then
&#9;&#9;&#9;return instance
&#9;&#9;end
&#9;&#9;instance = instance.Parent
&#9;end
&#9;return nil
end

t.AutoTruncateTextObject = function(textLabel)
&#9;local text = textLabel.Text

&#9;local fullLabel = textLabel:Clone()
&#9;fullLabel.Name = &quot;Full&quot; .. textLabel.Name 
&#9;fullLabel.BorderSizePixel = 0
&#9;fullLabel.BackgroundTransparency = 0
&#9;fullLabel.Text = text
&#9;fullLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;fullLabel.Position = UDim2.new(0,-3,0,0)
&#9;fullLabel.Size = UDim2.new(0,100,1,0)
&#9;fullLabel.Visible = false
&#9;fullLabel.Parent = textLabel

&#9;local shortText = nil
&#9;local mouseEnterConnection = nil
&#9;local mouseLeaveConnection= nil

&#9;local checkForResize = function()
&#9;&#9;if getGuiOwner(textLabel) == nil then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;textLabel.Text = text
&#9;&#9;if textLabel.TextFits then 
&#9;&#9;&#9;--Tear down the rollover if it is active
&#9;&#9;&#9;if mouseEnterConnection then
&#9;&#9;&#9;&#9;mouseEnterConnection:disconnect()
&#9;&#9;&#9;&#9;mouseEnterConnection = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection then
&#9;&#9;&#9;&#9;mouseLeaveConnection:disconnect()
&#9;&#9;&#9;&#9;mouseLeaveConnection = nil
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local len = string.len(text)
&#9;&#9;&#9;textLabel.Text = text .. &quot;~&quot;

&#9;&#9;&#9;--Shrink the text
&#9;&#9;&#9;local textSize = binaryGrow(0, len, 
&#9;&#9;&#9;&#9;function(pos)
&#9;&#9;&#9;&#9;&#9;if pos == 0 then
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = string.sub(text, 1, pos) .. &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;shortText = string.sub(text, 1, textSize) .. &quot;~&quot;
&#9;&#9;&#9;textLabel.Text = shortText
&#9;&#9;&#9;
&#9;&#9;&#9;--Make sure the fullLabel fits
&#9;&#9;&#9;if not fullLabel.TextFits then
&#9;&#9;&#9;&#9;--Already too small, grow it really bit to start
&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, 10000, 1, 0)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;--Okay, now try to binary shrink it back down
&#9;&#9;&#9;local fullLabelSize = binaryShrink(textLabel.AbsoluteSize.X,fullLabel.AbsoluteSize.X, 
&#9;&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, size, 1, 0)
&#9;&#9;&#9;&#9;&#9;return fullLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;fullLabel.Size = UDim2.new(0,fullLabelSize+6,1,0)

&#9;&#9;&#9;--Now setup the rollover effects, if they are currently off
&#9;&#9;&#9;if mouseEnterConnection == nil then
&#9;&#9;&#9;&#9;mouseEnterConnection = textLabel.MouseEnter:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.ZIndex = textLabel.ZIndex + 1
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection == nil then
&#9;&#9;&#9;&#9;mouseLeaveConnection = textLabel.MouseLeave:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = shortText
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;textLabel.AncestryChanged:connect(checkForResize)
&#9;textLabel.Changed:connect(
&#9;&#9;function(prop) 
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then 
&#9;&#9;&#9;&#9;checkForResize() &#9;
&#9;&#9;&#9;end 
&#9;&#9;end)

&#9;checkForResize()

&#9;local function changeText(newText)
&#9;&#9;text = newText
&#9;&#9;fullLabel.Text = text
&#9;&#9;checkForResize()
&#9;end

&#9;return textLabel, changeText
end

local function TransitionTutorialPages(fromPage, toPage, transitionFrame, currentPageValue)&#9;
&#9;if fromPage then
&#9;&#9;fromPage.Visible = false
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = fromPage.Size
&#9;&#9;&#9;transitionFrame.Position = fromPage.Position
&#9;&#9;end
&#9;else
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = UDim2.new(0.0,50,0.0,50)
&#9;&#9;&#9;transitionFrame.Position = UDim2.new(0.5,-25,0.5,-25)
&#9;&#9;end
&#9;end
&#9;transitionFrame.Visible = true
&#9;currentPageValue.Value = nil

&#9;local newsize, newPosition
&#9;if toPage then
&#9;&#9;--Make it visible so it resizes
&#9;&#9;toPage.Visible = true

&#9;&#9;newSize = toPage.Size
&#9;&#9;newPosition = toPage.Position

&#9;&#9;toPage.Visible = false
&#9;else
&#9;&#9;newSize = UDim2.new(0.0,50,0.0,50)
&#9;&#9;newPosition = UDim2.new(0.5,-25,0.5,-25)
&#9;end
&#9;transitionFrame:TweenSizeAndPosition(newSize, newPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, 0.3, true,
&#9;&#9;function(state)
&#9;&#9;&#9;if state == Enum.TweenStatus.Completed then
&#9;&#9;&#9;&#9;transitionFrame.Visible = false
&#9;&#9;&#9;&#9;if toPage then
&#9;&#9;&#9;&#9;&#9;toPage.Visible = true
&#9;&#9;&#9;&#9;&#9;currentPageValue.Value = toPage
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
end

t.CreateTutorial = function(name, tutorialKey, createButtons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;Tutorial-&quot; .. name
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)

&#9;local transitionFrame = Instance.new(&quot;Frame&quot;)
&#9;transitionFrame.Name = &quot;TransitionFrame&quot;
&#9;transitionFrame.Style = Enum.FrameStyle.RobloxRound
&#9;transitionFrame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;transitionFrame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;transitionFrame.Visible = false
&#9;transitionFrame.Parent = frame

&#9;local currentPageValue = Instance.new(&quot;ObjectValue&quot;)
&#9;currentPageValue.Name = &quot;CurrentTutorialPage&quot;
&#9;currentPageValue.Value = nil
&#9;currentPageValue.Parent = frame

&#9;local boolValue = Instance.new(&quot;BoolValue&quot;)
&#9;boolValue.Name = &quot;Buttons&quot;
&#9;boolValue.Value = createButtons
&#9;boolValue.Parent = frame

&#9;local pages = Instance.new(&quot;Frame&quot;)
&#9;pages.Name = &quot;Pages&quot;
&#9;pages.BackgroundTransparency = 1
&#9;pages.Size = UDim2.new(1,0,1,0)
&#9;pages.Parent = frame

&#9;local function getVisiblePageAndHideOthers()
&#9;&#9;local visiblePage = nil
&#9;&#9;local children = pages:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i,child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;if visiblePage then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;visiblePage = child
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return visiblePage
&#9;end

&#9;local showTutorial = function(alwaysShow)
&#9;&#9;if alwaysShow or UserSettings().GameSettings:GetTutorialState(tutorialKey) == false then
&#9;&#9;&#9;print(&quot;Showing tutorial-&quot;,tutorialKey)
&#9;&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;&#9;local firstPage = pages:FindFirstChild(&quot;TutorialPage1&quot;)
&#9;&#9;&#9;if firstPage then
&#9;&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, firstPage, transitionFrame, currentPageValue)&#9;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;Could not find TutorialPage1&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local dismissTutorial = function()
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;if currentTutorialPage then
&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, nil, transitionFrame, currentPageValue)
&#9;&#9;end

&#9;&#9;UserSettings().GameSettings:SetTutorialState(tutorialKey, true)
&#9;end

&#9;local gotoPage = function(pageNum)
&#9;&#9;local page = pages:FindFirstChild(&quot;TutorialPage&quot; .. pageNum)
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()
&#9;&#9;TransitionTutorialPages(currentTutorialPage, page, transitionFrame, currentPageValue)
&#9;end

&#9;return frame, showTutorial, dismissTutorial, gotoPage
end 

local function CreateBasicTutorialPage(name, handleResize, skipTutorial, giveDoneButton)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TutorialPage&quot;
&#9;frame.Style = Enum.FrameStyle.RobloxRound
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;frame.Visible = false
&#9;
&#9;local frameHeader = Instance.new(&quot;TextLabel&quot;)
&#9;frameHeader.Name = &quot;Header&quot;
&#9;frameHeader.Text = name
&#9;frameHeader.BackgroundTransparency = 1
&#9;frameHeader.FontSize = Enum.FontSize.Size24
&#9;frameHeader.Font = Enum.Font.ArialBold
&#9;frameHeader.TextColor3 = Color3.new(1,1,1)
&#9;frameHeader.TextXAlignment = Enum.TextXAlignment.Center
&#9;frameHeader.TextWrap = true
&#9;frameHeader.Size = UDim2.new(1,-55, 0, 22)
&#9;frameHeader.Position = UDim2.new(0,0,0,0)
&#9;frameHeader.Parent = frame

&#9;local skipButton = Instance.new(&quot;ImageButton&quot;)
&#9;skipButton.Name = &quot;SkipButton&quot;
&#9;skipButton.AutoButtonColor = false
&#9;skipButton.BackgroundTransparency = 1
&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;skipButton.MouseButton1Click:connect(function()
&#9;&#9;skipTutorial()
&#9;end)
&#9;skipButton.MouseEnter:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton_dn.png&quot;
&#9;end)
&#9;skipButton.MouseLeave:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;end)
&#9;skipButton.Size = UDim2.new(0, 25, 0, 25)
&#9;skipButton.Position = UDim2.new(1, -25, 0, 0)
&#9;skipButton.Parent = frame
&#9;
&#9;
&#9;if giveDoneButton then
&#9;&#9;local doneButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;doneButton.Name = &quot;DoneButton&quot;
&#9;&#9;doneButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;doneButton.Text = &quot;Done&quot;
&#9;&#9;doneButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;doneButton.Font = Enum.Font.ArialBold
&#9;&#9;doneButton.FontSize = Enum.FontSize.Size18
&#9;&#9;doneButton.Size = UDim2.new(0,100,0,50)
&#9;&#9;doneButton.Position = UDim2.new(0.5,-50,1,-50)
&#9;&#9;
&#9;&#9;if skipTutorial then
&#9;&#9;&#9;doneButton.MouseButton1Click:connect(function() skipTutorial() end)
&#9;&#9;end
&#9;&#9;
&#9;&#9;doneButton.Parent = frame
&#9;end

&#9;local innerFrame = Instance.new(&quot;Frame&quot;)
&#9;innerFrame.Name = &quot;ContentFrame&quot;
&#9;innerFrame.BackgroundTransparency = 1
&#9;innerFrame.Position = UDim2.new(0,0,0,25)
&#9;innerFrame.Parent = frame

&#9;local nextButton = Instance.new(&quot;TextButton&quot;)
&#9;nextButton.Name = &quot;NextButton&quot;
&#9;nextButton.Text = &quot;Next&quot;
&#9;nextButton.TextColor3 = Color3.new(1,1,1)
&#9;nextButton.Font = Enum.Font.Arial
&#9;nextButton.FontSize = Enum.FontSize.Size18
&#9;nextButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;nextButton.Size = UDim2.new(0,80, 0, 32)
&#9;nextButton.Position = UDim2.new(0.5, 5, 1, -32)
&#9;nextButton.Active = false
&#9;nextButton.Visible = false
&#9;nextButton.Parent = frame

&#9;local prevButton = Instance.new(&quot;TextButton&quot;)
&#9;prevButton.Name = &quot;PrevButton&quot;
&#9;prevButton.Text = &quot;Previous&quot;
&#9;prevButton.TextColor3 = Color3.new(1,1,1)
&#9;prevButton.Font = Enum.Font.Arial
&#9;prevButton.FontSize = Enum.FontSize.Size18
&#9;prevButton.Style = Enum.ButtonStyle.RobloxButton
&#9;prevButton.Size = UDim2.new(0,80, 0, 32)
&#9;prevButton.Position = UDim2.new(0.5, -85, 1, -32)
&#9;prevButton.Active = false
&#9;prevButton.Visible = false
&#9;prevButton.Parent = frame

&#9;if giveDoneButton then
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-75)
&#9;else
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-22)
&#9;end

&#9;local parentConnection = nil

&#9;local function basicHandleResize()
&#9;&#9;if frame.Visible and frame.Parent then
&#9;&#9;&#9;local maxSize = math.min(frame.Parent.AbsoluteSize.X, frame.Parent.AbsoluteSize.Y)
&#9;&#9;&#9;handleResize(200,maxSize)
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;Parent&quot; then
&#9;&#9;&#9;&#9;if parentConnection ~= nil then
&#9;&#9;&#9;&#9;&#9;parentConnection:disconnect()
&#9;&#9;&#9;&#9;&#9;parentConnection = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if frame.Parent and frame.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;parentConnection = frame.Parent.Changed:connect(
&#9;&#9;&#9;&#9;&#9;&#9;function(parentProp)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if parentProp == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;if prop == &quot;Visible&quot; then 
&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;end
&#9;&#9;end)

&#9;return frame, innerFrame
end

t.CreateTextTutorialPage = function(name, text, skipTutorialFunc)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local textLabel = Instance.new(&quot;TextLabel&quot;)
&#9;textLabel.BackgroundTransparency = 1
&#9;textLabel.TextColor3 = Color3.new(1,1,1)
&#9;textLabel.Text = text
&#9;textLabel.TextWrap = true
&#9;textLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;textLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;textLabel.Font = Enum.Font.Arial
&#9;textLabel.FontSize = Enum.FontSize.Size14
&#9;textLabel.Size = UDim2.new(1,0,1,0)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;end)
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc)
&#9;textLabel.Parent = contentFrame

&#9;return frame
end

t.CreateImageTutorialPage = function(name, imageAsset, x, y, skipTutorialFunc, giveDoneButton)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local imageLabel = Instance.new(&quot;ImageLabel&quot;)
&#9;imageLabel.BackgroundTransparency = 1
&#9;imageLabel.Image = imageAsset
&#9;imageLabel.Size = UDim2.new(0,x,0,y)
&#9;imageLabel.Position = UDim2.new(0.5,-x/2,0.5,-y/2)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;return size &gt;= x and size &gt;= y
&#9;&#9;&#9;end)
&#9;&#9;if size &gt;= x and size &gt;= y then
&#9;&#9;&#9;imageLabel.Size = UDim2.new(0,x, 0,y)
&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5,-x/2, 0.5, -y/2)
&#9;&#9;else
&#9;&#9;&#9;if x &gt; y then
&#9;&#9;&#9;&#9;--X is limiter, so 
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(1,0,y/x,0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0,0, 0.5 - (y/x)/2, 0)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--Y is limiter
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(x/y,0,1, 0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5-(x/y)/2, 0, 0, 0)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;size = size + 50
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc, giveDoneButton)
&#9;imageLabel.Parent = contentFrame

&#9;return frame
end

t.AddTutorialPage = function(tutorial, tutorialPage)
&#9;local transitionFrame = tutorial.TransitionFrame
&#9;local currentPageValue = tutorial.CurrentTutorialPage

&#9;if not tutorial.Buttons.Value then
&#9;&#9;tutorialPage.NextButton.Parent = nil
&#9;&#9;tutorialPage.PrevButton.Parent = nil
&#9;end

&#9;local children = tutorial.Pages:GetChildren()
&#9;if children and #children &gt; 0 then
&#9;&#9;tutorialPage.Name = &quot;TutorialPage&quot; .. (#children+1)
&#9;&#9;local previousPage = children[#children]
&#9;&#9;if not previousPage:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements under Pages must be GuiObjects&quot;)
&#9;&#9;end

&#9;&#9;if tutorial.Buttons.Value then
&#9;&#9;&#9;if previousPage.NextButton.Active then
&#9;&#9;&#9;&#9;error(&quot;NextButton already Active on previousPage, please only add pages with t.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;previousPage.NextButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(previousPage, tutorialPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;previousPage.NextButton.Active = true
&#9;&#9;&#9;previousPage.NextButton.Visible = true

&#9;&#9;&#9;if tutorialPage.PrevButton.Active then
&#9;&#9;&#9;&#9;error(&quot;PrevButton already Active on tutorialPage, please only add pages with t.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;tutorialPage.PrevButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(tutorialPage, previousPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;tutorialPage.PrevButton.Active = true
&#9;&#9;&#9;tutorialPage.PrevButton.Visible = true
&#9;&#9;end

&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;else
&#9;&#9;--First child
&#9;&#9;tutorialPage.Name = &quot;TutorialPage1&quot;
&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;end
end 

t.CreateSetPanel = function(userIdsForSets, objectSelected, dialogClosed, size, position, showAdminCategories, useAssetVersionId)

&#9;if not userIdsForSets then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is nil, should be a table of number ids&quot;)
&#9;end
&#9;if type(userIdsForSets) ~= &quot;table&quot; and type(userIdsForSets) ~= &quot;userdata&quot; then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is of type &quot; ..type(userIdsForSets) .. &quot;, should be of type table or userdata&quot;)
&#9;end
&#9;if not objectSelected then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is nil, should be a callback function!&quot;)
&#9;end
&#9;if type(objectSelected) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is of type &quot; .. type(objectSelected) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;if dialogClosed and type(dialogClosed) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: dialogClosed (third arg) is of type &quot; .. type(dialogClosed) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;
&#9;if showAdminCategories == nil then -- by default, don&apos;t show beta sets
&#9;&#9;showAdminCategories = false
&#9;end

&#9;local arrayPosition = 1
&#9;local insertButtons = {}
&#9;local insertButtonCons = {}
&#9;local contents = nil
&#9;local setGui = nil

&#9;-- used for water selections
&#9;local waterForceDirection = &quot;NegX&quot;
&#9;local waterForce = &quot;None&quot;
&#9;local waterGui, waterTypeChangedEvent = nil
&#9;
&#9;local Data = {}
&#9;Data.CurrentCategory = nil
&#9;Data.Category = {}
&#9;local SetCache = {}
&#9;
&#9;local userCategoryButtons = nil
&#9;
&#9;local buttonWidth = 64
&#9;local buttonHeight = buttonWidth
&#9;
&#9;local SmallThumbnailUrl = nil
&#9;local LargeThumbnailUrl = nil
&#9;local BaseUrl = game:GetService(&quot;ContentProvider&quot;).BaseUrl:lower()
&#9;
&#9;if useAssetVersionId then
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;assetversionid=&quot;
&#9;else
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;aid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;aid=&quot;
&#9;end
&#9;&#9;
&#9;local function drillDownSetZIndex(parent, index)
&#9;&#9;local children = parent:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;if children[i]:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;children[i].ZIndex = index
&#9;&#9;&#9;end
&#9;&#9;&#9;drillDownSetZIndex(children[i], index)
&#9;&#9;end
&#9;end
&#9;
&#9;-- for terrain stamping
&#9;local currTerrainDropDownFrame = nil
&#9;local terrainShapes = {&quot;Block&quot;,&quot;Vertical Ramp&quot;,&quot;Corner Wedge&quot;,&quot;Inverse Corner Wedge&quot;,&quot;Horizontal Ramp&quot;,&quot;Auto-Wedge&quot;}
&#9;local terrainShapeMap = {}
&#9;for i = 1, #terrainShapes do
&#9;&#9;terrainShapeMap[terrainShapes[i]] = i - 1
&#9;end&#9;
&#9;terrainShapeMap[terrainShapes[#terrainShapes]] = 6

&#9;local function createWaterGui()
&#9;&#9;local waterForceDirections = {&quot;NegX&quot;,&quot;X&quot;,&quot;NegY&quot;,&quot;Y&quot;,&quot;NegZ&quot;,&quot;Z&quot;}
&#9;&#9;local waterForces = {&quot;None&quot;, &quot;Small&quot;, &quot;Medium&quot;, &quot;Strong&quot;, &quot;Max&quot;}

&#9;&#9;local waterFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;waterFrame.Name = &quot;WaterFrame&quot;
&#9;&#9;waterFrame.Style = Enum.FrameStyle.RobloxSquare
&#9;&#9;waterFrame.Size = UDim2.new(0,150,0,110)
&#9;&#9;waterFrame.Visible = false

&#9;&#9;local waterForceLabel = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;waterForceLabel.Name = &quot;WaterForceLabel&quot;
&#9;&#9;waterForceLabel.BackgroundTransparency = 1
&#9;&#9;waterForceLabel.Size = UDim2.new(1,0,0,12)
&#9;&#9;waterForceLabel.Font = Enum.Font.ArialBold
&#9;&#9;waterForceLabel.FontSize = Enum.FontSize.Size12
&#9;&#9;waterForceLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;waterForceLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;waterForceLabel.Text = &quot;Water Force&quot;
&#9;&#9;waterForceLabel.Parent = waterFrame

&#9;&#9;local waterForceDirLabel = waterForceLabel:Clone()
&#9;&#9;waterForceDirLabel.Name = &quot;WaterForceDirectionLabel&quot;
&#9;&#9;waterForceDirLabel.Text = &quot;Water Force Direction&quot;
&#9;&#9;waterForceDirLabel.Position = UDim2.new(0,0,0,50)
&#9;&#9;waterForceDirLabel.Parent = waterFrame

&#9;&#9;local waterTypeChangedEvent = Instance.new(&quot;BindableEvent&quot;,waterFrame)
&#9;&#9;waterTypeChangedEvent.Name = &quot;WaterTypeChangedEvent&quot;

&#9;&#9;local waterForceDirectionSelectedFunc = function(newForceDirection)
&#9;&#9;&#9;waterForceDirection = newForceDirection
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end
&#9;&#9;local waterForceSelectedFunc = function(newForce)
&#9;&#9;&#9;waterForce = newForce
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end

&#9;&#9;local waterForceDirectionDropDown, forceWaterDirectionSelection = t.CreateDropDownMenu(waterForceDirections, waterForceDirectionSelectedFunc)
&#9;&#9;waterForceDirectionDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDirectionDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;forceWaterDirectionSelection(&quot;NegX&quot;)
&#9;&#9;waterForceDirectionDropDown.Parent = waterForceDirLabel

&#9;&#9;local waterForceDropDown, forceWaterForceSelection = t.CreateDropDownMenu(waterForces, waterForceSelectedFunc)
&#9;&#9;forceWaterForceSelection(&quot;None&quot;)
&#9;&#9;waterForceDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;waterForceDropDown.Parent = waterForceLabel

&#9;&#9;return waterFrame, waterTypeChangedEvent
&#9;end

&#9;-- Helper Function that contructs gui elements
&#9;local function createSetGui()
&#9;
&#9;&#9;local setGui = Instance.new(&quot;ScreenGui&quot;)
&#9;&#9;setGui.Name = &quot;SetGui&quot;
&#9;&#9;
&#9;&#9;local setPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;setPanel.Name = &quot;SetPanel&quot;
&#9;&#9;setPanel.Active = true
&#9;&#9;setPanel.BackgroundTransparency = 1
&#9;&#9;if position then
&#9;&#9;&#9;setPanel.Position = position
&#9;&#9;else
&#9;&#9;&#9;setPanel.Position = UDim2.new(0.2, 29, 0.1, 24)
&#9;&#9;end
&#9;&#9;if size then
&#9;&#9;&#9;setPanel.Size = size
&#9;&#9;else
&#9;&#9;&#9;setPanel.Size = UDim2.new(0.6, -58, 0.64, 0)
&#9;&#9;end
&#9;&#9;setPanel.Style = Enum.FrameStyle.RobloxRound
&#9;&#9;setPanel.ZIndex = 6
&#9;&#9;setPanel.Parent = setGui
&#9;&#9;
&#9;&#9;&#9;-- Children of SetPanel
&#9;&#9;&#9;local itemPreview = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;itemPreview.Name = &quot;ItemPreview&quot;
&#9;&#9;&#9;itemPreview.BackgroundTransparency = 1
&#9;&#9;&#9;itemPreview.Position = UDim2.new(0.8,5,0.085,0)
&#9;&#9;&#9;itemPreview.Size = UDim2.new(0.21,0,0.9,0)
&#9;&#9;&#9;itemPreview.ZIndex = 6
&#9;&#9;&#9;itemPreview.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of ItemPreview
&#9;&#9;&#9;&#9;local textPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;textPanel.Name = &quot;TextPanel&quot;
&#9;&#9;&#9;&#9;textPanel.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;textPanel.Position = UDim2.new(0,0,0.45,0)
&#9;&#9;&#9;&#9;textPanel.Size = UDim2.new(1,0,0.55,0)
&#9;&#9;&#9;&#9;textPanel.ZIndex = 6
&#9;&#9;&#9;&#9;textPanel.Parent = itemPreview
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- Children of TextPanel
&#9;&#9;&#9;&#9;&#9;local rolloverText = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;&#9;rolloverText.Name = &quot;RolloverText&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;rolloverText.Size = UDim2.new(1,0,0,48)
&#9;&#9;&#9;&#9;&#9;rolloverText.ZIndex = 6
&#9;&#9;&#9;&#9;&#9;rolloverText.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;rolloverText.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;&#9;rolloverText.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;&#9;rolloverText.TextWrap = true
&#9;&#9;&#9;&#9;&#9;rolloverText.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;&#9;rolloverText.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;&#9;rolloverText.Parent = textPanel
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local largePreview = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;largePreview.Name = &quot;LargePreview&quot;
&#9;&#9;&#9;&#9;largePreview.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;largePreview.Image = &quot;&quot;
&#9;&#9;&#9;&#9;largePreview.Size = UDim2.new(1,0,0,170)
&#9;&#9;&#9;&#9;largePreview.ZIndex = 6
&#9;&#9;&#9;&#9;largePreview.Parent = itemPreview
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;local sets = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;sets.Name = &quot;Sets&quot;
&#9;&#9;&#9;sets.BackgroundTransparency = 1
&#9;&#9;&#9;sets.Position = UDim2.new(0,0,0,5)
&#9;&#9;&#9;sets.Size = UDim2.new(0.23,0,1,-5)
&#9;&#9;&#9;sets.ZIndex = 6
&#9;&#9;&#9;sets.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Sets
&#9;&#9;&#9;&#9;local line = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;line.Name = &quot;Line&quot;
&#9;&#9;&#9;&#9;line.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;line.BackgroundTransparency = 0.7
&#9;&#9;&#9;&#9;line.BorderSizePixel = 0
&#9;&#9;&#9;&#9;line.Position = UDim2.new(1,-3,0.06,0)
&#9;&#9;&#9;&#9;line.Size = UDim2.new(0,3,0.9,0)
&#9;&#9;&#9;&#9;line.ZIndex = 6
&#9;&#9;&#9;&#9;line.Parent = sets
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsLists, controlFrame = t.CreateTrueScrollingFrame()
&#9;&#9;&#9;&#9;setsLists.Size = UDim2.new(1,-6,0.94,0)
&#9;&#9;&#9;&#9;setsLists.Position = UDim2.new(0,0,0.06,0)
&#9;&#9;&#9;&#9;setsLists.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsLists.Name = &quot;SetsLists&quot;
&#9;&#9;&#9;&#9;setsLists.ZIndex = 6
&#9;&#9;&#9;&#9;setsLists.Parent = sets
&#9;&#9;&#9;&#9;drillDownSetZIndex(controlFrame, 7)
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsHeader = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;setsHeader.Name = &quot;SetsHeader&quot;
&#9;&#9;&#9;&#9;setsHeader.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsHeader.Size = UDim2.new(0,47,0,24)
&#9;&#9;&#9;&#9;setsHeader.ZIndex = 6
&#9;&#9;&#9;&#9;setsHeader.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;setsHeader.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;setsHeader.Text = &quot;Sets&quot;
&#9;&#9;&#9;&#9;setsHeader.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setsHeader.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;setsHeader.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;setsHeader.Parent = sets
&#9;&#9;&#9;
&#9;&#9;&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;&#9;&#9;cancelButton.Position = UDim2.new(1,-32,0,-2)
&#9;&#9;&#9;cancelButton.Size = UDim2.new(0,34,0,34)
&#9;&#9;&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;&#9;cancelButton.ZIndex = 6
&#9;&#9;&#9;cancelButton.Text = &quot;&quot;
&#9;&#9;&#9;cancelButton.Modal = true
&#9;&#9;&#9;cancelButton.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Cancel Button
&#9;&#9;&#9;&#9;local cancelImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;cancelImage.Name = &quot;CancelImage&quot;
&#9;&#9;&#9;&#9;cancelImage.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;cancelImage.Image = &quot;http://www.roblox.com/asset/?id=54135717&quot;
&#9;&#9;&#9;&#9;cancelImage.Position = UDim2.new(0,-2,0,-2)
&#9;&#9;&#9;&#9;cancelImage.Size = UDim2.new(0,16,0,16)
&#9;&#9;&#9;&#9;cancelImage.ZIndex = 6
&#9;&#9;&#9;&#9;cancelImage.Parent = cancelButton
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;return setGui
&#9;end
&#9;
&#9;local function createSetButton(text)
&#9;&#9;local setButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;
&#9;&#9;if text then setButton.Text = text
&#9;&#9;else setButton.Text = &quot;&quot; end
&#9;&#9;
&#9;&#9;setButton.AutoButtonColor = false
&#9;&#9;setButton.BackgroundTransparency = 1
&#9;&#9;setButton.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.BorderSizePixel = 0
&#9;&#9;setButton.Size = UDim2.new(1,-5,0,18)
&#9;&#9;setButton.ZIndex = 6
&#9;&#9;setButton.Visible = false
&#9;&#9;setButton.Font = Enum.Font.Arial
&#9;&#9;setButton.FontSize = Enum.FontSize.Size18
&#9;&#9;setButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;
&#9;&#9;return setButton
&#9;end
&#9;
&#9;local function buildSetButton(name, setId, setImageId, i,  count)
&#9;&#9;local button = createSetButton(name)
&#9;&#9;button.Text = name
&#9;&#9;button.Name = &quot;SetButton&quot;
&#9;&#9;button.Visible = true
&#9;&#9;
&#9;&#9;local setValue = Instance.new(&quot;IntValue&quot;)
&#9;&#9;setValue.Name = &quot;SetId&quot;
&#9;&#9;setValue.Value = setId
&#9;&#9;setValue.Parent = button

&#9;&#9;local setName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;setName.Name = &quot;SetName&quot;
&#9;&#9;setName.Value = name
&#9;&#9;setName.Parent = button

&#9;&#9;return button
&#9;end
&#9;
&#9;local function processCategory(sets)
&#9;&#9;local setButtons = {}
&#9;&#9;local numSkipped = 0
&#9;&#9;for i = 1, #sets do
&#9;&#9;&#9;if not showAdminCategories and sets[i].Name == &quot;Beta&quot; then
&#9;&#9;&#9;&#9;numSkipped = numSkipped + 1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;setButtons[i - numSkipped] = buildSetButton(sets[i].Name, sets[i].CategoryId, sets[i].ImageAssetId, i - numSkipped, #sets)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return setButtons
&#9;end
&#9;
&#9;local function handleResize()
&#9;&#9;wait() -- neccessary to insure heartbeat happened
&#9;&#9;
&#9;&#9;local itemPreview = setGui.SetPanel.ItemPreview
&#9;&#9;
&#9;&#9;itemPreview.LargePreview.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.X)
&#9;&#9;itemPreview.LargePreview.Position = UDim2.new(0.5,-itemPreview.LargePreview.AbsoluteSize.X/2,0,0)
&#9;&#9;itemPreview.TextPanel.Position = UDim2.new(0,0,0,itemPreview.LargePreview.AbsoluteSize.Y)
&#9;&#9;itemPreview.TextPanel.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.Y - itemPreview.LargePreview.AbsoluteSize.Y)
&#9;end
&#9;
&#9;local function makeInsertAssetButton()
&#9;&#9;local insertAssetButtonExample = Instance.new(&quot;Frame&quot;)
&#9;&#9;insertAssetButtonExample.Name = &quot;InsertAssetButtonExample&quot;
&#9;&#9;insertAssetButtonExample.Position = UDim2.new(0,128,0,64)
&#9;&#9;insertAssetButtonExample.Size = UDim2.new(0,64,0,64)
&#9;&#9;insertAssetButtonExample.BackgroundTransparency = 1
&#9;&#9;insertAssetButtonExample.ZIndex = 6
&#9;&#9;insertAssetButtonExample.Visible = false

&#9;&#9;local assetId = Instance.new(&quot;IntValue&quot;)
&#9;&#9;assetId.Name = &quot;AssetId&quot;
&#9;&#9;assetId.Value = 0
&#9;&#9;assetId.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;local assetName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;assetName.Name = &quot;AssetName&quot;
&#9;&#9;assetName.Value = &quot;&quot;
&#9;&#9;assetName.Parent = insertAssetButtonExample

&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot;
&#9;&#9;button.Text = &quot;&quot;
&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;button.Position = UDim2.new(0.025,0,0.025,0)
&#9;&#9;button.Size = UDim2.new(0.95,0,0.95,0)
&#9;&#9;button.ZIndex = 6
&#9;&#9;button.Parent = insertAssetButtonExample

&#9;&#9;local buttonImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;buttonImage.Name = &quot;ButtonImage&quot;
&#9;&#9;buttonImage.Image = &quot;&quot;
&#9;&#9;buttonImage.Position = UDim2.new(0,-7,0,-7)
&#9;&#9;buttonImage.Size = UDim2.new(1,14,1,14)
&#9;&#9;buttonImage.BackgroundTransparency = 1
&#9;&#9;buttonImage.ZIndex = 7
&#9;&#9;buttonImage.Parent = button

&#9;&#9;local configIcon = buttonImage:clone()
&#9;&#9;configIcon.Name = &quot;ConfigIcon&quot;
&#9;&#9;configIcon.Visible = false
&#9;&#9;configIcon.Position = UDim2.new(1,-23,1,-24)
&#9;&#9;configIcon.Size = UDim2.new(0,16,0,16)
&#9;&#9;configIcon.Image = &quot;&quot;
&#9;&#9;configIcon.ZIndex = 6
&#9;&#9;configIcon.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;return insertAssetButtonExample
&#9;end
&#9;
&#9;local function showLargePreview(insertButton)
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetId&quot;) then
&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(LargeThumbnailUrl .. tostring(insertButton.AssetId.Value))
&#9;&#9;&#9;&#9;setGui.SetPanel.ItemPreview.LargePreview.Image = LargeThumbnailUrl .. tostring(insertButton.AssetId.Value)
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetName&quot;) then
&#9;&#9;&#9;setGui.SetPanel.ItemPreview.TextPanel.RolloverText.Text = insertButton.AssetName.Value
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectTerrainShape(shape)
&#9;&#9;if currTerrainDropDownFrame then
&#9;&#9;&#9;objectSelected(tostring(currTerrainDropDownFrame.AssetName.Value), tonumber(currTerrainDropDownFrame.AssetId.Value), shape)
&#9;&#9;end
&#9;end
&#9;
&#9;local function createTerrainTypeButton(name, parent)
&#9;&#9;local dropDownTextButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;dropDownTextButton.Name = name .. &quot;Button&quot;
&#9;&#9;dropDownTextButton.Font = Enum.Font.ArialBold
&#9;&#9;dropDownTextButton.FontSize = Enum.FontSize.Size14
&#9;&#9;dropDownTextButton.BorderSizePixel = 0
&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;dropDownTextButton.Text = name
&#9;&#9;dropDownTextButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;dropDownTextButton.ZIndex = parent.ZIndex + 1
&#9;&#9;dropDownTextButton.Size = UDim2.new(0,parent.Size.X.Offset - 2,0,16)
&#9;&#9;dropDownTextButton.Position = UDim2.new(0,1,0,0)

&#9;&#9;dropDownTextButton.MouseEnter:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 0
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(0,0,0)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseLeave:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;if dropDownTextButton.Parent and dropDownTextButton.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;dropDownTextButton.Parent.Visible = false
&#9;&#9;&#9;end
&#9;&#9;&#9;selectTerrainShape(terrainShapeMap[dropDownTextButton.Text])
&#9;&#9;end)

&#9;&#9;return dropDownTextButton
&#9;end
&#9;
&#9;local function createTerrainDropDownMenu(zIndex)
&#9;&#9;local dropDown = Instance.new(&quot;Frame&quot;)
&#9;&#9;dropDown.Name = &quot;TerrainDropDown&quot;
&#9;&#9;dropDown.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;dropDown.BorderColor3 = Color3.new(1,0,0)
&#9;&#9;dropDown.Size = UDim2.new(0,200,0,0)
&#9;&#9;dropDown.Visible = false
&#9;&#9;dropDown.ZIndex = zIndex
&#9;&#9;dropDown.Parent = setGui

&#9;&#9;for i = 1, #terrainShapes do
&#9;&#9;&#9;local shapeButton = createTerrainTypeButton(terrainShapes[i],dropDown)
&#9;&#9;&#9;shapeButton.Position = UDim2.new(0,1,0,(i - 1) * (shapeButton.Size.Y.Offset))
&#9;&#9;&#9;shapeButton.Parent = dropDown
&#9;&#9;&#9;dropDown.Size = UDim2.new(0,200,0,dropDown.Size.Y.Offset + (shapeButton.Size.Y.Offset))
&#9;&#9;end

&#9;&#9;dropDown.MouseLeave:connect(function()
&#9;&#9;&#9;dropDown.Visible = false
&#9;&#9;end)
&#9;end

&#9;
&#9;local function createDropDownMenuButton(parent)
&#9;&#9;local dropDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;dropDownButton.Name = &quot;DropDownButton&quot;
&#9;&#9;dropDownButton.Image = &quot;http://www.roblox.com/asset/?id=67581509&quot;
&#9;&#9;dropDownButton.BackgroundTransparency = 1
&#9;&#9;dropDownButton.Size = UDim2.new(0,16,0,16)
&#9;&#9;dropDownButton.Position = UDim2.new(1,-24,0,6)
&#9;&#9;dropDownButton.ZIndex = parent.ZIndex + 2
&#9;&#9;dropDownButton.Parent = parent
&#9;&#9;
&#9;&#9;if not setGui:FindFirstChild(&quot;TerrainDropDown&quot;) then
&#9;&#9;&#9;createTerrainDropDownMenu(8)
&#9;&#9;end
&#9;&#9;
&#9;&#9;dropDownButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;setGui.TerrainDropDown.Visible = true
&#9;&#9;&#9;setGui.TerrainDropDown.Position = UDim2.new(0,parent.AbsolutePosition.X,0,parent.AbsolutePosition.Y)
&#9;&#9;&#9;currTerrainDropDownFrame = parent
&#9;&#9;end)
&#9;end
&#9;
&#9;local function buildInsertButton()
&#9;&#9;local insertButton = makeInsertAssetButton()
&#9;&#9;insertButton.Name = &quot;InsertAssetButton&quot;
&#9;&#9;insertButton.Visible = true

&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;createDropDownMenuButton(insertButton)
&#9;&#9;end

&#9;&#9;local lastEnter = nil
&#9;&#9;local mouseEnterCon = insertButton.MouseEnter:connect(function()
&#9;&#9;&#9;lastEnter = insertButton
&#9;&#9;&#9;delay(0.1,function()
&#9;&#9;&#9;&#9;if lastEnter == insertButton then
&#9;&#9;&#9;&#9;&#9;showLargePreview(insertButton)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end)
&#9;&#9;return insertButton, mouseEnterCon
&#9;end
&#9;
&#9;local function realignButtonGrid(columns)
&#9;&#9;local x = 0
&#9;&#9;local y = 0 
&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;insertButtons[i].Position = UDim2.new(0, buttonWidth * x, 0, buttonHeight * y)
&#9;&#9;&#9;x = x + 1
&#9;&#9;&#9;if x &gt;= columns then
&#9;&#9;&#9;&#9;x = 0
&#9;&#9;&#9;&#9;y = y + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function setInsertButtonImageBehavior(insertFrame, visible, name, assetId)
&#9;&#9;if visible then
&#9;&#9;&#9;insertFrame.AssetName.Value = name
&#9;&#9;&#9;insertFrame.AssetId.Value = assetId
&#9;&#9;&#9;local newImageUrl = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;if newImageUrl ~= insertFrame.Button.ButtonImage.Image then
&#9;&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(SmallThumbnailUrl  .. assetId)
&#9;&#9;&#9;&#9;&#9;if insertFrame:findFirstChild(&quot;Button&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;insertFrame.Button.ButtonImage.Image = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;table.insert(insertButtonCons,
&#9;&#9;&#9;&#9;insertFrame.Button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;-- special case for water, show water selection gui
&#9;&#9;&#9;&#9;&#9;local isWaterSelected = (name == &quot;Water&quot;) and (Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot;)
&#9;&#9;&#9;&#9;&#9;waterGui.Visible = isWaterSelected
&#9;&#9;&#9;&#9;&#9;if isWaterSelected then
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId), nil)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId))
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;)
&#9;&#9;&#9;insertFrame.Visible = true
&#9;&#9;else
&#9;&#9;&#9;insertFrame.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local function loadSectionOfItems(setGui, rows, columns)
&#9;&#9;local pageSize = rows * columns

&#9;&#9;if arrayPosition &gt; #contents then return end

&#9;&#9;local origArrayPos = arrayPosition

&#9;&#9;local yCopy = 0
&#9;&#9;for i = 1, pageSize + 1 do 
&#9;&#9;&#9;if arrayPosition &gt;= #contents + 1 then
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end

&#9;&#9;&#9;local buttonCon
&#9;&#9;&#9;insertButtons[arrayPosition], buttonCon = buildInsertButton()
&#9;&#9;&#9;table.insert(insertButtonCons,buttonCon)
&#9;&#9;&#9;insertButtons[arrayPosition].Parent = setGui.SetPanel.ItemsFrame
&#9;&#9;&#9;arrayPosition = arrayPosition + 1
&#9;&#9;end
&#9;&#9;realignButtonGrid(columns)

&#9;&#9;local indexCopy = origArrayPos
&#9;&#9;for index = origArrayPos, arrayPosition do
&#9;&#9;&#9;if insertButtons[index] then
&#9;&#9;&#9;&#9;if contents[index] then

&#9;&#9;&#9;&#9;&#9;-- we don&apos;t want water to have a drop down button
&#9;&#9;&#9;&#9;&#9;if contents[index].Name == &quot;Water&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;insertButtons[index]:FindFirstChild(&quot;DropDownButton&quot;,true):Destroy()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;local assetId
&#9;&#9;&#9;&#9;&#9;if useAssetVersionId then
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetVersionId
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;setInsertButtonImageBehavior(insertButtons[index], true, contents[index].Name, assetId)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;&#9;indexCopy = index
&#9;&#9;end
&#9;end
&#9;
&#9;local function setSetIndex()
&#9;&#9;Data.Category[Data.CurrentCategory].Index = 0

&#9;&#9;rows = 7
&#9;&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;&#9;contents = Data.Category[Data.CurrentCategory].Contents
&#9;&#9;if contents then
&#9;&#9;&#9;-- remove our buttons and their connections
&#9;&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;&#9;insertButtons[i]:remove()
&#9;&#9;&#9;end
&#9;&#9;&#9;for i = 1, #insertButtonCons do
&#9;&#9;&#9;&#9;if insertButtonCons[i] then insertButtonCons[i]:disconnect() end
&#9;&#9;&#9;end
&#9;&#9;&#9;insertButtonCons = {}
&#9;&#9;&#9;insertButtons = {}

&#9;&#9;&#9;arrayPosition = 1
&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectSet(button, setName, setId, setIndex)
&#9;&#9;if button and Data.Category[Data.CurrentCategory] ~= nil then
&#9;&#9;&#9;if button ~= Data.Category[Data.CurrentCategory].Button then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = button

&#9;&#9;&#9;&#9;if SetCache[setId] == nil then
&#9;&#9;&#9;&#9;&#9;SetCache[setId] = game:GetService(&quot;InsertService&quot;):GetCollection(setId)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Contents = SetCache[setId]

&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetName = setName
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetId = setId
&#9;&#9;&#9;end
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategoryPage(buttons, page)
&#9;&#9;if buttons ~= Data.CurrentCategory then
&#9;&#9;&#9;if Data.CurrentCategory then
&#9;&#9;&#9;&#9;for key, button in pairs(Data.CurrentCategory) do
&#9;&#9;&#9;&#9;&#9;button.Visible = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;Data.CurrentCategory = buttons
&#9;&#9;&#9;if Data.Category[Data.CurrentCategory] == nil then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory] = {}
&#9;&#9;&#9;&#9;if #buttons &gt; 0 then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[1], buttons[1].SetName.Value, buttons[1].SetId.Value, 0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = nil
&#9;&#9;&#9;&#9;selectSet(Data.Category[Data.CurrentCategory].ButtonFrame, Data.Category[Data.CurrentCategory].SetName, Data.Category[Data.CurrentCategory].SetId, Data.Category[Data.CurrentCategory].Index)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategory(category)
&#9;&#9;selectCategoryPage(category, 0)
&#9;end
&#9;
&#9;local function resetAllSetButtonSelection()
&#9;&#9;local setButtons = setGui.SetPanel.Sets.SetsLists:GetChildren()
&#9;&#9;for i = 1, #setButtons do
&#9;&#9;&#9;if setButtons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;setButtons[i].Selected = false
&#9;&#9;&#9;&#9;setButtons[i].BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setButtons[i].TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setButtons[i].BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function populateSetsFrame()
&#9;&#9;local currRow = 0
&#9;&#9;for i = 1, #userCategoryButtons do
&#9;&#9;&#9;local button = userCategoryButtons[i]
&#9;&#9;&#9;button.Visible = true
&#9;&#9;&#9;button.Position = UDim2.new(0,5,0,currRow * button.Size.Y.Offset)
&#9;&#9;&#9;button.Parent = setGui.SetPanel.Sets.SetsLists
&#9;&#9;&#9;
&#9;&#9;&#9;if i == 1 then -- we will have this selected by default, so show it
&#9;&#9;&#9;&#9;button.Selected = true
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;end

&#9;&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;resetAllSetButtonSelection()
&#9;&#9;&#9;&#9;button.Selected = not button.Selected
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;selectSet(button, button.Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;end)

&#9;&#9;&#9;currRow = currRow + 1
&#9;&#9;end

&#9;&#9;local buttons =  setGui.SetPanel.Sets.SetsLists:GetChildren()

&#9;&#9;-- set first category as loaded for default
&#9;&#9;if buttons then
&#9;&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;&#9;if buttons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[i], buttons[i].Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;&#9;&#9;selectCategory(userCategoryButtons)
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;setGui = createSetGui()
&#9;waterGui, waterTypeChangedEvent = createWaterGui()
&#9;waterGui.Position = UDim2.new(0,55,0,0)
&#9;waterGui.Parent = setGui
&#9;setGui.Changed:connect(function(prop) -- this resizes the preview image to always be the right size
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;handleResize()
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end)
&#9;
&#9;local scrollFrame, controlFrame = t.CreateTrueScrollingFrame()
&#9;scrollFrame.Size = UDim2.new(0.54,0,0.85,0)
&#9;scrollFrame.Position = UDim2.new(0.24,0,0.085,0)
&#9;scrollFrame.Name = &quot;ItemsFrame&quot;
&#9;scrollFrame.ZIndex = 6
&#9;scrollFrame.Parent = setGui.SetPanel
&#9;scrollFrame.BackgroundTransparency = 1

&#9;drillDownSetZIndex(controlFrame,7)

&#9;controlFrame.Parent = setGui.SetPanel
&#9;controlFrame.Position = UDim2.new(0.76, 5, 0, 0)

&#9;local debounce = false
&#9;controlFrame.ScrollBottom.Changed:connect(function(prop)
&#9;&#9;if controlFrame.ScrollBottom.Value == true then
&#9;&#9;&#9;if debounce then return end
&#9;&#9;&#9;debounce = true
&#9;&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;&#9;debounce = false
&#9;&#9;end
&#9;end)

&#9;local userData = {}
&#9;for id = 1, #userIdsForSets do
&#9;&#9;local newUserData = game:GetService(&quot;InsertService&quot;):GetUserSets(userIdsForSets[id])
&#9;&#9;if newUserData and #newUserData &gt; 2 then
&#9;&#9;&#9;-- start at #3 to skip over My Decals and My Models for each account
&#9;&#9;&#9;for category = 3, #newUserData do
&#9;&#9;&#9;&#9;if newUserData[category].Name == &quot;High Scalability&quot; then -- we want high scalability parts to show first
&#9;&#9;&#9;&#9;&#9;table.insert(userData,1,newUserData[category])
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;table.insert(userData, newUserData[category])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;
&#9;end
&#9;if userData then
&#9;&#9;userCategoryButtons = processCategory(userData)
&#9;end

&#9;rows = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;populateSetsFrame()

&#9;insertPanelCloseCon = setGui.SetPanel.CancelButton.MouseButton1Click:connect(function()
&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;if dialogClosed then dialogClosed() end
&#9;end)
&#9;
&#9;local setVisibilityFunction = function(visible)
&#9;&#9;if visible then
&#9;&#9;&#9;setGui.SetPanel.Visible = true
&#9;&#9;else
&#9;&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local getVisibilityFunction = function()
&#9;&#9;if setGui then
&#9;&#9;&#9;if setGui:FindFirstChild(&quot;SetPanel&quot;) then
&#9;&#9;&#9;&#9;return setGui.SetPanel.Visible
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;return false
&#9;end
&#9;
&#9;return setGui, setVisibilityFunction, getVisibilityFunction, waterTypeChangedEvent
end

t.CreateTerrainMaterialSelector = function(size,position)
&#9;local terrainMaterialSelectionChanged = Instance.new(&quot;BindableEvent&quot;)
&#9;terrainMaterialSelectionChanged.Name = &quot;TerrainMaterialSelectionChanged&quot;

&#9;local selectedButton = nil

&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TerrainMaterialSelector&quot;
&#9;if size then
&#9;&#9;frame.Size = size
&#9;else
&#9;&#9;frame.Size = UDim2.new(0, 245, 0, 230)
&#9;end
&#9;if position then
&#9;&#9;frame.Position = position
&#9;end
&#9;frame.BorderSizePixel = 0
&#9;frame.BackgroundColor3 = Color3.new(0,0,0)
&#9;frame.Active = true

&#9;terrainMaterialSelectionChanged.Parent = frame

&#9;local waterEnabled = true -- todo: turn this on when water is ready

&#9;local materialToImageMap = {}
&#9;local materialNames = {&quot;Grass&quot;, &quot;Sand&quot;, &quot;Brick&quot;, &quot;Granite&quot;, &quot;Asphalt&quot;, &quot;Iron&quot;, &quot;Aluminum&quot;, &quot;Gold&quot;, &quot;Plank&quot;, &quot;Log&quot;, &quot;Gravel&quot;, &quot;Cinder Block&quot;, &quot;Stone Wall&quot;, &quot;Concrete&quot;, &quot;Plastic (red)&quot;, &quot;Plastic (blue)&quot;}
&#9;if waterEnabled then
&#9;&#9;table.insert(materialNames,&quot;Water&quot;)
&#9;end
&#9;local currentMaterial = 1

&#9;function getEnumFromName(choice)
&#9;&#9;if choice == &quot;Grass&quot; then return 1 end
&#9;&#9;if choice == &quot;Sand&quot; then return 2 end 
&#9;&#9;if choice == &quot;Erase&quot; then return 0 end
&#9;&#9;if choice == &quot;Brick&quot; then return 3 end
&#9;&#9;if choice == &quot;Granite&quot; then return 4 end
&#9;&#9;if choice == &quot;Asphalt&quot; then return 5 end
&#9;&#9;if choice == &quot;Iron&quot; then return 6 end
&#9;&#9;if choice == &quot;Aluminum&quot; then return 7 end
&#9;&#9;if choice == &quot;Gold&quot; then return 8 end
&#9;&#9;if choice == &quot;Plank&quot; then return 9 end
&#9;&#9;if choice == &quot;Log&quot; then return 10 end
&#9;&#9;if choice == &quot;Gravel&quot; then return 11 end
&#9;&#9;if choice == &quot;Cinder Block&quot; then return 12 end
&#9;&#9;if choice == &quot;Stone Wall&quot; then return 13 end
&#9;&#9;if choice == &quot;Concrete&quot; then return 14 end
&#9;&#9;if choice == &quot;Plastic (red)&quot; then return 15 end
&#9;&#9;if choice == &quot;Plastic (blue)&quot; then return 16 end
&#9;&#9;if choice == &quot;Water&quot; then return 17 end
&#9;end

&#9;function getNameFromEnum(choice)
&#9;&#9;if choice == Enum.CellMaterial.Grass or choice == 1 then return &quot;Grass&quot;end
&#9;&#9;if choice == Enum.CellMaterial.Sand or choice == 2 then return &quot;Sand&quot; end 
&#9;&#9;if choice == Enum.CellMaterial.Empty or choice == 0 then return &quot;Erase&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Brick or choice == 3 then return &quot;Brick&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Granite or choice == 4 then return &quot;Granite&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Asphalt or choice == 5 then return &quot;Asphalt&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Iron or choice == 6 then return &quot;Iron&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Aluminum or choice == 7 then return &quot;Aluminum&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gold or choice == 8 then return &quot;Gold&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodPlank or choice == 9 then return &quot;Plank&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodLog or choice == 10 then return &quot;Log&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gravel or choice == 11 then return &quot;Gravel&quot; end
&#9;&#9;if choice == Enum.CellMaterial.CinderBlock or choice == 12 then return &quot;Cinder Block&quot; end
&#9;&#9;if choice == Enum.CellMaterial.MossyStone or choice == 13 then return &quot;Stone Wall&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Cement or choice == 14 then return &quot;Concrete&quot; end
&#9;&#9;if choice == Enum.CellMaterial.RedPlastic or choice == 15 then return &quot;Plastic (red)&quot; end
&#9;&#9;if choice == Enum.CellMaterial.BluePlastic or choice == 16 then return &quot;Plastic (blue)&quot; end

&#9;&#9;if waterEnabled then
&#9;&#9;&#9;if choice == Enum.CellMaterial.Water or choice == 17 then return &quot;Water&quot; end
&#9;&#9;end
&#9;end


&#9;local function updateMaterialChoice(choice)
&#9;&#9;currentMaterial = getEnumFromName(choice)
&#9;&#9;terrainMaterialSelectionChanged:Fire(currentMaterial)
&#9;end

&#9;-- we so need a better way to do this
&#9;for i,v in pairs(materialNames) do
&#9;&#9;materialToImageMap[v] = {}
&#9;&#9;if v == &quot;Grass&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=56563112&quot;
&#9;&#9;elseif v == &quot;Sand&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=62356652&quot;
&#9;&#9;elseif v == &quot;Brick&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=65961537&quot;
&#9;&#9;elseif v == &quot;Granite&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532153&quot;
&#9;&#9;elseif v == &quot;Asphalt&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532038&quot;
&#9;&#9;elseif v == &quot;Iron&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532093&quot;
&#9;&#9;elseif v == &quot;Aluminum&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531995&quot;
&#9;&#9;elseif v == &quot;Gold&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532118&quot;
&#9;&#9;elseif v == &quot;Plastic (red)&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531848&quot;
&#9;&#9;elseif v == &quot;Plastic (blue)&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531924&quot;
&#9;&#9;elseif v == &quot;Plank&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532015&quot;
&#9;&#9;elseif v == &quot;Log&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532051&quot;
&#9;&#9;elseif v == &quot;Gravel&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532206&quot;
&#9;&#9;elseif v == &quot;Cinder Block&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532103&quot;
&#9;&#9;elseif v == &quot;Stone Wall&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531804&quot;
&#9;&#9;elseif v == &quot;Concrete&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532059&quot;
&#9;&#9;elseif v == &quot;Water&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=81407474&quot;
&#9;&#9;else materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=66887593&quot; -- fill in the rest here!!
&#9;&#9;end
&#9;end

&#9;local scrollFrame, scrollUp, scrollDown, recalculateScroll = t.CreateScrollingFrame(nil,&quot;grid&quot;)
&#9;scrollFrame.Size = UDim2.new(0.85,0,1,0)
&#9;scrollFrame.Position = UDim2.new(0,0,0,0)
&#9;scrollFrame.Parent = frame

&#9;scrollUp.Parent = frame
&#9;scrollUp.Visible = true
&#9;scrollUp.Position = UDim2.new(1,-19,0,0)

&#9;scrollDown.Parent = frame
&#9;scrollDown.Visible = true
&#9;scrollDown.Position = UDim2.new(1,-19,1,-17)

&#9;local function goToNewMaterial(buttonWrap, materialName)
&#9;&#9;updateMaterialChoice(materialName)
&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;selectedButton.BackgroundTransparency = 1
&#9;&#9;selectedButton = buttonWrap
&#9;end

&#9;local function createMaterialButton(name)&#9;
&#9;&#9;local buttonWrap = Instance.new(&quot;TextButton&quot;)
&#9;&#9;buttonWrap.Text = &quot;&quot;
&#9;&#9;buttonWrap.Size = UDim2.new(0,32,0,32)
&#9;&#9;buttonWrap.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;buttonWrap.BorderSizePixel = 0
&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;buttonWrap.AutoButtonColor = false
&#9;&#9;buttonWrap.Name = tostring(name)
&#9;&#9;
&#9;&#9;local imageButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;imageButton.AutoButtonColor = false
&#9;&#9;imageButton.BackgroundTransparency = 1
&#9;&#9;imageButton.Size = UDim2.new(0,30,0,30)
&#9;&#9;imageButton.Position = UDim2.new(0,1,0,1)
&#9;&#9;imageButton.Name = tostring(name)
&#9;&#9;imageButton.Parent = buttonWrap
&#9;&#9;imageButton.Image = materialToImageMap[name].Regular

&#9;&#9;local enumType = Instance.new(&quot;NumberValue&quot;)
&#9;&#9;enumType.Name = &quot;EnumType&quot;
&#9;&#9;enumType.Parent = buttonWrap
&#9;&#9;enumType.Value = 0
&#9;&#9;
&#9;&#9;imageButton.MouseEnter:connect(function()
&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;imageButton.MouseLeave:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;imageButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;goToNewMaterial(buttonWrap, tostring(name))
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;
&#9;&#9;return buttonWrap 
&#9;end

&#9;for i = 1, #materialNames do
&#9;&#9;local imageButton = createMaterialButton(materialNames[i])
&#9;&#9;
&#9;&#9;if materialNames[i] == &quot;Grass&quot; then -- always start with grass as the default
&#9;&#9;&#9;selectedButton = imageButton
&#9;&#9;&#9;imageButton.BackgroundTransparency = 0
&#9;&#9;end
&#9;&#9;
&#9;&#9;imageButton.Parent = scrollFrame
&#9;end

&#9;local forceTerrainMaterialSelection = function(newMaterialType)
&#9;&#9;if not newMaterialType then return end
&#9;&#9;if currentMaterial == newMaterialType then return end

&#9;&#9;local matName = getNameFromEnum(newMaterialType)
&#9;&#9;local buttons = scrollFrame:GetChildren()
&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (blue)&quot; and matName == &quot;Plastic (blue)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (red)&quot; and matName == &quot;Plastic (red)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if string.find(buttons[i].Name, matName) then
&#9;&#9;&#9;&#9;goToNewMaterial(buttons[i],matName)
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(function ( prop )
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;recalculateScroll()
&#9;&#9;end
&#9;end)

&#9;recalculateScroll()
&#9;return frame, terrainMaterialSelectionChanged, forceTerrainMaterialSelection
end

t.CreateLoadingFrame = function(name,size,position)
&#9;game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=35238053&quot;)

&#9;local loadingFrame = Instance.new(&quot;Frame&quot;)
&#9;loadingFrame.Name = &quot;LoadingFrame&quot;
&#9;loadingFrame.Style = Enum.FrameStyle.RobloxRound

&#9;if size then loadingFrame.Size = size
&#9;else loadingFrame.Size = UDim2.new(0,300,0,160) end
&#9;if position then loadingFrame.Position = position 
&#9;else loadingFrame.Position = UDim2.new(0.5, -150, 0.5,-80) end

&#9;local loadingBar = Instance.new(&quot;Frame&quot;)
&#9;loadingBar.Name = &quot;LoadingBar&quot;
&#9;loadingBar.BackgroundColor3 = Color3.new(0,0,0)
&#9;loadingBar.BorderColor3 = Color3.new(79/255,79/255,79/255)
&#9;loadingBar.Position = UDim2.new(0,0,0,41)
&#9;loadingBar.Size = UDim2.new(1,0,0,30)
&#9;loadingBar.Parent = loadingFrame

&#9;&#9;local loadingGreenBar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;loadingGreenBar.Name = &quot;LoadingGreenBar&quot;
&#9;&#9;loadingGreenBar.Image = &quot;http://www.roblox.com/asset/?id=35238053&quot;
&#9;&#9;loadingGreenBar.Position = UDim2.new(0,0,0,0)
&#9;&#9;loadingGreenBar.Size = UDim2.new(0,0,1,0)
&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;loadingGreenBar.Parent = loadingBar

&#9;&#9;local loadingPercent = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;loadingPercent.Name = &quot;LoadingPercent&quot;
&#9;&#9;loadingPercent.BackgroundTransparency = 1
&#9;&#9;loadingPercent.Position = UDim2.new(0,0,1,0)
&#9;&#9;loadingPercent.Size = UDim2.new(1,0,0,14)
&#9;&#9;loadingPercent.Font = Enum.Font.Arial
&#9;&#9;loadingPercent.Text = &quot;0%&quot;
&#9;&#9;loadingPercent.FontSize = Enum.FontSize.Size14
&#9;&#9;loadingPercent.TextColor3 = Color3.new(1,1,1)
&#9;&#9;loadingPercent.Parent = loadingBar

&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;cancelButton.Position = UDim2.new(0.5,-60,1,-40)
&#9;cancelButton.Size = UDim2.new(0,120,0,40)
&#9;cancelButton.Font = Enum.Font.Arial
&#9;cancelButton.FontSize = Enum.FontSize.Size18
&#9;cancelButton.TextColor3 = Color3.new(1,1,1)
&#9;cancelButton.Text = &quot;Cancel&quot;
&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButton
&#9;cancelButton.Parent = loadingFrame

&#9;local loadingName = Instance.new(&quot;TextLabel&quot;)
&#9;loadingName.Name = &quot;loadingName&quot;
&#9;loadingName.BackgroundTransparency = 1
&#9;loadingName.Size = UDim2.new(1,0,0,18)
&#9;loadingName.Position = UDim2.new(0,0,0,2)
&#9;loadingName.Font = Enum.Font.Arial
&#9;loadingName.Text = name
&#9;loadingName.TextColor3 = Color3.new(1,1,1)
&#9;loadingName.TextStrokeTransparency = 1
&#9;loadingName.FontSize = Enum.FontSize.Size18
&#9;loadingName.Parent = loadingFrame

&#9;local cancelButtonClicked = Instance.new(&quot;BindableEvent&quot;)
&#9;cancelButtonClicked.Name = &quot;CancelButtonClicked&quot;
&#9;cancelButtonClicked.Parent = cancelButton
&#9;cancelButton.MouseButton1Click:connect(function()
&#9;&#9;cancelButtonClicked:Fire()
&#9;end)

&#9;local updateLoadingGuiPercent = function(percent, tweenAction, tweenLength)
&#9;&#9;if percent and type(percent) ~= &quot;number&quot; then
&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent expects number as argument, got&quot;,type(percent),&quot;instead&quot;)
&#9;&#9;end

&#9;&#9;local newSize = nil
&#9;&#9;if percent &lt; 0 then
&#9;&#9;&#9;newSize = UDim2.new(0,0,1,0)
&#9;&#9;elseif percent &gt; 1 then
&#9;&#9;&#9;newSize = UDim2.new(1,0,1,0)
&#9;&#9;else
&#9;&#9;&#9;newSize = UDim2.new(percent,0,1,0)
&#9;&#9;end

&#9;&#9;if tweenAction then
&#9;&#9;&#9;if not tweenLength then
&#9;&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent is set to tween new percentage, but got no tween time length! Please pass this in as third argument&quot;)
&#9;&#9;&#9;end

&#9;&#9;&#9;if (newSize.X.Scale &gt; 0) then
&#9;&#9;&#9;&#9;loadingGreenBar.Visible = true
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function() 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (newSize.X.Scale &lt; 0) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end

&#9;&#9;else
&#9;&#9;&#9;loadingGreenBar.Size = newSize
&#9;&#9;&#9;loadingGreenBar.Visible = (newSize.X.Scale &gt; 0)
&#9;&#9;end
&#9;end

&#9;loadingGreenBar.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Size&quot; then
&#9;&#9;&#9;loadingPercent.Text = tostring( math.ceil(loadingGreenBar.Size.X.Scale * 100) ) .. &quot;%&quot;
&#9;&#9;end
&#9;end)

&#9;return loadingFrame, updateLoadingGuiPercent, cancelButtonClicked
end

t.CreatePluginFrame = function (name,size,position,scrollable,parent)
&#9;function createMenuButton(size,position,text,fontsize,name,parent)
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;,parent)
&#9;&#9;button.AutoButtonColor = false
&#9;&#9;button.Name = name
&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;button.Position = position
&#9;&#9;button.Size = size
&#9;&#9;button.Font = Enum.Font.ArialBold
&#9;&#9;button.FontSize = fontsize
&#9;&#9;button.Text =  text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.BorderSizePixel = 0
&#9;&#9;button.BackgroundColor3 = Color3.new(20/255,20/255,20/255)

&#9;&#9;button.MouseEnter:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;button.MouseLeave:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)

&#9;&#9;return button

&#9;end

&#9;local dragBar = Instance.new(&quot;Frame&quot;,parent)
&#9;dragBar.Name = tostring(name) .. &quot;DragBar&quot;
&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;dragBar.BorderColor3 = Color3.new(0,0,0)
&#9;if size then
&#9;&#9;dragBar.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,20)  + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;dragBar.Size = UDim2.new(0,183,0,20)
&#9;end
&#9;if position then
&#9;&#9;dragBar.Position = position
&#9;end
&#9;dragBar.Active = true
&#9;dragBar.Draggable = true
&#9;--dragBar.Visible = false
&#9;dragBar.MouseEnter:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(49/255,49/255,49/255)
&#9;end)
&#9;dragBar.MouseLeave:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;end)

&#9;-- plugin name label
&#9;local pluginNameLabel = Instance.new(&quot;TextLabel&quot;,dragBar)
&#9;pluginNameLabel.Name = &quot;BarNameLabel&quot;
&#9;pluginNameLabel.Text = &quot; &quot; .. tostring(name)
&#9;pluginNameLabel.TextColor3 = Color3.new(1,1,1)
&#9;pluginNameLabel.TextStrokeTransparency = 0
&#9;pluginNameLabel.Size = UDim2.new(1,0,1,0)
&#9;pluginNameLabel.Font = Enum.Font.ArialBold
&#9;pluginNameLabel.FontSize = Enum.FontSize.Size18
&#9;pluginNameLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;pluginNameLabel.BackgroundTransparency = 1

&#9;-- close button
&#9;local closeButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-16,0.5,-8),&quot;X&quot;,Enum.FontSize.Size14,&quot;CloseButton&quot;,dragBar)
&#9;local closeEvent = Instance.new(&quot;BindableEvent&quot;)
&#9;closeEvent.Name = &quot;CloseEvent&quot;
&#9;closeEvent.Parent = closeButton
&#9;closeButton.MouseButton1Click:connect(function ()
&#9;&#9;closeEvent:Fire()
&#9;&#9;closeButton.BackgroundTransparency = 1
&#9;end)

&#9;-- help button
&#9;local helpButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-51,0.5,-8),&quot;?&quot;,Enum.FontSize.Size14,&quot;HelpButton&quot;,dragBar)
&#9;local helpFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;helpFrame.Name = &quot;HelpFrame&quot;
&#9;helpFrame.BackgroundColor3 = Color3.new(0,0,0)
&#9;helpFrame.Size = UDim2.new(0,300,0,552)
&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;helpFrame.Active = true
&#9;helpFrame.BorderSizePixel = 0
&#9;helpFrame.Visible = false

&#9;helpButton.MouseButton1Click:connect(function(  )
&#9;&#9;helpFrame.Visible = not helpFrame.Visible
&#9;&#9;if helpFrame.Visible then
&#9;&#9;&#9;helpButton.Selected = true
&#9;&#9;&#9;helpButton.BackgroundTransparency = 0
&#9;&#9;&#9;local screenGui = getScreenGuiAncestor(helpFrame)
&#9;&#9;&#9;if screenGui then
&#9;&#9;&#9;&#9;if helpFrame.AbsolutePosition.X + helpFrame.AbsoluteSize.X &gt; screenGui.AbsoluteSize.X then --position on left hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(0,-5 - helpFrame.AbsoluteSize.X,0,0)
&#9;&#9;&#9;&#9;else -- position on right hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;helpButton.Selected = false
&#9;&#9;&#9;helpButton.BackgroundTransparency = 1
&#9;&#9;end
&#9;end)

&#9;local minimizeButton = createMenuButton(UDim2.new(0,16,0,17),UDim2.new(1,-34,0.5,-8),&quot;-&quot;,Enum.FontSize.Size14,&quot;MinimizeButton&quot;,dragBar)
&#9;minimizeButton.TextYAlignment = Enum.TextYAlignment.Top

&#9;local minimizeFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;minimizeFrame.Name = &quot;MinimizeFrame&quot;
&#9;minimizeFrame.BackgroundColor3 = Color3.new(73/255,73/255,73/255)
&#9;minimizeFrame.BorderColor3 = Color3.new(0,0,0)
&#9;minimizeFrame.Position = UDim2.new(0,0,1,0)
&#9;if size then
&#9;&#9;minimizeFrame.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,50) + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;minimizeFrame.Size = UDim2.new(0,183,0,50)
&#9;end
&#9;minimizeFrame.Visible = false

&#9;local minimizeBigButton = Instance.new(&quot;TextButton&quot;,minimizeFrame)
&#9;minimizeBigButton.Position = UDim2.new(0.5,-50,0.5,-20)
&#9;minimizeBigButton.Name = &quot;MinimizeButton&quot;
&#9;minimizeBigButton.Size = UDim2.new(0,100,0,40)
&#9;minimizeBigButton.Style = Enum.ButtonStyle.RobloxButton
&#9;minimizeBigButton.Font = Enum.Font.ArialBold
&#9;minimizeBigButton.FontSize = Enum.FontSize.Size18
&#9;minimizeBigButton.TextColor3 = Color3.new(1,1,1)
&#9;minimizeBigButton.Text = &quot;Show&quot;

&#9;local separatingLine = Instance.new(&quot;Frame&quot;,dragBar)
&#9;separatingLine.Name = &quot;SeparatingLine&quot;
&#9;separatingLine.BackgroundColor3 = Color3.new(115/255,115/255,115/255)
&#9;separatingLine.BorderSizePixel = 0
&#9;separatingLine.Position = UDim2.new(1,-18,0.5,-7)
&#9;separatingLine.Size = UDim2.new(0,1,0,14)

&#9;local otherSeparatingLine = separatingLine:clone()
&#9;otherSeparatingLine.Position = UDim2.new(1,-35,0.5,-7)
&#9;otherSeparatingLine.Parent = dragBar

&#9;local widgetContainer = Instance.new(&quot;Frame&quot;,dragBar)
&#9;widgetContainer.Name = &quot;WidgetContainer&quot;
&#9;widgetContainer.BackgroundTransparency = 1
&#9;widgetContainer.Position = UDim2.new(0,0,1,0)
&#9;widgetContainer.BorderColor3 = Color3.new(0,0,0)
&#9;if not scrollable then
&#9;&#9;widgetContainer.BackgroundTransparency = 0
&#9;&#9;widgetContainer.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;end

&#9;if size then
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = size
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,size.Y.Scale,size.Y.Offset)
&#9;&#9;end
&#9;else
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,163,0,400)
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,0,400)
&#9;&#9;end
&#9;end
&#9;if position then
&#9;&#9;widgetContainer.Position = position + UDim2.new(0,0,0,20)
&#9;end

&#9;local frame,control,verticalDragger = nil
&#9;if scrollable then
&#9;&#9;--frame for widgets
&#9;&#9;frame,control = t.CreateTrueScrollingFrame()
&#9;&#9;frame.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;frame.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;frame.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;frame.Active = true
&#9;&#9;frame.Parent = widgetContainer
&#9;&#9;control.Parent = dragBar
&#9;&#9;control.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;control.BorderSizePixel = 0
&#9;&#9;control.BackgroundTransparency = 0
&#9;&#9;control.Position = UDim2.new(1,-21,1,1)
&#9;&#9;if size then
&#9;&#9;&#9;control.Size = UDim2.new(0,21,size.Y.Scale,size.Y.Offset)
&#9;&#9;else
&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,400)
&#9;&#9;end
&#9;&#9;control:FindFirstChild(&quot;ScrollDownButton&quot;).Position = UDim2.new(0,0,1,-20)

&#9;&#9;local fakeLine = Instance.new(&quot;Frame&quot;,control)
&#9;&#9;fakeLine.Name = &quot;FakeLine&quot;
&#9;&#9;fakeLine.BorderSizePixel = 0
&#9;&#9;fakeLine.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;fakeLine.Size = UDim2.new(0,1,1,1)
&#9;&#9;fakeLine.Position = UDim2.new(1,0,0,0)

&#9;&#9;verticalDragger = Instance.new(&quot;TextButton&quot;,widgetContainer)
&#9;&#9;verticalDragger.ZIndex = 2
&#9;&#9;verticalDragger.AutoButtonColor = false
&#9;&#9;verticalDragger.Name = &quot;VerticalDragger&quot;
&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;verticalDragger.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;verticalDragger.Size = UDim2.new(1,20,0,20)
&#9;&#9;verticalDragger.Position = UDim2.new(0,0,1,0)
&#9;&#9;verticalDragger.Active = true
&#9;&#9;verticalDragger.Text = &quot;&quot;

&#9;&#9;local scrubFrame = Instance.new(&quot;Frame&quot;,verticalDragger)
&#9;&#9;scrubFrame.Name = &quot;ScrubFrame&quot;
&#9;&#9;scrubFrame.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;scrubFrame.BorderSizePixel = 0
&#9;&#9;scrubFrame.Position = UDim2.new(0.5,-5,0.5,0)
&#9;&#9;scrubFrame.Size = UDim2.new(0,10,0,1)
&#9;&#9;scrubFrame.ZIndex = 5
&#9;&#9;local scrubTwo = scrubFrame:clone()
&#9;&#9;scrubTwo.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;&#9;scrubTwo.Parent = verticalDragger
&#9;&#9;local scrubThree = scrubFrame:clone()
&#9;&#9;scrubThree.Position = UDim2.new(0.5,-5,0.5,2)
&#9;&#9;scrubThree.Parent = verticalDragger

&#9;&#9;local areaSoak = Instance.new(&quot;TextButton&quot;,getScreenGuiAncestor(parent))
&#9;&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;&#9;areaSoak.BackgroundTransparency = 1
&#9;&#9;areaSoak.BorderSizePixel = 0
&#9;&#9;areaSoak.Text = &quot;&quot;
&#9;&#9;areaSoak.ZIndex = 10
&#9;&#9;areaSoak.Visible = false
&#9;&#9;areaSoak.Active = true

&#9;&#9;local draggingVertical = false
&#9;&#9;local startYPos = nil
&#9;&#9;verticalDragger.MouseEnter:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(60/255,60/255,60/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseLeave:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseButton1Down:connect(function(x,y)
&#9;&#9;&#9;draggingVertical = true
&#9;&#9;&#9;areaSoak.Visible = true
&#9;&#9;&#9;startYPos = y
&#9;&#9;end)
&#9;&#9;areaSoak.MouseButton1Up:connect(function (  )
&#9;&#9;&#9;draggingVertical = false
&#9;&#9;&#9;areaSoak.Visible = false
&#9;&#9;end)
&#9;&#9;areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;if not draggingVertical then return end

&#9;&#9;&#9;local yDelta = y - startYPos
&#9;&#9;&#9;if not control.ScrollDownButton.Visible and yDelta &gt; 0 then
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;if (widgetContainer.Size.Y.Offset + yDelta) &lt; 150 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,150)
&#9;&#9;&#9;&#9;control.Size = UDim2.new (0,21,0,150)
&#9;&#9;&#9;&#9;return 
&#9;&#9;&#9;end 

&#9;&#9;&#9;startYPos = y

&#9;&#9;&#9;if widgetContainer.Size.Y.Offset + yDelta &gt;= 0 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,widgetContainer.Size.Y.Offset + yDelta)
&#9;&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,control.Size.Y.Offset + yDelta )
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end

&#9;local function switchMinimize()
&#9;&#9;minimizeFrame.Visible = not minimizeFrame.Visible
&#9;&#9;if scrollable then
&#9;&#9;&#9;frame.Visible = not frame.Visible
&#9;&#9;&#9;verticalDragger.Visible = not verticalDragger.Visible
&#9;&#9;&#9;control.Visible = not control.Visible
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Visible = not widgetContainer.Visible
&#9;&#9;end

&#9;&#9;if minimizeFrame.Visible then
&#9;&#9;&#9;minimizeButton.Text = &quot;+&quot;
&#9;&#9;else
&#9;&#9;&#9;minimizeButton.Text = &quot;-&quot;
&#9;&#9;end
&#9;end

&#9;minimizeBigButton.MouseButton1Click:connect(function (  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;minimizeButton.MouseButton1Click:connect(function(  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;if scrollable then
&#9;&#9;return dragBar, frame, helpFrame, closeEvent
&#9;else
&#9;&#9;return dragBar, widgetContainer, helpFrame, closeEvent
&#9;end
end

t.Help = 
&#9;function(funcNameOrFunc) 
&#9;&#9;--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
&#9;&#9;if funcNameOrFunc == &quot;CreatePropertyDropDownMenu&quot; or funcNameOrFunc == t.CreatePropertyDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreatePropertyDropDownMenu.  &quot; ..
&#9;&#9;&#9;&#9;   &quot;Arguments: (instance, propertyName, enumType).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: returns a container with a drop-down-box that is linked to the &apos;property&apos; field of &apos;instance&apos; which is of type &apos;enumType&apos;&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateDropDownMenu&quot; or funcNameOrFunc == t.CreateDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreateDropDownMenu.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (items, onItemSelected).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: Returns 2 results, a container to the gui object and a &apos;updateSelection&apos; function for external updating.  The container is a drop-down-box created around a list of items&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateMessageDialog&quot; or funcNameOrFunc == t.CreateMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button&quot;
&#9;&#9;end&#9;&#9;
&#9;&#9;if funcNameOrFunc == &quot;CreateStyledMessageDialog&quot; or funcNameOrFunc == t.CreateStyledMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateStyledMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, style, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button, &apos;style&apos; is a string, either Error, Notify or Confirm&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;GetFontHeight&quot; or funcNameOrFunc == t.GetFontHeight then
&#9;&#9;&#9;return &quot;Function GetFontHeight.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (font, fontSize). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: returns the size in pixels of the given font + fontSize&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;LayoutGuiObjects&quot; or funcNameOrFunc == t.LayoutGuiObjects then
&#9;&#9;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateScrollingFrame&quot; or funcNameOrFunc == t.CreateScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (orderList, style) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 4 objects, (scrollFrame, scrollUpButton, scrollDownButton, recalculateFunction).  &apos;scrollFrame&apos; can be filled with GuiObjects.  It will lay them out and allow scrollUpButton/scrollDownButton to interact with them.  Orderlist is optional (and specifies the order to layout the children.  Without orderlist, it uses the children order. style is also optional, and allows for a &apos;grid&apos; styling if style is passed &apos;grid&apos; as a string.  recalculateFunction can be called when a relayout is needed (when orderList changes)&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTrueScrollingFrame&quot; or funcNameOrFunc == t.CreateTrueScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateTrueScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (nil) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (scrollFrame, controlFrame).  &apos;scrollFrame&apos; can be filled with GuiObjects, and they will be clipped if not inside the frame&apos;s bounds. controlFrame has children scrollup and scrolldown, as well as a slider.  controlFrame can be parented to any guiobject and it will readjust itself to fit.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;AutoTruncateTextObject&quot; or funcNameOrFunc == t.AutoTruncateTextObject then
&#9;&#9;&#9;return &quot;Function AutoTruncateTextObject.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (textLabel) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (textLabel, changeText).  The &apos;textLabel&apos; input is modified to automatically truncate text (with ellipsis), if it gets too small to fit.  &apos;changeText&apos; is a function that can be used to change the text, it takes 1 string as an argument&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSlider&quot; or funcNameOrFunc == t.CreateSlider then
&#9;&#9;&#9;return &quot;Function CreateSlider.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSliderNew&quot; or funcNameOrFunc == t.CreateSliderNew then
&#9;&#9;&#9;return &quot;Function CreateSliderNew.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateLoadingFrame&quot; or funcNameOrFunc == t.CreateLoadingFrame then
&#9;&#9;&#9;return &quot;Function CreateLoadingFrame.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (name, size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Creates a gui that can be manipulated to show progress for a particular action.  Name appears above the loading bar, and size and position are udim2 values (both size and position are optional arguments).  Returns 3 arguments, the first being the gui created. The second being updateLoadingGuiPercent, which is a bindable function.  This function takes one argument (two optionally), which should be a number between 0 and 1, representing the percentage the loading gui should be at.  The second argument to this function is a boolean value that if set to true will tween the current percentage value to the new percentage value, therefore our third argument is how long this tween should take. Our third returned argument is a BindableEvent, that when fired means that someone clicked the cancel button on the dialog.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTerrainMaterialSelector&quot; or funcNameOrFunc == t.CreateTerrainMaterialSelector then
&#9;&#9;&#9;return &quot;Function CreateTerrainMaterialSelector.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Size and position are UDim2 values that specifies the selector&apos;s size and position.  Both size and position are optional arguments. This method returns 3 objects (terrainSelectorGui, terrainSelected, forceTerrainSelection).  terrainSelectorGui is just the gui object that we generate with this function, parent it as you like. TerrainSelected is a BindableEvent that is fired whenever a new terrain type is selected in the gui.  ForceTerrainSelection is a function that takes an argument of Enum.CellMaterial and will force the gui to show that material as currently selected.&quot;
&#9;&#9;end
&#9;end

--rbxsig%S02sfJuSM3Thz5hVIxyf9kDDENER9guz5nwJx/SfET0qAar5EDNQ6VJkwq7L45ZNfqVNd7IxhujzkgYff2V8ee5Mp5MfS9aEcztYGlWumULivAzynGfqkdVh+GzofuzUmMwWqPPsKqvQLiFe9MXMtCqe89S/Y9n6LZgrS1hyuqY=%
--fixed by iagoMAO --

-- A couple of necessary functions
local function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end
local function waitForProperty(instance, property)
&#9;while not instance[property] do
&#9;&#9;instance.Changed:wait()
&#9;end
end

waitForChild(game,&quot;Players&quot;)
waitForProperty(game.Players,&quot;LocalPlayer&quot;)
local player = game.Players.LocalPlayer

local RbxGui,msg = t
if not RbxGui then print(&quot;could not find RbxGui!&quot;) return end

--- Begin Locals
waitForChild(game,&quot;Players&quot;)

-- don&apos;t do anything if we are in an empty game
if #game.Players:GetChildren() &lt; 1 then
&#9;game.Players.ChildAdded:wait()
end

local tilde = &quot;~&quot;
local backquote = &quot;`&quot;
game:GetService(&quot;GuiService&quot;):AddKey(tilde) -- register our keys
game:GetService(&quot;GuiService&quot;):AddKey(backquote)

local player = game.Players.LocalPlayer

local backpack = script.Parent.Backpack
local screen = script.Parent
local closeButton = backpack.Tabs.CloseButton

local openCloseDebounce = false

local backpackItems = {}

local buttons = {}

local debounce = false

local guiTweenSpeed = 1

local browsingMenu = false

local mouseEnterCons = {}
local mouseClickCons = {}

local characterChildAddedCon = nil
local characterChildRemovedCon = nil
local backpackAddCon = nil
local humanoidDiedCon = nil
local backpackButtonClickCon = nil
local guiServiceKeyPressCon = nil

waitForChild(player,&quot;Backpack&quot;)
local playerBackpack = player.Backpack

waitForChild(backpack,&quot;Gear&quot;)
waitForChild(backpack.Gear,&quot;GearPreview&quot;)
local gearPreview = backpack.Gear.GearPreview

waitForChild(backpack.Gear,&quot;GearGridScrollingArea&quot;)
local scroller = backpack.Gear.GearGridScrollingArea

waitForChild(backpack.Parent,&quot;CurrentLoadout&quot;)
local currentLoadout = backpack.Parent.CurrentLoadout

waitForChild(backpack.Parent,&quot;ControlFrame&quot;)
waitForChild(backpack.Parent.ControlFrame,&quot;BackpackButton&quot;)
local backpackButton = backpack.Parent.ControlFrame.BackpackButton

waitForChild(backpack.Gear,&quot;GearGrid&quot;)
waitForChild(backpack.Gear.GearGrid,&quot;GearButton&quot;)
local gearButton = backpack.Gear.GearGrid.GearButton
local grid = backpack.Gear.GearGrid

waitForChild(backpack.Gear.GearGrid,&quot;SearchFrame&quot;)
waitForChild(backpack.Gear.GearGrid.SearchFrame,&quot;SearchBoxFrame&quot;)
waitForChild(backpack.Gear.GearGrid.SearchFrame.SearchBoxFrame,&quot;SearchBox&quot;)
local searchBox = backpack.Gear.GearGrid.SearchFrame.SearchBoxFrame.SearchBox

waitForChild(backpack.Gear.GearGrid.SearchFrame,&quot;SearchButton&quot;)
local searchButton = backpack.Gear.GearGrid.SearchFrame.SearchButton

waitForChild(backpack.Gear.GearGrid,&quot;ResetFrame&quot;)
local resetFrame = backpack.Gear.GearGrid.ResetFrame

waitForChild(backpack.Gear.GearGrid.ResetFrame,&quot;ResetButtonBorder&quot;)
local resetButton = backpack.Gear.GearGrid.ResetFrame.ResetButtonBorder

waitForChild(script.Parent,&quot;SwapSlot&quot;)
local swapSlot = script.Parent.SwapSlot


-- creating scroll bar early as to make sure items get placed correctly
local scrollFrame, scrollUp, scrollDown, recalculateScroll = RbxGui.CreateScrollingFrame(nil,&quot;grid&quot;)

scrollFrame.Position = UDim2.new(0,0,0,30)
scrollFrame.Size = UDim2.new(1,0,1,-30)
scrollFrame.Parent = backpack.Gear.GearGrid

local scrollBar = Instance.new(&quot;Frame&quot;)
scrollBar.Name = &quot;ScrollBar&quot;
scrollBar.BackgroundTransparency = 0.9
scrollBar.BackgroundColor3 = Color3.new(1,1,1)
scrollBar.BorderSizePixel = 0
scrollBar.Size = UDim2.new(0, 17, 1, -36)
scrollBar.Position = UDim2.new(0,0,0,18)
scrollBar.Parent = scroller

scrollDown.Position = UDim2.new(0,0,1,-17)

scrollUp.Parent = scroller
scrollDown.Parent = scroller

local scrollFrameLoadout, scrollUpLoadout, scrollDownLoadout, recalculateScrollLoadout = RbxGui.CreateScrollingFrame()

scrollFrameLoadout.Position = UDim2.new(0,0,0,0)
scrollFrameLoadout.Size = UDim2.new(1,0,1,0)
scrollFrameLoadout.Parent = backpack.Gear.GearLoadouts.LoadoutsList

local LoadoutButton = Instance.new(&quot;TextButton&quot;)

LoadoutButton.Name = &quot;LoadoutButton&quot;
LoadoutButton.Font = Enum.Font.ArialBold
LoadoutButton.FontSize = Enum.FontSize.Size14
LoadoutButton.Position = UDim2.new(0,0,0,0)
LoadoutButton.Size = UDim2.new(1,0,0,32)
LoadoutButton.Style = Enum.ButtonStyle.RobloxButton
LoadoutButton.Text = &quot;Loadout #1&quot;
LoadoutButton.TextColor3 = Color3.new(1,1,1)
LoadoutButton.Parent = scrollFrameLoadout

local LoadoutButtonTwo = LoadoutButton:clone()
LoadoutButtonTwo.Text = &quot;Loadout #2&quot;
LoadoutButtonTwo.Parent = scrollFrameLoadout

local LoadoutButtonThree = LoadoutButton:clone()
LoadoutButtonThree.Text = &quot;Loadout #3&quot;
LoadoutButtonThree.Parent = scrollFrameLoadout

local LoadoutButtonFour = LoadoutButton:clone()
LoadoutButtonFour.Text = &quot;Loadout #4&quot;
LoadoutButtonFour.Parent = scrollFrameLoadout

local scrollBarLoadout = Instance.new(&quot;Frame&quot;)
scrollBarLoadout.Name = &quot;ScrollBarLoadout&quot;
scrollBarLoadout.BackgroundTransparency = 0.9
scrollBarLoadout.BackgroundColor3 = Color3.new(1,1,1)
scrollBarLoadout.BorderSizePixel = 0
scrollBarLoadout.Size = UDim2.new(0, 17, 1, -36)
scrollBarLoadout.Position = UDim2.new(0,0,0,18)
scrollBarLoadout.Parent = backpack.Gear.GearLoadouts.GearLoadoutsScrollingArea

scrollDownLoadout.Position = UDim2.new(0,0,1,-17)

scrollUpLoadout.Parent = backpack.Gear.GearLoadouts.GearLoadoutsScrollingArea
scrollDownLoadout.Parent = backpack.Gear.GearLoadouts.GearLoadoutsScrollingArea


-- Begin Functions
function removeFromMap(map,object)
&#9;for i = 1, #map do
&#9;&#9;if map[i] == object then
&#9;&#9;&#9;table.remove(map,i)
&#9;&#9;&#9;break
&#9;&#9;end
&#9;end
end


function resize()
&#9;local size = 0
&#9;if gearPreview.AbsoluteSize.Y &gt; gearPreview.AbsoluteSize.X then
&#9;&#9;size = gearPreview.AbsoluteSize.X * 0.75
&#9;else
&#9;&#9;size = gearPreview.AbsoluteSize.Y * 0.75
&#9;end

&#9;gearPreview.GearImage.Size = UDim2.new(0,size,0,size)
&#9;gearPreview.GearImage.Position = UDim2.new(0,gearPreview.AbsoluteSize.X/2 - size/2,0.75,-size)
&#9;
&#9;resizeGrid()
end

function addToGrid(child)
&#9;if not child:IsA(&quot;Tool&quot;) then
&#9;&#9;if not child:IsA(&quot;HopperBin&quot;) then 
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end
&#9;if child:FindFirstChild(&quot;RobloxBuildTool&quot;) then return end
&#9;
&#9;for i,v in pairs(backpackItems) do  -- check to see if we already have this gear registered
&#9;&#9;if v == child then return end
&#9;end

&#9;table.insert(backpackItems,child)
&#9;
&#9;local changeCon = child.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Name&quot; then
&#9;&#9;&#9;if buttons[child] then
&#9;&#9;&#9;&#9;if buttons[child].Image == &quot;&quot; then
&#9;&#9;&#9;&#9;&#9;buttons[child].GearText.Text = child.Name
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;local ancestryCon = nil
&#9;ancestryCon = child.AncestryChanged:connect(function(theChild,theParent)
&#9;&#9;local thisObject = nil
&#9;&#9;for k,v in pairs(backpackItems) do
&#9;&#9;&#9;if v == child then
&#9;&#9;&#9;&#9;thisObject = v
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;waitForProperty(player,&quot;Character&quot;)
&#9;&#9;waitForChild(player,&quot;Backpack&quot;)
&#9;&#9;if (child.Parent ~= player.Backpack and child.Parent ~= player.Character) then
&#9;&#9;&#9;if ancestryCon then ancestryCon:disconnect() end
&#9;&#9;&#9;if changeCon then changeCon:disconnect() end
&#9;&#9;&#9;
&#9;&#9;&#9;for k,v in pairs(backpackItems) do
&#9;&#9;&#9;&#9;if v == thisObject then
&#9;&#9;&#9;&#9;&#9;if mouseEnterCons[buttons[v]] then mouseEnterCons[buttons[v]]:disconnect() end
&#9;&#9;&#9;&#9;&#9;if mouseClickCons[buttons[v]] then mouseClickCons[buttons[v]]:disconnect() end
&#9;&#9;&#9;&#9;&#9;buttons[v].Parent = nil
&#9;&#9;&#9;&#9;&#9;buttons[v] = nil
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;removeFromMap(backpackItems,thisObject)
&#9;&#9;&#9;
&#9;&#9;&#9;resizeGrid()
&#9;&#9;else
&#9;&#9;&#9;resizeGrid()
&#9;&#9;end
&#9;&#9;updateGridActive()
&#9;end)
&#9;resizeGrid()
end

function buttonClick(button)
&#9;if button:FindFirstChild(&quot;UnequipContextMenu&quot;) and not button.Active then
&#9;&#9;button.UnequipContextMenu.Visible = true
&#9;&#9;browsingMenu = true
&#9;end
end

function previewGear(button)
&#9;if not browsingMenu then
&#9;&#9;gearPreview.GearImage.Image = button.Image
&#9;&#9;gearPreview.GearStats.GearName.Text = button.GearReference.Value.Name
&#9;end
end

function findEmptySlot()
&#9;local smallestNum = nil
&#9;local loadout = currentLoadout:GetChildren()
&#9;for i = 1, #loadout do
&#9;&#9;if loadout[i]:IsA(&quot;Frame&quot;) and #loadout[i]:GetChildren() &lt;= 0 then
&#9;&#9;&#9;local frameNum = tonumber(string.sub(loadout[i].Name,5))
&#9;&#9;&#9;if frameNum == 0 then frameNum = 10 end
&#9;&#9;&#9;if not smallestNum or (smallestNum &gt; frameNum) then
&#9;&#9;&#9;&#9;smallestNum = frameNum
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;if smallestNum == 10 then smallestNum = 0 end
&#9;return smallestNum
end

function checkForSwap(button,x,y)
&#9;local loadoutChildren = currentLoadout:GetChildren()
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) and string.find(loadoutChildren[i].Name,&quot;Slot&quot;) then
&#9;&#9;&#9;if x &gt;= loadoutChildren[i].AbsolutePosition.x and x &lt;= (loadoutChildren[i].AbsolutePosition.x + loadoutChildren[i].AbsoluteSize.x) then
&#9;&#9;&#9;&#9;if y &gt;= loadoutChildren[i].AbsolutePosition.y and y &lt;= (loadoutChildren[i].AbsolutePosition.y + loadoutChildren[i].AbsoluteSize.y) then
&#9;&#9;&#9;&#9;&#9;local slot = tonumber(string.sub(loadoutChildren[i].Name,5))
&#9;&#9;&#9;&#9;&#9;swapGearSlot(slot,button)
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return false
end

function resizeGrid()
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if not v:FindFirstChild(&quot;RobloxBuildTool&quot;) then
&#9;&#9;&#9;if not buttons[v] then
&#9;&#9;&#9;&#9;local buttonClone = gearButton:clone()
&#9;&#9;&#9;&#9;buttonClone.Parent = grid.ScrollingFrame
&#9;&#9;&#9;&#9;buttonClone.Visible = true
&#9;&#9;&#9;&#9;buttonClone.Image = v.TextureId
&#9;&#9;&#9;&#9;if buttonClone.Image == &quot;&quot; then
&#9;&#9;&#9;&#9;&#9;buttonClone.GearText.Text = v.Name
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;buttonClone.GearReference.Value = v
&#9;&#9;&#9;&#9;buttonClone.Draggable = true 
&#9;&#9;&#9;&#9;buttons[v] = buttonClone
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local unequipMenu = getGearContextMenu()
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;unequipMenu.Visible = false
&#9;&#9;&#9;&#9;unequipMenu.Parent = buttonClone
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local beginPos = nil
&#9;&#9;&#9;&#9;buttonClone.DragBegin:connect(function(value)
&#9;&#9;&#9;&#9;&#9;buttonClone.ZIndex = 9
&#9;&#9;&#9;&#9;&#9;beginPos = value
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;buttonClone.DragStopped:connect(function(x,y)
&#9;&#9;&#9;&#9;&#9;if beginPos ~= buttonClone.Position then
&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.ZIndex = 1
&#9;&#9;&#9;&#9;&#9;&#9;if not checkForSwap(buttonClone,x,y) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone:TweenPosition(beginPos,Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.5, true)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.Draggable = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;delay(0.5,function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.Draggable = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.Position = beginPos
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end&#9;
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;local clickTime = tick()
&#9;&#9;&#9;&#9;mouseEnterCons[buttonClone] = buttonClone.MouseEnter:connect(function() previewGear(buttonClone) end)
&#9;&#9;&#9;&#9;mouseClickCons[buttonClone] = buttonClone.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;local newClickTime = tick()
&#9;&#9;&#9;&#9;&#9;if buttonClone.Active and (newClickTime - clickTime) &lt; 0.5 then
&#9;&#9;&#9;&#9;&#9;&#9;local slot = findEmptySlot()
&#9;&#9;&#9;&#9;&#9;&#9;if slot then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.ZIndex = 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;swapGearSlot(slot,buttonClone)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;buttonClick(buttonClone)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;clickTime = newClickTime
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;recalculateScroll()
end

function showPartialGrid(subset)

&#9;resetFrame.Visible = true

&#9;for k,v in pairs(buttons) do
&#9;&#9;v.Parent = nil
&#9;end
&#9;for k,v in pairs(subset) do
&#9;&#9;v.Parent =  grid.ScrollingFrame
&#9;end
&#9;recalculateScroll()
end

function showEntireGrid()
&#9;resetFrame.Visible = false
&#9;
&#9;for k,v in pairs(buttons) do
&#9;&#9;v.Parent = grid.ScrollingFrame
&#9;end
&#9;recalculateScroll()
end

function inLoadout(gear)
&#9;local children = currentLoadout:GetChildren()
&#9;for i = 1, #children do
&#9;&#9;if children[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;local button = children[i]:GetChildren()
&#9;&#9;&#9;if #button &gt; 0 then
&#9;&#9;&#9;&#9;if button[1].GearReference.Value and button[1].GearReference.Value == gear then
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return false
end&#9;

function updateGridActive()
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if buttons[v] then
&#9;&#9;&#9;local gear = nil
&#9;&#9;&#9;local gearRef = buttons[v]:FindFirstChild(&quot;GearReference&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;if gearRef then gear = gearRef.Value end
&#9;&#9;&#9;
&#9;&#9;&#9;if not gear then
&#9;&#9;&#9;&#9;buttons[v].Active = false
&#9;&#9;&#9;elseif inLoadout(gear) then
&#9;&#9;&#9;&#9;buttons[v].Active = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;buttons[v].Active = true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function centerGear(loadoutChildren)
&#9;local gearButtons = {}
&#9;local lastSlotAdd = nil
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) and #loadoutChildren[i]:GetChildren() &gt; 0 then
&#9;&#9;&#9;if loadoutChildren[i].Name == &quot;Slot0&quot; then 
&#9;&#9;&#9;&#9;lastSlotAdd = loadoutChildren[i]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;table.insert(gearButtons, loadoutChildren[i])
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;if lastSlotAdd then table.insert(gearButtons,lastSlotAdd) end
&#9;
&#9;local startPos = ( 1 - (#gearButtons * 0.1) ) / 2
&#9;for i = 1, #gearButtons do&#9;
&#9;&#9;gearButtons[i]:TweenPosition(UDim2.new(startPos + ((i - 1) * 0.1),0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.25, true)
&#9;end
end

function spreadOutGear(loadoutChildren)
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;local slot = tonumber(string.sub(loadoutChildren[i].Name,5))
&#9;&#9;&#9;if slot == 0 then slot = 10 end
&#9;&#9;&#9;loadoutChildren[i]:TweenPosition(UDim2.new((slot - 1)/10,0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.25, true)
&#9;&#9;end
&#9;end
end

function openCloseBackpack(close)
&#9;if openCloseDebounce then return end
&#9;openCloseDebounce = true

&#9;local visible = not backpack.Visible
&#9;if visible and not close then
&#9;&#9;updateGridActive()
&#9;&#9;local centerDialogSupported, msg = pcall(function() game.GuiService:AddCenterDialog(backpack, Enum.CenterDialogType.PlayerInitiatedDialog, 
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;backpack.Visible = true
&#9;&#9;&#9;&#9;loadoutChildren = currentLoadout:GetChildren()
&#9;&#9;&#9;&#9;for i = 1, #loadoutChildren do
&#9;&#9;&#9;&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;loadoutChildren[i].BackgroundTransparency = 0.5
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;spreadOutGear(loadoutChildren)
&#9;&#9;&#9;end,
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;backpack.Visible = false
&#9;&#9;&#9;end)
&#9;&#9;end)
&#9;&#9;backpackButton.Selected = true
&#9;&#9;backpack:TweenSizeAndPosition(UDim2.new(0.55, 0, 0.6, 0),UDim2.new(0.225, 0, 0.2, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, guiTweenSpeed/2, true)
&#9;&#9;delay(guiTweenSpeed/2 + 0.01,
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;local children = backpack:GetChildren()
&#9;&#9;&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;&#9;&#9;if children[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;children[i].Visible = true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;resizeGrid()
&#9;&#9;&#9;&#9;resize()
&#9;&#9;&#9;&#9;openCloseDebounce = false
&#9;&#9;&#9;end)
&#9;else
&#9;&#9;backpackButton.Selected = false
&#9;&#9;local children = backpack:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;if children[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;children[i].Visible = false
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;loadoutChildren = currentLoadout:GetChildren()
&#9;&#9;for i = 1, #loadoutChildren do
&#9;&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;loadoutChildren[i].BackgroundTransparency = 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;centerGear(loadoutChildren)
&#9;
&#9;&#9;backpack:TweenSizeAndPosition(UDim2.new(0,0,0,0),UDim2.new(0.5,0,0.5,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, guiTweenSpeed/2, true)
&#9;&#9;delay(guiTweenSpeed/2 + 0.01,
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;backpack.Visible = visible
&#9;&#9;&#9;&#9;resizeGrid()
&#9;&#9;&#9;&#9;resize()
&#9;&#9;&#9;&#9;pcall(function() game.GuiService:RemoveCenterDialog(backpack) end)
&#9;&#9;&#9;&#9;openCloseDebounce = false
&#9;&#9;&#9;end)
&#9;end
end

function loadoutCheck(child, selectState)
&#9;if not child:IsA(&quot;ImageButton&quot;) then return end
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if buttons[v] then
&#9;&#9;&#9;if child:FindFirstChild(&quot;GearReference&quot;) and buttons[v]:FindFirstChild(&quot;GearReference&quot;) then
&#9;&#9;&#9;&#9;if buttons[v].GearReference.Value == child.GearReference.Value then
&#9;&#9;&#9;&#9;&#9;buttons[v].Active = selectState
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function clearPreview()
&#9;gearPreview.GearImage.Image = &quot;&quot;
&#9;gearPreview.GearStats.GearName.Text = &quot;&quot;
end

function removeAllEquippedGear(physGear)
&#9;local stuff = player.Character:GetChildren()
&#9;for i = 1, #stuff do
&#9;&#9;if ( stuff[i]:IsA(&quot;Tool&quot;) or stuff[i]:IsA(&quot;HopperBin&quot;) ) and stuff[i] ~= physGear then
&#9;&#9;&#9;stuff[i].Parent = playerBackpack
&#9;&#9;end
&#9;end
end

function equipGear(physGear)
&#9;removeAllEquippedGear(physGear)
&#9;physGear.Parent = player.Character
&#9;updateGridActive()
end

function unequipGear(physGear)
&#9;physGear.Parent = playerBackpack
&#9;updateGridActive()
end

function highlight(button)
&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;button.BackgroundColor3 = Color3.new(0.8,0.8,0.8)
end
function clearHighlight(button)
&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;button.BackgroundColor3 = Color3.new(0,0,0)
end

function swapGearSlot(slot,gearButton)
&#9;if not swapSlot.Value then -- signal loadout to swap a gear out
&#9;&#9;swapSlot.Slot.Value = slot
&#9;&#9;swapSlot.GearButton.Value = gearButton
&#9;&#9;swapSlot.Value = true
&#9;&#9;updateGridActive()
&#9;end
end


local UnequipGearMenuClick = function(element, menu)
&#9;if type(element.Action) ~= &quot;number&quot; then return end
&#9;local num = element.Action
&#9;if num == 1 then -- remove from loadout
&#9;&#9;unequipGear(menu.Parent.GearReference.Value)
&#9;&#9;local inventoryButton = menu.Parent
&#9;&#9;local gearToUnequip = inventoryButton.GearReference.Value
&#9;&#9;local loadoutChildren = currentLoadout:GetChildren()
&#9;&#9;local slot = -1
&#9;&#9;for i = 1, #loadoutChildren do
&#9;&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;local button = loadoutChildren[i]:GetChildren()
&#9;&#9;&#9;&#9;if button[1] and button[1].GearReference.Value == gearToUnequip then
&#9;&#9;&#9;&#9;&#9;slot = button[1].SlotNumber.Text
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;swapGearSlot(slot,nil)
&#9;end
end

-- these next two functions are used to stop any use of backpack while the player is dead (can cause issues)
function activateBackpack()
&#9;loadoutChildren = currentLoadout:GetChildren()
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;loadoutChildren[i].BackgroundTransparency = 1
&#9;&#9;end
&#9;end

&#9;backpackButtonClickCon = backpackButton.MouseButton1Click:connect(function() openCloseBackpack() end)
&#9;guiServiceKeyPressCon = game:GetService(&quot;GuiService&quot;).KeyPressed:connect(function(key)
&#9;&#9;if key == tilde or key == backquote then
&#9;&#9;&#9;openCloseBackpack()
&#9;&#9;end
&#9;end)
end
function deactivateBackpack()
&#9;if backpackButtonClickCon then backpackButtonClickCon:disconnect() end
&#9;if guiServiceKeyPressCon then guiServiceKeyPressCon:disconnect() end

&#9;openCloseBackpack(true)
end

function setupCharacterConnections()

&#9;if backpackAddCon then backpackAddCon:disconnect() end
&#9;backpackAddCon = game.Players.LocalPlayer.Backpack.ChildAdded:connect(function(child) addToGrid(child) end)
&#9;
&#9;-- make sure we get all the children
&#9;local backpackChildren = game.Players.LocalPlayer.Backpack:GetChildren()
&#9;for i = 1, #backpackChildren do
&#9;&#9;addToGrid(backpackChildren[i])
&#9;end

&#9;if characterChildAddedCon then characterChildAddedCon:disconnect() end
&#9;characterChildAddedCon = 
&#9;&#9;game.Players.LocalPlayer.Character.ChildAdded:connect(function(child)
&#9;&#9;&#9;addToGrid(child)
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;&#9;
&#9;if characterChildRemovedCon then characterChildRemovedCon:disconnect() end
&#9;characterChildRemovedCon = 
&#9;&#9;game.Players.LocalPlayer.Character.ChildRemoved:connect(function(child)
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;&#9;
&#9;&#9;&#9;
&#9;if humanoidDiedCon then humanoidDiedCon:disconnect() end
&#9;local localPlayer = game.Players.LocalPlayer
&#9;waitForProperty(localPlayer,&quot;Character&quot;)
&#9;waitForChild(localPlayer.Character,&quot;Humanoid&quot;)
&#9;humanoidDiedCon = game.Players.LocalPlayer.Character.Humanoid.Died:connect(function() deactivateBackpack() end)
&#9;
&#9;activateBackpack()

&#9;wait()
&#9;centerGear(currentLoadout:GetChildren())
end

function removeCharacterConnections()
&#9;if characterChildAddedCon then characterChildAddedCon:disconnect() end
&#9;if characterChildRemovedCon then characterChildRemovedCon:disconnect() end
&#9;if backpackAddCon then backpackAddCon:disconnect() end
end

function trim(s)
  return (s:gsub(&quot;^%s*(.-)%s*$&quot;, &quot;%1&quot;))
end

function splitByWhiteSpace(text)
&#9;if type(text) ~= &quot;string&quot; then return nil end
&#9;
&#9;local terms = {}
&#9;for token in string.gmatch(text, &quot;[^%s]+&quot;) do
&#9;   if string.len(token) &gt; 2 then
&#9;&#9;&#9;table.insert(terms,token)
&#9;   end
&#9;end
&#9;return terms
end

function filterGear(searchTerm)
&#9;string.lower(searchTerm)
&#9;searchTerm = trim(searchTerm)
&#9;if string.len(searchTerm) &lt; 2 then return nil end
&#9;local terms = splitByWhiteSpace(searchTerm)
&#9;
&#9;local filteredGear = {}
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if buttons[v] then
&#9;&#9;&#9;local gearString = string.lower(buttons[v].GearReference.Value.Name)
&#9;&#9;&#9;gearString = trim(gearString)
&#9;&#9;&#9;for i = 1, #terms do
&#9;&#9;&#9;&#9;if string.match(gearString,terms[i]) then
&#9;&#9;&#9;&#9;&#9;table.insert(filteredGear,buttons[v])
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;return filteredGear
end


function showSearchGear()
&#9;local searchText = searchBox.Text
&#9;searchBox.Text = &quot;Search...&quot;
&#9;local filteredButtons = filterGear(searchText)
&#9;if filteredButtons and #filteredButtons &gt; 0 then
&#9;&#9;showPartialGrid(filteredButtons)
&#9;else
&#9;&#9;showEntireGrid()
&#9;end
end

function nukeBackpack()
&#9;while #buttons &gt; 0 do
&#9;&#9;table.remove(buttons)
&#9;end
&#9;buttons = {}
&#9;while #backpackItems &gt; 0 do
&#9;&#9;table.remove(backpackItems)
&#9;end
&#9;backpackItems = {}
&#9;local scrollingFrameChildren = grid.ScrollingFrame:GetChildren()
&#9;for i = 1, #scrollingFrameChildren do
&#9;&#9;scrollingFrameChildren[i]:remove()
&#9;end
end

function getGearContextMenu()
&#9;local gearContextMenu = Instance.new(&quot;Frame&quot;)
&#9;gearContextMenu.Active = true
&#9;gearContextMenu.Name = &quot;UnequipContextMenu&quot;
&#9;gearContextMenu.Size = UDim2.new(0,115,0,70)
&#9;gearContextMenu.Position = UDim2.new(0,-16,0,-16)
&#9;gearContextMenu.BackgroundTransparency = 1
&#9;gearContextMenu.Visible = false

&#9;local gearContextMenuButton = Instance.new(&quot;TextButton&quot;)
&#9;gearContextMenuButton.Name = &quot;UnequipContextMenuButton&quot;
&#9;gearContextMenuButton.Text = &quot;&quot;
&#9;gearContextMenuButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;gearContextMenuButton.ZIndex = 4
&#9;gearContextMenuButton.Size = UDim2.new(1, 0, 1, -20)
&#9;gearContextMenuButton.Visible = true
&#9;gearContextMenuButton.Parent = gearContextMenu
&#9;
&#9;local elementHeight = 12
&#9;
&#9;local contextMenuElements = {}&#9;&#9;
&#9;local contextMenuElementsName = {&quot;Remove Hotkey&quot;}

&#9;for i = 1, #contextMenuElementsName do
&#9;&#9;local element = {}
&#9;&#9;element.Type = &quot;Button&quot;
&#9;&#9;element.Text = contextMenuElementsName[i]
&#9;&#9;element.Action = i
&#9;&#9;element.DoIt = UnequipGearMenuClick
&#9;&#9;table.insert(contextMenuElements,element)
&#9;end

&#9;for i, contextElement in ipairs(contextMenuElements) do
&#9;&#9;local element = contextElement
&#9;&#9;if element.Type == &quot;Button&quot; then
&#9;&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;button.Name = &quot;UnequipContextButton&quot; .. i
&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;button.BorderSizePixel = 0
&#9;&#9;&#9;button.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;button.Text = &quot; &quot; .. contextElement.Text
&#9;&#9;&#9;button.Font = Enum.Font.Arial
&#9;&#9;&#9;button.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;button.Size = UDim2.new(1, 8, 0, elementHeight)
&#9;&#9;&#9;button.Position = UDim2.new(0,0,0,elementHeight * i)
&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;button.ZIndex = 4
&#9;&#9;&#9;button.Parent = gearContextMenuButton

&#9;&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;if button.Active and not gearContextMenu.Parent.Active then
&#9;&#9;&#9;&#9;&#9;local success, result = pcall(function() element.DoIt(element, gearContextMenu) end)
&#9;&#9;&#9;&#9;&#9;browsingMenu = false
&#9;&#9;&#9;&#9;&#9;gearContextMenu.Visible = false
&#9;&#9;&#9;&#9;&#9;clearHighlight(button)
&#9;&#9;&#9;&#9;&#9;clearPreview()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;if button.Active and gearContextMenu.Parent.Active then
&#9;&#9;&#9;&#9;&#9;highlight(button)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;if button.Active and gearContextMenu.Parent.Active then
&#9;&#9;&#9;&#9;&#9;clearHighlight(button)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;contextElement.Button = button
&#9;&#9;&#9;contextElement.Element = button
&#9;&#9;elseif element.Type == &quot;Label&quot; then
&#9;&#9;&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;frame.Name = &quot;ContextLabel&quot; .. i
&#9;&#9;&#9;frame.BackgroundTransparency = 1
&#9;&#9;&#9;frame.Size = UDim2.new(1, 8, 0, elementHeight)

&#9;&#9;&#9;local label = Instance.new(&quot;TextLabel&quot;)&#9;
&#9;&#9;&#9;label.Name = &quot;Text1&quot;
&#9;&#9;&#9;label.BackgroundTransparency = 1
&#9;&#9;&#9;label.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;label.BorderSizePixel = 0
&#9;&#9;&#9;label.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;label.Font = Enum.Font.ArialBold
&#9;&#9;&#9;label.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;label.Position = UDim2.new(0.0, 0, 0, 0)
&#9;&#9;&#9;label.Size = UDim2.new(0.5, 0, 1, 0)
&#9;&#9;&#9;label.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;label.ZIndex = 4
&#9;&#9;&#9;label.Parent = frame
&#9;&#9;&#9;element.Label1 = label
&#9;&#9;
&#9;&#9;&#9;if element.GetText2 then
&#9;&#9;&#9;&#9;label = Instance.new(&quot;TextLabel&quot;)&#9;
&#9;&#9;&#9;&#9;label.Name = &quot;Text2&quot;
&#9;&#9;&#9;&#9;label.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;label.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;label.BorderSizePixel = 0
&#9;&#9;&#9;&#9;label.TextXAlignment = Enum.TextXAlignment.Right
&#9;&#9;&#9;&#9;label.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;label.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;&#9;label.Position = UDim2.new(0.5, 0, 0, 0)
&#9;&#9;&#9;&#9;label.Size = UDim2.new(0.5, 0, 1, 0)
&#9;&#9;&#9;&#9;label.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;label.ZIndex = 4
&#9;&#9;&#9;&#9;label.Parent = frame
&#9;&#9;&#9;&#9;element.Label2 = label
&#9;&#9;&#9;end
&#9;&#9;&#9;frame.Parent = gearContextMenuButton
&#9;&#9;&#9;element.Label = frame
&#9;&#9;&#9;element.Element =  frame
&#9;&#9;end
&#9;end

&#9;gearContextMenu.ZIndex = 4
&#9;gearContextMenu.MouseLeave:connect(function()
&#9;&#9;browsingMenu = false
&#9;&#9;gearContextMenu.Visible = false
&#9;&#9;clearPreview()
&#9;end)
&#9;
&#9;
&#9;return gearContextMenu
end

local backpackChildren = player.Backpack:GetChildren()
for i = 1, #backpackChildren do
&#9;addToGrid(backpackChildren[i])
end

------------------------- Start Lifelong Connections -----------------------
screen.Changed:connect(function(prop)
&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;if debounce then return end
&#9;&#9;debounce = true
&#9;&#9;wait()
&#9;&#9;resize()
&#9;&#9;resizeGrid()
&#9;&#9;debounce = false
&#9;end
end)

currentLoadout.ChildAdded:connect(function(child) loadoutCheck(child, false) end)
currentLoadout.ChildRemoved:connect(function(child) loadoutCheck(child, true) end)

currentLoadout.DescendantAdded:connect(function(descendant)
&#9;if not backpack.Visible and ( descendant:IsA(&quot;ImageButton&quot;) or descendant:IsA(&quot;TextButton&quot;) ) then
&#9;&#9;centerGear(currentLoadout:GetChildren())
&#9;end
end)
currentLoadout.DescendantRemoving:connect(function(descendant)
&#9;if not backpack.Visible and ( descendant:IsA(&quot;ImageButton&quot;) or descendant:IsA(&quot;TextButton&quot;) ) then
&#9;&#9;wait()
&#9;&#9;centerGear(currentLoadout:GetChildren())
&#9;end
end)
&#9;
grid.MouseEnter:connect(function() clearPreview() end)
grid.MouseLeave:connect(function() clearPreview() end)

player.CharacterRemoving:connect(function()
&#9;removeCharacterConnections()
&#9;nukeBackpack()
end)
player.CharacterAdded:connect(function() setupCharacterConnections() end)

player.ChildAdded:connect(function(child)
&#9;if child:IsA(&quot;Backpack&quot;) then
&#9;&#9;playerBackpack = child
&#9;&#9;if backpackAddCon then backpackAddCon:disconnect() end
&#9;&#9;backpackAddCon = game.Players.LocalPlayer.Backpack.ChildAdded:connect(function(child) addToGrid(child) end)
&#9;end
end)

swapSlot.Changed:connect(function()
&#9;if not swapSlot.Value then
&#9;&#9;updateGridActive()
&#9;end
end)

searchBox.FocusLost:connect(function(enterPressed)
&#9;if enterPressed then
&#9;&#9;showSearchGear()
&#9;end
end)

local loadoutChildren = currentLoadout:GetChildren()
for i = 1, #loadoutChildren do
&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) and string.find(loadoutChildren[i].Name,&quot;Slot&quot;) then
&#9;&#9;loadoutChildren[i].ChildRemoved:connect(function()
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;&#9;loadoutChildren[i].ChildAdded:connect(function()
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;end
end

pcall(function() closeButton.Modal = true end)
closeButton.MouseButton1Click:connect(function() openCloseBackpack() end)

searchButton.MouseButton1Click:connect(function() showSearchGear() end)
resetButton.MouseButton1Click:connect(function() showEntireGrid() end)
------------------------- End Lifelong Connections -----------------------

resize()
resizeGrid()

-- make sure any items in the loadout are accounted for in inventory
local loadoutChildren = currentLoadout:GetChildren()
for i = 1, #loadoutChildren do
&#9;loadoutCheck(loadoutChildren[i], false)
end
if not backpack.Visible then centerGear(currentLoadout:GetChildren()) end

-- make sure that inventory is listening to gear reparenting
if characterChildAddedCon == nil and game.Players.LocalPlayer[&quot;Character&quot;] then
&#9;setupCharacterConnections()
end
if not backpackAddCon then
&#9;backpackAddCon = game.Players.LocalPlayer.Backpack.ChildAdded:connect(function(child) addToGrid(child) end)
end

recalculateScrollLoadout()

print(&quot;Backpack has been built. Time for the resizer script.&quot;)
script.Parent.BackpackResizer.Parent = script.Parent.Backpack</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX4">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">BackpackScript</string>
					<ProtectedString name="Source">-- A couple of necessary functions
local function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end
local function waitForProperty(instance, property)
&#9;while not instance[property] do
&#9;&#9;instance.Changed:wait()
&#9;end
end





--- Begin Locals
waitForChild(game,&quot;Players&quot;)
waitForProperty(game.Players,&quot;LocalPlayer&quot;)
local player = game.Players.LocalPlayer

local currentLoadout = script.Parent
local maxNumLoadoutItems = 10

local guiBackpack = currentLoadout.Backpack

local characterChildAddedCon = nil
local keyPressCon = nil
local backpackChildCon = nil

local debounce = script.Parent.CurrentLoadout.Debounce

local waitingOnEnlarge = nil

local enlargeFactor = 1.18
local buttonSizeEnlarge = UDim2.new(1 * enlargeFactor,0,1 * enlargeFactor,0)
local buttonSizeNormal = UDim2.new(1,0,1,0)
local enlargeOverride = true

local guiTweenSpeed = 0.5

for i = 0, 9 do
&#9;game:GetService(&quot;GuiService&quot;):AddKey(tostring(i)) -- register our keys
end

local gearSlots = {}
for i = 1, maxNumLoadoutItems do
&#9;gearSlots[i] = &quot;empty&quot;
end

local inventory = {}
--- End Locals






-- Begin Functions
local function kill(prop,con,gear)
&#9;if con then con:disconnect() end
&#9;if prop == true and gear then
&#9;&#9;reorganizeLoadout(gear,false)
&#9;end
end



function centerGear()
   
   local Loadout = script.Parent.CurrentLoadout
   Loadout.Position = UDim2.new(0.45, -170, 1, -85)
&#9;loadoutChildren = Loadout:GetChildren()
&#9;local gearButtons = {}
&#9;local lastSlotAdd = nil
&#9;for i = 1,#loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;if #loadoutChildren[i]:GetChildren() &gt; 0 then
&#9;&#9;&#9;&#9;if loadoutChildren[i].Name == &quot;Slot0&quot; then 
&#9;&#9;&#9;&#9;&#9;lastSlotAdd = loadoutChildren[i]
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;table.insert(gearButtons,loadoutChildren[i])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;loadoutChildren[i].BackgroundTransparency = 1
         if script.Parent.Backpack.Visible == true then
         loadoutChildren[i].BackgroundTransparency = 0.5
         elseif script.Parent.Backpack.Visible == false then 
         loadoutChildren[i].BackgroundTransparency = 1
         end
         
&#9;&#9;end
&#9;end
&#9;if lastSlotAdd then table.insert(gearButtons,lastSlotAdd) end
&#9;
&#9;local startPos = ( 1 - (#gearButtons * 0.1) ) / 2
&#9;for i = 1,#gearButtons do&#9;&#9;&#9;
&#9;&#9;gearButtons[i]:TweenPosition(UDim2.new(startPos + ((i - 1) * 0.1),0,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quad,0.25,true)
&#9;end
end

function removeGear(gear)
&#9;local emptySlot = nil
&#9;for i = 1, #gearSlots do
&#9;&#9;if gearSlots[i] == gear and gear.Parent ~= nil then
&#9;&#9;&#9;emptySlot = i
&#9;&#9;&#9;break
&#9;&#9;end
&#9;end
&#9;if emptySlot then
&#9;&#9;if gearSlots[emptySlot].GearReference.Value then
&#9;&#9;&#9;if gearSlots[emptySlot].GearReference.Value.Parent == game.Players.LocalPlayer.Character then -- if we currently have this equipped, unequip it
&#9;&#9;&#9;&#9;gearSlots[emptySlot].GearReference.Value.Parent = game.Players.LocalPlayer.Backpack
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if gearSlots[emptySlot].GearReference.Value:IsA(&quot;HopperBin&quot;) and gearSlots[emptySlot].GearReference.Value.Active then -- this is an active hopperbin
&#9;&#9;&#9;&#9;gearSlots[emptySlot].GearReference.Value:Disable()
&#9;&#9;&#9;&#9;gearSlots[emptySlot].GearReference.Value.Active = false
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;gearSlots[emptySlot] = &quot;empty&quot;
&#9;


&#9;&#9;delay(guiTweenSpeed/2,
&#9;&#9;&#9;function()
            
&#9;&#9;&#9;&#9;gear:remove()
            if script.Parent.Backpack.Visible == false then
            centerGear()
            else
            gear:remove()
            end

&#9;&#9;&#9;end)
&#9;end
end

function insertGear(gear, addToSlot)
&#9;local pos = nil
&#9;if not addToSlot then
&#9;&#9;for i = 1, #gearSlots do
&#9;&#9;&#9;if gearSlots[i] == &quot;empty&quot; then
&#9;&#9;&#9;&#9;pos = i
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;if pos == 1 and gearSlots[1] ~= &quot;empty&quot; then gear:remove() return end -- we are currently full, can&apos;t add in
&#9;else
&#9;&#9;pos = addToSlot
&#9;&#9;-- push all gear down one slot
&#9;&#9;local start = 1
&#9;&#9;for i = 1, #gearSlots do
&#9;&#9;&#9;if gearSlots[i] == &quot;empty&quot; then
&#9;&#9;&#9;&#9;start = i
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;for i = start, pos + 1, -1 do
&#9;&#9;&#9;gearSlots[i] = gearSlots[i - 1]
&#9;&#9;&#9;if i == 10 then
&#9;&#9;&#9;&#9;gearSlots[i].SlotNumber.Text = &quot;0&quot;
&#9;&#9;&#9;&#9;gearSlots[i].SlotNumberDownShadow.Text = &quot;0&quot;
&#9;&#9;&#9;&#9;gearSlots[i].SlotNumberUpShadow.Text = &quot;0&quot;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;gearSlots[i].SlotNumber.Text = i
&#9;&#9;&#9;&#9;gearSlots[i].SlotNumberDownShadow.Text = i
&#9;&#9;&#9;&#9;gearSlots[i].SlotNumberUpShadow.Text = i
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;gearSlots[pos] = gear
&#9;if pos ~= maxNumLoadoutItems then
&#9;&#9;if(type(tostring(pos)) == &quot;string&quot;) then
&#9;&#9;&#9;local posString = tostring(pos) 
&#9;&#9;&#9;gear.SlotNumber.Text = posString
&#9;&#9;&#9;gear.SlotNumberDownShadow.Text = posString
&#9;&#9;&#9;gear.SlotNumberUpShadow.Text = posString
&#9;&#9;end
&#9;else -- tenth gear doesn&apos;t follow mathematical pattern :(
&#9;&#9;gear.SlotNumber.Text = &quot;0&quot;
&#9;&#9;gear.SlotNumberDownShadow.Text = &quot;0&quot;
&#9;&#9;gear.SlotNumberUpShadow.Text = &quot;0&quot;
&#9;end
&#9;gear.Visible = true

   if script.Parent.Backpack.Visible == false then
   centerGear()
   else
   return 
   end
&#9;local con = nil
&#9;con = gear.Kill.Changed:connect(function(prop) kill(prop,con,gear) end)
end


function reorganizeLoadout(gear, inserting, equipped, addToSlot)
&#9;if inserting then -- add in gear
&#9;&#9;insertGear(gear, addToSlot)
&#9;else
&#9;&#9;removeGear(gear)
&#9;end
&#9;if gear ~= &quot;empty&quot; then gear.ZIndex = 1 end
end

function checkToolAncestry(child,parent)
&#9;if child:FindFirstChild(&quot;RobloxBuildTool&quot;) then return end -- don&apos;t show roblox build tools
&#9;if child:IsA(&quot;Tool&quot;) or child:IsA(&quot;HopperBin&quot;) then
&#9;&#9;for i = 1, #gearSlots do
&#9;&#9;&#9;if gearSlots[i] ~= &quot;empty&quot; and gearSlots[i].GearReference.Value == child then
&#9;&#9;&#9;&#9;if parent == nil then 
&#9;&#9;&#9;&#9;&#9;gearSlots[i].Kill.Value = true
&#9;&#9;&#9;&#9;&#9;return false
&#9;&#9;&#9;&#9;elseif child.Parent == player.Character then
&#9;&#9;&#9;&#9;&#9;gearSlots[i].Selected = true
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;elseif child.Parent == player.Backpack then
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;Tool&quot;) then gearSlots[i].Selected = false end
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;gearSlots[i].Kill.Value = true
&#9;&#9;&#9;&#9;&#9;return false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function removeAllEquippedGear(physGear)
&#9;local stuff = player.Character:GetChildren()
&#9;for i = 1, #stuff do
&#9;&#9;if ( stuff[i]:IsA(&quot;Tool&quot;) or stuff[i]:IsA(&quot;HopperBin&quot;) ) and stuff[i] ~= physGear then
&#9;&#9;&#9;if stuff[i]:IsA(&quot;Tool&quot;) then stuff[i].Parent = player.Backpack end
&#9;&#9;&#9;if stuff[i]:IsA(&quot;HopperBin&quot;) then
&#9;&#9;&#9;&#9;stuff[i]:Disable()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function hopperBinSwitcher(numKey, physGear)
&#9;if not physGear then return end
&#9;
&#9;physGear:ToggleSelect()
&#9;
&#9;if gearSlots[numKey] == &quot;empty&quot; then return end
&#9;
&#9;if not physGear.Active then
&#9;&#9;gearSlots[numKey].Selected = false
&#9;&#9;normalizeButton(gearSlots[numKey])
&#9;else
&#9;&#9;gearSlots[numKey].Selected = true
&#9;&#9;enlargeButton(gearSlots[numKey])
&#9;end
end

function toolSwitcher(numKey)

&#9;if not gearSlots[numKey] then return end
&#9;local physGear = gearSlots[numKey].GearReference.Value
&#9;if physGear == nil then return end

&#9;removeAllEquippedGear(physGear) -- we don&apos;t remove this gear, as then we get a double switcheroo

&#9;local key = numKey
&#9;if numKey == 0 then key = 10 end
&#9;&#9;
&#9;for i = 1, #gearSlots do
&#9;&#9;if gearSlots[i] and gearSlots[i] ~= &quot;empty&quot; and i ~= key then
&#9;&#9;&#9;normalizeButton(gearSlots[i])
&#9;&#9;&#9;gearSlots[i].Selected = false
&#9;&#9;&#9;if gearSlots[i].GearReference.Value:IsA(&quot;HopperBin&quot;) and gearSlots[i].GearReference.Value.Active then
&#9;&#9;&#9;&#9;gearSlots[i].GearReference.Value:ToggleSelect()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;if physGear:IsA(&quot;HopperBin&quot;) then
&#9;&#9;hopperBinSwitcher(numKey,physGear)
&#9;else
&#9;&#9;if physGear.Parent == player.Character then
&#9;&#9;&#9;physGear.Parent = player.Backpack
&#9;&#9;&#9;gearSlots[numKey].Selected = false
&#9;&#9;&#9;
&#9;&#9;&#9;normalizeButton(gearSlots[numKey])
&#9;&#9;else
&#9;&#9;&#9;physGear.Parent = player.Character
&#9;&#9;&#9;gearSlots[numKey].Selected = true
&#9;&#9;&#9;
&#9;&#9;&#9;enlargeButton(gearSlots[numKey])
&#9;&#9;end
&#9;end
end


function activateGear(num)
&#9;local numKey = nil
&#9;if num == &quot;0&quot; then
&#9;&#9;numKey = 10 -- why do lua indexes have to start at 1? :(
&#9;else
&#9;&#9;numKey = tonumber(num)
&#9;end

&#9;if(numKey == nil) then return end

&#9;if gearSlots[numKey] ~= &quot;empty&quot; then
&#9;&#9;toolSwitcher(numKey)
&#9;end
end


enlargeButton = function(button)
&#9;if button.Size.Y.Scale &gt; 1 then return end
&#9;if not button.Parent then return end
&#9;if not button.Selected then return end

&#9;for i = 1, #gearSlots do
&#9;&#9;if gearSlots[i] == &quot;empty&quot; then break end
&#9;&#9;if gearSlots[i] ~= button then
&#9;&#9;&#9;normalizeButton(gearSlots[i])
&#9;&#9;end
&#9;end
&#9;
&#9;if not enlargeOverride then
&#9;&#9;waitingOnEnlarge = button
&#9;&#9;return
&#9;end

&#9;if button:IsA(&quot;ImageButton&quot;) or button:IsA(&quot;TextButton&quot;) then
&#9;&#9;button.ZIndex = 2
&#9;&#9;local centerizeX = -(buttonSizeEnlarge.X.Scale - button.Size.X.Scale)/2
&#9;&#9;local centerizeY = -(buttonSizeEnlarge.Y.Scale - button.Size.Y.Scale)/2
&#9;&#9;button:TweenSizeAndPosition(buttonSizeEnlarge,
&#9;&#9;&#9;UDim2.new(button.Position.X.Scale + centerizeX,button.Position.X.Offset,button.Position.Y.Scale + centerizeY,button.Position.Y.Offset),
&#9;&#9;&#9;Enum.EasingDirection.Out, Enum.EasingStyle.Quad,guiTweenSpeed/5,enlargeOverride)
&#9;end
end

normalizeAllButtons = function()
&#9;for i = 1, #gearSlots do
&#9;&#9;if gearSlots[i] == &quot;empty&quot; then break end
&#9;&#9;if gearSlots[i] ~= button then
&#9;&#9;&#9;normalizeButton(gearSlots[i],0.1)
&#9;&#9;end
&#9;end
end


normalizeButton = function(button, speed)
&#9;if not button then return end
&#9;if button.Size.Y.Scale &lt;= 1 then return end
&#9;if button.Selected then return end
&#9;if not button.Parent then return end
&#9;
&#9;local moveSpeed = speed
&#9;if moveSpeed == nil or type(moveSpeed) ~= &quot;number&quot; then moveSpeed = guiTweenSpeed/5 end

&#9;if button:IsA(&quot;ImageButton&quot;) or button:IsA(&quot;TextButton&quot;) then
&#9;&#9;button.ZIndex = 1
&#9;&#9;local inverseEnlarge = 1/enlargeFactor
&#9;&#9;local centerizeX = -(buttonSizeNormal.X.Scale - button.Size.X.Scale)/2
&#9;&#9;local centerizeY = -(buttonSizeNormal.Y.Scale - button.Size.Y.Scale)/2
&#9;&#9;button:TweenSizeAndPosition(buttonSizeNormal,
&#9;&#9;&#9;UDim2.new(button.Position.X.Scale + centerizeX,button.Position.X.Offset,button.Position.Y.Scale + centerizeY,button.Position.Y.Offset),
&#9;&#9;&#9;Enum.EasingDirection.Out, Enum.EasingStyle.Quad,moveSpeed,enlargeOverride)
&#9;end
end

waitForDebounce = function()
&#9;if debounce.Value then
&#9;&#9;debounce.Changed:wait()
&#9;end
end

function pointInRectangle(point,rectTopLeft,rectSize)
&#9;if point.x &gt; rectTopLeft.x and point.x &lt; (rectTopLeft.x + rectSize.x) then
&#9;&#9;if point.y &gt; rectTopLeft.y and point.y &lt; (rectTopLeft.y + rectSize.y) then
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;end
&#9;return false
end

function swapGear(gearClone,toFrame)
&#9;local toFrameChildren = toFrame:GetChildren()
&#9;if #toFrameChildren == 1 then
&#9;&#9;if toFrameChildren[1]:FindFirstChild(&quot;SlotNumber&quot;) then
&#9;&#9;
&#9;&#9;&#9;local toSlot = tonumber(toFrameChildren[1].SlotNumber.Text)
&#9;&#9;&#9;local gearCloneSlot = tonumber(gearClone.SlotNumber.Text)
&#9;&#9;&#9;if toSlot == 0 then toSlot = 10 end
&#9;&#9;&#9;if gearCloneSlot == 0 then gearCloneSlot = 10 end
&#9;&#9;&#9;
&#9;&#9;&#9;gearSlots[toSlot] = gearClone
&#9;&#9;&#9;gearSlots[gearCloneSlot] = toFrameChildren[1]
&#9;&#9;&#9;
&#9;&#9;&#9;toFrameChildren[1].SlotNumber.Text = gearClone.SlotNumber.Text
&#9;&#9;&#9;toFrameChildren[1].SlotNumberDownShadow.Text = gearClone.SlotNumber.Text
&#9;&#9;&#9;toFrameChildren[1].SlotNumberUpShadow.Text = gearClone.SlotNumber.Text
&#9;&#9;&#9;
&#9;&#9;&#9;local subString = string.sub(toFrame.Name,5)
&#9;&#9;&#9;gearClone.SlotNumber.Text = subString
&#9;&#9;&#9;gearClone.SlotNumberDownShadow.Text = subString
&#9;&#9;&#9;gearClone.SlotNumberUpShadow.Text = subString
&#9;&#9;&#9;
&#9;&#9;&#9;gearClone.Position = UDim2.new(gearClone.Position.X.Scale,0,gearClone.Position.Y.Scale,0)
&#9;&#9;&#9;toFrameChildren[1].Position = UDim2.new(toFrameChildren[1].Position.X.Scale,0,toFrameChildren[1].Position.Y.Scale,0)
&#9;&#9;&#9;
&#9;&#9;&#9;toFrameChildren[1].Parent = gearClone.Parent
&#9;&#9;&#9;gearClone.Parent = toFrame
&#9;&#9;end
&#9;else
&#9;&#9;local slotNum = tonumber(gearClone.SlotNumber.Text)
&#9;&#9;if slotNum == 0 then slotNum = 10 end
&#9;&#9;gearSlots[slotNum] = &quot;empty&quot; -- reset this gear slot
&#9;&#9;
&#9;&#9;local subString = string.sub(toFrame.Name,5)
&#9;&#9;gearClone.SlotNumber.Text = subString
&#9;&#9;gearClone.SlotNumberDownShadow.Text = subString
&#9;&#9;gearClone.SlotNumberUpShadow.Text = subString
&#9;&#9;&#9;
&#9;&#9;local toSlotNum = tonumber(gearClone.SlotNumber.Text)
&#9;&#9;if toSlotNum == 0 then toSlotNum = 10 end
&#9;&#9;gearSlots[toSlotNum] = gearClone
&#9;&#9;gearClone.Position = UDim2.new(gearClone.Position.X.Scale,0,gearClone.Position.Y.Scale,0)
&#9;&#9;gearClone.Parent = toFrame
&#9;end
end

function resolveDrag(gearClone,x,y)
&#9;local mousePoint = Vector2.new(x,y)
&#9;
&#9;local frame = gearClone.Parent
&#9;local frames = frame.Parent:GetChildren()
&#9;
&#9;for i = 1, #frames do
&#9;&#9;if frames[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;if pointInRectangle(mousePoint, frames[i].AbsolutePosition,frames[i].AbsoluteSize) then
&#9;&#9;&#9;&#9;swapGear(gearClone,frames[i])
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;if x &lt; frame.AbsolutePosition.x or x &gt; ( frame.AbsolutePosition.x + frame.AbsoluteSize.x ) then
&#9;&#9;reorganizeLoadout(gearClone,false)
&#9;&#9;return false
&#9;elseif y &lt; frame.AbsolutePosition.y or y &gt; ( frame.AbsolutePosition.y + frame.AbsoluteSize.y ) then
&#9;&#9;reorganizeLoadout(gearClone,false)
&#9;&#9;return false
&#9;else
&#9;&#9;gearClone.Position = dragBeginPos
&#9;&#9;return -1
&#9;end
end

function unequipAllItems(dontEquipThis)
&#9;for i = 1, #gearSlots do
&#9;&#9;if gearSlots[i] == &quot;empty&quot; then break end
&#9;&#9;if gearSlots[i].GearReference.Value ~= dontEquipThis then
&#9;&#9;&#9;if gearSlots[i].GearReference.Value:IsA(&quot;HopperBin&quot;) then
&#9;&#9;&#9;&#9;gearSlots[i].GearReference.Value:Disable()
&#9;&#9;&#9;elseif gearSlots[i].GearReference.Value:IsA(&quot;Tool&quot;) then
&#9;&#9;&#9;&#9;gearSlots[i].GearReference.Value.Parent = game.Players.LocalPlayer.Backpack
&#9;&#9;&#9;end
&#9;&#9;&#9;gearSlots[i].Selected = false
&#9;&#9;end
&#9;end
end

local addingPlayerChild = function(child, equipped, addToSlot, inventoryGearButton)
&#9;waitForDebounce()
&#9;debounce.Value = true
&#9;
&#9;if child:FindFirstChild(&quot;RobloxBuildTool&quot;) then debounce.Value = false return end -- don&apos;t show roblox build tools
&#9;if not child:IsA(&quot;Tool&quot;) then
&#9;&#9;if not child:IsA(&quot;HopperBin&quot;) then
&#9;&#9;&#9;debounce.Value = false 
&#9;&#9;&#9;return  -- we don&apos;t care about anything besides tools (sigh...)
&#9;&#9;end
&#9;end
&#9;
&#9;if not addToSlot then
&#9;&#9;for i = 1, #gearSlots do
&#9;&#9;&#9;if gearSlots[i] ~= &quot;empty&quot; and gearSlots[i].GearReference.Value == child then -- we already have gear, do nothing
&#9;&#9;&#9;&#9;debounce.Value = false
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;

&#9;local gearClone = currentLoadout.CurrentLoadout.TempSlot:clone()
&#9;gearClone.Name = child.Name
&#9;gearClone.GearImage.Image = child.TextureId
&#9;if gearClone.GearImage.Image == &quot;&quot; then
&#9;&#9;gearClone.GearText.Text = child.Name
&#9;end
&#9;gearClone.GearReference.Value = child

&#9;

&#9;local slotToMod = -1
&#9;
&#9;if not addToSlot then
&#9;&#9;for i = 1, #gearSlots do
&#9;&#9;&#9;if gearSlots[i] == &quot;empty&quot; then
&#9;&#9;&#9;&#9;slotToMod = i
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;slotToMod = addToSlot
&#9;end
&#9;
&#9;if slotToMod == - 1 then debounce.Value = false print(&quot;no slots!&quot;) return end -- No available slot to add in!
&#9;
&#9;local slotNum = slotToMod % 10
&#9;local parent = currentLoadout.CurrentLoadout:FindFirstChild(&quot;Slot&quot;..tostring(slotNum))
&#9;gearClone.Parent = parent
&#9;
&#9;if inventoryGearButton then
&#9;&#9;local absolutePositionFinal = inventoryGearButton.AbsolutePosition
&#9;&#9;local currentAbsolutePosition = gearClone.AbsolutePosition
&#9;&#9;local diff = absolutePositionFinal - currentAbsolutePosition
&#9;&#9;gearClone.Position = UDim2.new(gearClone.Position.X.Scale,diff.x,gearClone.Position.Y.Scale,diff.y)
&#9;&#9;gearClone.ZIndex = 4
&#9;end
&#9;
&#9;if addToSlot then
&#9;&#9;reorganizeLoadout(gearClone, true, equipped, addToSlot)
&#9;else
&#9;&#9;reorganizeLoadout(gearClone, true)
&#9;end

&#9;if gearClone.Parent == nil then debounce.Value = false return end -- couldn&apos;t fit in (hopper is full!)

&#9;if equipped then
&#9;&#9;gearClone.Selected = true
&#9;&#9;unequipAllItems(child)
&#9;&#9;delay(guiTweenSpeed + 0.01,function() -- if our gear is equipped, we will want to enlarge it when done moving
&#9;&#9;&#9;if (gearClone.GearReference.Value:IsA(&quot;Tool&quot;) and gearClone.GearReference.Value.Parent == player.Character) or
&#9;&#9;&#9;&#9;(gearClone.GearReference.Value:IsA(&quot;HopperBin&quot;) and gearClone.GearReference.Value.Active == true) then
&#9;&#9;&#9;&#9;&#9;enlargeButton(gearClone)
&#9;&#9;&#9;end
&#9;&#9;end) 
&#9;end

&#9;local dragBeginPos = nil
&#9;local clickCon, buttonDeleteCon, mouseEnterCon, mouseLeaveCon, dragStop, dragBegin = nil
&#9;clickCon = gearClone.MouseButton1Click:connect(function() if not gearClone.Draggable then activateGear(gearClone.SlotNumber.Text) end end)
&#9;mouseEnterCon = gearClone.MouseEnter:connect(function()
&#9;&#9;if guiBackpack.Visible then
&#9;&#9;&#9;gearClone.Draggable = true
&#9;&#9;end
&#9;end)
&#9;dragBegin = gearClone.DragBegin:connect(function(pos)
&#9;&#9;dragBeginPos = pos
&#9;&#9;gearClone.ZIndex = 7
&#9;&#9;local children = gearClone:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;if children[i]:IsA(&quot;TextLabel&quot;) then
&#9;&#9;&#9;&#9;if string.find(children[i].Name,&quot;Shadow&quot;) then
&#9;&#9;&#9;&#9;&#9;children[i].ZIndex = 8
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;children[i].ZIndex = 9
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;elseif children[i]:IsA(&quot;Frame&quot;) or children[i]:IsA(&quot;ImageLabel&quot;) then
&#9;&#9;&#9;&#9; children[i].ZIndex = 7
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;dragStop = gearClone.DragStopped:connect(function(x,y)
&#9;&#9;if gearClone.Selected then
&#9;&#9;&#9;gearClone.ZIndex = 2
&#9;&#9;else
&#9;&#9;&#9;gearClone.ZIndex = 1
&#9;&#9;end
&#9;&#9;local children = gearClone:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;if children[i]:IsA(&quot;TextLabel&quot;) then
&#9;&#9;&#9;&#9;if string.find(children[i].Name,&quot;Shadow&quot;) then
&#9;&#9;&#9;&#9;&#9;children[i].ZIndex = 3
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;children[i].ZIndex = 4
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;elseif children[i]:IsA(&quot;Frame&quot;) or children[i]:IsA(&quot;ImageLabel&quot;) then
&#9;&#9;&#9;&#9; children[i].ZIndex = 2
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;resolveDrag(gearClone,x,y)
&#9;end)
&#9;mouseLeaveCon = gearClone.MouseLeave:connect(function()
&#9;&#9;gearClone.Draggable = false
&#9;end)
&#9;buttonDeleteCon = gearClone.AncestryChanged:connect(function()
&#9;&#9;&#9;if gearClone.Parent and gearClone.Parent.Parent == currentLoadout then return end
&#9;&#9;&#9;if clickCon then clickCon:disconnect() end
&#9;&#9;&#9;if buttonDeleteCon then buttonDeleteCon:disconnect() end
&#9;&#9;&#9;if mouseEnterCon then mouseEnterCon:disconnect() end
&#9;&#9;&#9;if mouseLeaveCon then mouseLeaveCon:disconnect() end
&#9;&#9;&#9;if dragStop then dragStop:disconnect() end
&#9;&#9;&#9;if dragBegin then dragBegin:disconnect() end
&#9;end) -- this probably isn&apos;t necessary since objects are being deleted (probably), but this might still leak just in case
&#9;
&#9;local childCon = nil
&#9;local childChangeCon = nil
&#9;childCon = child.AncestryChanged:connect(function(newChild,parent)
&#9;&#9;if not checkToolAncestry(newChild,parent) then
&#9;&#9;&#9;if childCon then childCon:disconnect() end
&#9;&#9;&#9;if childChangeCon then childChangeCon:disconnect() end
&#9;&#9;&#9;removeFromInventory(child)
&#9;&#9;elseif parent == game.Players.LocalPlayer.Backpack then
&#9;&#9;&#9;normalizeButton(gearClone)
&#9;&#9;end
&#9;end)
&#9;
&#9;childChangeCon = child.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Name&quot; then
&#9;&#9;&#9;if gearClone and gearClone.GearImage.Image == &quot;&quot; then
&#9;&#9;&#9;&#9;gearClone.GearText.Text = child.Name
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;
&#9;debounce.Value = false
&#9;
end

function addToInventory(child)
&#9;if not child:IsA(&quot;Tool&quot;) or not child:IsA(&quot;HopperBin&quot;) then return end
&#9;
&#9;local slot = nil
&#9;for i = 1, #inventory do
&#9;&#9;if inventory[i] and inventory[i] == child then return end
&#9;&#9;if not inventory[i] then slot = i end
&#9;end
&#9;if slot then 
&#9;&#9;inventory[slot] = child 
&#9;elseif #inventory &lt; 1 then
&#9;&#9;inventory[1] = child
&#9;else
&#9;&#9;inventory[#inventory + 1] = child
&#9;end
end

function removeFromInventory(child)
&#9;for i = 1, #inventory do
&#9;&#9;if inventory[i] == child then
&#9;&#9;&#9;table.remove(inventory,i)
&#9;&#9;&#9;inventory[i] = nil
&#9;&#9;end
&#9;end
end

-- these next two functions are used for safe guarding 
-- when we are waiting for character to come back after dying
function activateLoadout()
&#9;keyPressCon = game:GetService(&quot;GuiService&quot;).KeyPressed:connect(function(key) activateGear(key) end)
&#9;currentLoadout.Visible = true
end

function deactivateLoadout()
&#9;if keyPressCon then keyPressCon:disconnect() end
&#9;currentLoadout.CurrentLoadout.Visible = false
end

function setupBackpackListener()
&#9;if backpackChildCon then backpackChildCon:disconnect() end
&#9;backpackChildCon = player.Backpack.ChildAdded:connect(function(child)
&#9;&#9;addingPlayerChild(child)
&#9;&#9;addToInventory(child)
&#9;end)
end

function playerCharacterChildAdded(child)
&#9;addingPlayerChild(child,true)
&#9;addToInventory(child)
end
-- End Functions






-- Begin Script
wait() -- let stuff initialize incase this is first heartbeat...
&#9;
waitForChild(player,&quot;Backpack&quot;)
local backpackChildren = player.Backpack:GetChildren()
local size = math.min(10,#backpackChildren)
for i = 1, size do
&#9;addingPlayerChild(backpackChildren[i],false)
end
setupBackpackListener()

waitForProperty(player,&quot;Character&quot;)
for i,v in ipairs(player.Character:GetChildren()) do
&#9;playerCharacterChildAdded(v)
end
characterChildAddedCon = player.Character.ChildAdded:connect(function(child) playerCharacterChildAdded(child) end)

waitForChild(player.Character,&quot;Humanoid&quot;)
humanoidDiedCon = player.Character.Humanoid.Died:connect(function() deactivateLoadout() end)

player.CharacterRemoving:connect(function()
&#9;if characterChildAddedCon then characterChildAddedCon:disconnect() end
&#9;if humanoidDiedCon then humanoidDiedCon:disconnect() end
&#9;if backpackChildCon then backpackChildCon:disconnect() end
&#9;deactivateLoadout()
end)
player.CharacterAdded:connect(function()
&#9;player = game.Players.LocalPlayer -- make sure we are still looking at the correct character
&#9;
&#9;for i = 1, #gearSlots do
&#9;&#9;if gearSlots[i] ~= &quot;empty&quot; then
&#9;&#9;&#9;gearSlots[i].Parent = nil
&#9;&#9;&#9;gearSlots[i] = &quot;empty&quot;
&#9;&#9;end
&#9;end

&#9;local backpackChildren = player.Backpack:GetChildren()
&#9;local size = math.min(10,#backpackChildren)
&#9;for i = 1, size do
&#9;&#9;addingPlayerChild(backpackChildren[i])
&#9;end
&#9;
&#9;setupBackpackListener()
&#9;
&#9;characterChildAddedCon = 
&#9;&#9;player.Character.ChildAdded:connect(function(child)
&#9;&#9;&#9;addingPlayerChild(child,true)
&#9;&#9;end)
&#9;&#9;
&#9;waitForChild(player.Character,&quot;Humanoid&quot;)
&#9;humanoidDiedCon = 
&#9;&#9;player.Character.Humanoid.Died:connect(function()
&#9;&#9;&#9;deactivateLoadout()
&#9;&#9;end)
&#9;activateLoadout()
end)

script.Parent.ControlFrame.BackpackButton.MouseButton1Click:connect(function()
centerGear()
end)

waitForChild(guiBackpack,&quot;SwapSlot&quot;)
guiBackpack.SwapSlot.Changed:connect(function()
&#9;if guiBackpack.SwapSlot.Value then
&#9;&#9;local swapSlot = guiBackpack.SwapSlot
&#9;&#9;local pos = swapSlot.Slot.Value
&#9;&#9;if pos == 0 then pos = 10 end
&#9;&#9;if gearSlots[pos] then
&#9;&#9;&#9;reorganizeLoadout(gearSlots[pos],false)
&#9;&#9;end
&#9;&#9;if swapSlot.GearButton.Value then
&#9;&#9;&#9;addingPlayerChild(swapSlot.GearButton.Value.GearReference.Value,false,pos)
&#9;&#9;end
&#9;&#9;guiBackpack.SwapSlot.Value = false
&#9;end
end)

keyPressCon = game:GetService(&quot;GuiService&quot;).KeyPressed:connect(function(key) activateGear(key) end)</ProtectedString>
				</Properties>
			</Item>
			<Item class="Frame" referent="RBX5">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">ControlFrame</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="NotificationBox" referent="RBX6">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">NotificationBox</string>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>-200</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>200</XO>
							<YS>0.419999987</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX7">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">BackpackMaker</string>
					<ProtectedString name="Source">local BackpackButton = Instance.new(&quot;ImageButton&quot;)
BackpackButton.Visible = true
BackpackButton.Name = &quot;BackpackButton&quot;
BackpackButton.BackgroundTransparency = 1
BackpackButton.Image = &quot;rbxasset://textures/ui/backpackButton.png&quot;
BackpackButton.Position = UDim2.new(0.5, -195, 1, -30)
BackpackButton.Size = UDim2.new(0,107,0,26)
BackpackButton.Parent = script.Parent.ControlFrame

-- this makes the backpackbutton without making the backpack D I  E --</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX8">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">BackpackManager</string>
					<ProtectedString name="Source">-- This script manages context switches in the backpack (Gear to Wardrobe, etc.) and player state changes.  Also manages global functions across different tabs (currently only search)
print(&quot;mamanger&quot;)
print(&quot;made it past gui version check&quot;)

-- basic functions
local function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
&#9;return instance:FindFirstChild(name)
end
local function waitForProperty(instance, property)
&#9;while not instance[property] do
&#9;&#9;instance.Changed:wait()
&#9;end
end

-- don&apos;t do anything if we are in an empty game
waitForChild(game,&quot;Players&quot;)
if #game.Players:GetChildren() &lt; 1 then
&#9;game.Players.ChildAdded:wait()
end
-- make sure everything is loaded in before we do anything
-- get our local player
waitForProperty(game.Players,&quot;LocalPlayer&quot;)
local player = game.Players.LocalPlayer



------------------------ Locals ------------------------------
local backpack = script.Parent.Backpack
waitForChild(backpack,&quot;Gear&quot;)

local screen = script.Parent
assert(screen:IsA(&quot;ScreenGui&quot;))

waitForChild(backpack, &quot;Tabs&quot;)
waitForChild(backpack.Tabs, &quot;CloseButton&quot;)
local closeButton = backpack.Tabs.CloseButton

waitForChild(backpack.Tabs, &quot;InventoryButton&quot;)
local inventoryButton = backpack.Tabs.InventoryButton
waitForChild(backpack.Parent,&quot;ControlFrame&quot;)
local backpackButton = waitForChild(backpack.Parent.ControlFrame,&quot;BackpackButton&quot;)
local currentTab = &quot;gear&quot;

local searchFrame = waitForChild(backpack,&quot;SearchFrame&quot;)
waitForChild(backpack.SearchFrame,&quot;SearchBoxFrame&quot;)
local searchBox = waitForChild(backpack.SearchFrame.SearchBoxFrame,&quot;SearchBox&quot;)
local searchButton = waitForChild(backpack.SearchFrame,&quot;SearchButton&quot;)
local resetButton = waitForChild(backpack.SearchFrame,&quot;ResetButton&quot;)

local canToggle = true
local readyForNextEvent = true
local backpackIsOpen = false
local active = true

local humanoidDiedCon = nil

local guiTweenSpeed = 0.25 -- how quickly we open/close the backpack

local searchDefaultText = &quot;Search...&quot;
local tilde = &quot;~&quot;
local backquote = &quot;`&quot;

------------------------ End Locals ---------------------------


---------------------------------------- Public Event Setup ----------------------------------------

function createPublicEvent(eventName)
&#9;assert(eventName, &quot;eventName is nil&quot;)
&#9;assert(tostring(eventName),&quot;eventName is not a string&quot;)
&#9;
&#9;local newEvent = Instance.new(&quot;BindableEvent&quot;)
&#9;newEvent.Name = tostring(eventName)
&#9;newEvent.Parent = script

&#9;return newEvent
end

function createPublicFunction(funcName, invokeFunc)
&#9;assert(funcName, &quot;funcName is nil&quot;)
&#9;assert(tostring(funcName), &quot;funcName is not a string&quot;)
&#9;assert(invokeFunc, &quot;invokeFunc is nil&quot;)
&#9;assert(type(invokeFunc) == &quot;function&quot;, &quot;invokeFunc should be of type &apos;function&apos;&quot;)
&#9;
&#9;local newFunction = Instance.new(&quot;BindableFunction&quot;)
&#9;newFunction.Name = tostring(funcName)
&#9;newFunction.OnInvoke = invokeFunc
&#9;newFunction.Parent = script

&#9;return newFunction
end

-- Events 
local resizeEvent = createPublicEvent(&quot;ResizeEvent&quot;)
local backpackOpenEvent = createPublicEvent(&quot;BackpackOpenEvent&quot;)
local backpackCloseEvent = createPublicEvent(&quot;BackpackCloseEvent&quot;)
local tabClickedEvent = createPublicEvent(&quot;TabClickedEvent&quot;)
local searchRequestedEvent = createPublicEvent(&quot;SearchRequestedEvent&quot;)
---------------------------------------- End Public Event Setup ----------------------------------------



--------------------------- Internal Functions ----------------------------------------

function deactivateBackpack()
&#9;backpack.Visible = false
&#9;active = false
end

function activateBackpack()
&#9;initHumanoidDiedConnections()&#9;&#9;
&#9;active = true
&#9;backpack.Visible = backpackIsOpen
end

function initHumanoidDiedConnections()&#9;&#9;&#9;
&#9;if humanoidDiedCon then 
&#9;&#9;humanoidDiedCon:disconnect()
&#9;end
&#9;waitForProperty(game.Players.LocalPlayer,&quot;Character&quot;)
&#9;waitForChild(game.Players.LocalPlayer.Character,&quot;Humanoid&quot;)
&#9;humanoidDiedCon = game.Players.LocalPlayer.Character.Humanoid.Died:connect(deactivateBackpack)
end

function resizeGrid()
   local backpackItems = {}
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if not v:FindFirstChild(&quot;RobloxBuildTool&quot;) then
&#9;&#9;&#9;if not buttons[v] then
&#9;&#9;&#9;&#9;local buttonClone = gearButton:clone()
&#9;&#9;&#9;&#9;buttonClone.Parent = grid.ScrollingFrame
&#9;&#9;&#9;&#9;buttonClone.Visible = true
&#9;&#9;&#9;&#9;buttonClone.Image = v.TextureId
&#9;&#9;&#9;&#9;if buttonClone.Image == &quot;&quot; then
&#9;&#9;&#9;&#9;&#9;buttonClone.GearText.Text = v.Name
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;buttonClone.GearReference.Value = v
&#9;&#9;&#9;&#9;buttonClone.Draggable = true 
&#9;&#9;&#9;&#9;buttons[v] = buttonClone
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local unequipMenu = getGearContextMenu()
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;unequipMenu.Visible = false
&#9;&#9;&#9;&#9;unequipMenu.Parent = buttonClone
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local beginPos = nil
&#9;&#9;&#9;&#9;buttonClone.DragBegin:connect(function(value)
&#9;&#9;&#9;&#9;&#9;buttonClone.ZIndex = 9
&#9;&#9;&#9;&#9;&#9;beginPos = value
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;buttonClone.DragStopped:connect(function(x,y)
&#9;&#9;&#9;&#9;&#9;if beginPos ~= buttonClone.Position then
&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.ZIndex = 1
&#9;&#9;&#9;&#9;&#9;&#9;if not checkForSwap(buttonClone,x,y) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone:TweenPosition(beginPos,Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.5, true)
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.Position = beginPos
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end&#9;
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;mouseEnterCons[buttonClone] = buttonClone.MouseEnter:connect(function() previewGear(buttonClone) end)
&#9;&#9;&#9;&#9;mouseClickCons[buttonClone] = buttonClone.MouseButton1Click:connect(function() buttonClick(buttonClone) end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function spreadOutGear(loadoutChildren)
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;local slot = tonumber(string.sub(loadoutChildren[i].Name,5))
&#9;&#9;&#9;if slot == 0 then slot = 10 end
&#9;&#9;&#9;loadoutChildren[i]:TweenPosition(UDim2.new((slot - 1)/10,0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.25, true)
&#9;&#9;end
&#9;end
end

function resize()
&#9;local size = 0
   local gearPreview = script.Parent.Backpack.Gear.GearPreview
&#9;if gearPreview.AbsoluteSize.Y &gt; gearPreview.AbsoluteSize.X then
&#9;&#9;size = gearPreview.AbsoluteSize.X * 0.75
&#9;else
&#9;&#9;size = gearPreview.AbsoluteSize.Y * 0.75
&#9;end

&#9;gearPreview.GearImage.Size = UDim2.new(0,size,0,size)
&#9;gearPreview.GearImage.Position = UDim2.new(0,gearPreview.AbsoluteSize.X/2 - size/2,0.75,-size)
&#9;
&#9;resizeGrid()
end

function openCloseBackpack()
&#9;if backpack.Visible == true then
&#9;&#9;updateGridActive()
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;loadoutChildren = currentLoadout:GetChildren()
&#9;&#9;&#9;&#9;for i = 1, #loadoutChildren do
&#9;&#9;&#9;&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;loadoutChildren[i].BackgroundTransparency = 0.5
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;spreadOutGear(loadoutChildren)

&#9;&#9;--[[backpackButton.Selected = true
&#9;&#9;backpack:TweenSizeAndPosition(UDim2.new(0.55, 0, 0.6, 0),UDim2.new(0.225, 0, 0.2, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, guiTweenSpeed/2, true)
&#9;&#9;delay(guiTweenSpeed/2 + 0.01,
&#9;&#9;&#9;function()--]]
&#9;&#9;&#9;&#9;local children = backpack:getChildren()
&#9;&#9;&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;&#9;&#9;if children[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;children[i].Visible = true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;resizeGrid()
&#9;&#9;&#9;&#9;resize()
&#9;&#9;&#9;&#9;openCloseDebounce = false


&#9;end
end

function centerGear()
   
   local Loadout = script.Parent.CurrentLoadout
   Loadout.Position = UDim2.new(0.45, -170, 1, -85)
&#9;loadoutChildren = Loadout:GetChildren()
&#9;local gearButtons = {}
&#9;local lastSlotAdd = nil
&#9;for i = 1,#loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;if #loadoutChildren[i]:GetChildren() &gt; 0 then
&#9;&#9;&#9;&#9;if loadoutChildren[i].Name == &quot;Slot0&quot; then 
&#9;&#9;&#9;&#9;&#9;lastSlotAdd = loadoutChildren[i]
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;table.insert(gearButtons,loadoutChildren[i])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;loadoutChildren[i].BackgroundTransparency = 1
         
&#9;&#9;end
&#9;end
&#9;if lastSlotAdd then table.insert(gearButtons,lastSlotAdd) end
&#9;
&#9;local startPos = ( 1 - (#gearButtons * 0.1) ) / 2
&#9;for i = 1,#gearButtons do&#9;&#9;&#9;
&#9;&#9;gearButtons[i]:TweenPosition(UDim2.new(startPos + ((i - 1) * 0.1),0,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quad,0.25,true)
&#9;end
end

local hideBackpack = function()
&#9;backpackIsOpen = false
&#9;readyForNextEvent = false
&#9;backpackButton.Selected = false
&#9;resetSearch()
&#9;backpackCloseEvent:Fire(currentTab)
&#9;backpack.Tabs.Visible = false
&#9;searchFrame.Visible = false
   loadoutChildren = script.Parent.CurrentLoadout:GetChildren()
   for i = 1,#loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;if #loadoutChildren[i]:GetChildren() &gt; 0 then
&#9;&#9;&#9;&#9;if loadoutChildren[i].Name == &quot;Slot0&quot; then 
&#9;&#9;&#9;&#9;&#9;lastSlotAdd = loadoutChildren[i]
   end
end

   loadoutChildren[i].BackgroundTransparency = 1
   centerGear()
   end
&#9;backpack:TweenSizeAndPosition(UDim2.new(0,0,0,0),UDim2.new(0.5,0,0.5,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, guiTweenSpeed, true,
&#9;&#9;function()
&#9;&#9;&#9;game.GuiService:RemoveCenterDialog(backpack)
&#9;&#9;&#9;backpack.Visible = false
&#9;&#9;&#9;backpackButton.Selected = false
&#9;&#9;end)
&#9;delay(guiTweenSpeed,function()
&#9;&#9;game.GuiService:RemoveCenterDialog(backpack)
&#9;&#9;backpack.Visible = false
&#9;&#9;backpackButton.Selected = false
&#9;&#9;canToggle = true
&#9;end)
end

end

function showBackpack()
&#9;game.GuiService:AddCenterDialog(backpack, Enum.CenterDialogType.PlayerInitiatedDialog, 
&#9;&#9;function()
&#9;&#9;&#9;backpack.Visible = true
&#9;&#9;&#9;backpackButton.Selected = true
&#9;&#9;end,
&#9;&#9;function()
&#9;&#9;&#9;backpack.Visible = false
&#9;&#9;&#9;backpackButton.Selected = false
&#9;end)
&#9;backpack.Visible = true
&#9;backpackButton.Selected = true
&#9;backpack:TweenSizeAndPosition(UDim2.new(0.55, 0, 0.76, 0),UDim2.new(0.225, 0, 0.09, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, guiTweenSpeed, true)
&#9;delay(guiTweenSpeed,function()
      openCloseBackpack()
&#9;&#9;backpack.Tabs.Visible = true
&#9;&#9;searchFrame.Visible = true
&#9;&#9;backpackOpenEvent:Fire(currentTab)
&#9;&#9;canToggle = true
&#9;end)
end

function spreadOutGear(loadoutChildren)
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;local slot = tonumber(string.sub(loadoutChildren[i].Name,5))
&#9;&#9;&#9;if slot == 0 then slot = 10 end
&#9;&#9;&#9;loadoutChildren[i]:TweenPosition(UDim2.new((slot - 1)/10,0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.25, true)
&#9;&#9;end
&#9;end
end

function toggleBackpack()
&#9;if not game.Players.LocalPlayer then return end
&#9;if not game.Players.LocalPlayer[&quot;Character&quot;] then return end

&#9;if not canToggle then return end
&#9;if not readyForNextEvent then return end
&#9;readyForNextEvent = false
&#9;canToggle = false
&#9;
&#9;backpackIsOpen = not backpackIsOpen

&#9;if backpackIsOpen then
      
&#9;&#9;showBackpack()
 
&#9;else
&#9;&#9;backpackButton.Selected = false
&#9;&#9;closeBackpack()
&#9;end
end

function updateGridActive()
   local backpackItems = {}
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if buttons[v] then
&#9;&#9;&#9;local gear = nil
&#9;&#9;&#9;local gearRef = buttons[v]:FindFirstChild(&quot;GearReference&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;if gearRef then gear = gearRef.Value end
&#9;&#9;&#9;
&#9;&#9;&#9;if not gear then
&#9;&#9;&#9;&#9;buttons[v].Active = false
&#9;&#9;&#9;elseif inLoadout(gear) then
&#9;&#9;&#9;&#9;buttons[v].Active = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;buttons[v].Active = true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function openCloseBackpack()
&#9;
&#9;if backpack.Visible == true then
&#9;&#9;updateGridActive()
            local currentLoadout = script.Parent.CurrentLoadout
&#9;&#9;&#9;&#9;backpack.Visible = true
&#9;&#9;&#9;&#9;loadoutChildren = currentLoadout:GetChildren()
&#9;&#9;&#9;&#9;for i = 1, #loadoutChildren do
&#9;&#9;&#9;&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;loadoutChildren[i].BackgroundTransparency = 0.5
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;spreadOutGear(loadoutChildren)


&#9;&#9;backpackButton.Selected = true
&#9;&#9;backpack:TweenSizeAndPosition(UDim2.new(0.55, 0, 0.6, 0),UDim2.new(0.225, 0, 0.2, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, guiTweenSpeed/2, true)
&#9;&#9;delay(guiTweenSpeed/2 + 0.01,
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;local children = backpack:getChildren()
&#9;&#9;&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;&#9;&#9;if children[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;children[i].Visible = true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;resizeGrid()
&#9;&#9;&#9;&#9;resize()
&#9;&#9;&#9;&#9;openCloseDebounce = false
           end)

&#9;else
&#9;&#9;backpackButton.Selected = false
&#9;&#9;local children = backpack:getChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;if children[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;children[i].Visible = false
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;loadoutChildren = currentLoadout:GetChildren()
&#9;&#9;for i = 1, #loadoutChildren do
&#9;&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;loadoutChildren[i].BackgroundTransparency = 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;centerGear(loadoutChildren)
&#9;
&#9;&#9;backpack:TweenSizeAndPosition(UDim2.new(0,0,0,0),UDim2.new(0.5,0,0.5,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, guiTweenSpeed/2, true)
&#9;&#9;delay(guiTweenSpeed/2 + 0.01,
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;backpack.Visible = visible
&#9;&#9;&#9;&#9;resizeGrid()
&#9;&#9;&#9;&#9;resize()
&#9;&#9;&#9;&#9;pcall(function() game.GuiService:RemoveCenterDialog(backpack) end)
&#9;&#9;&#9;&#9;openCloseDebounce = false
&#9;&#9;&#9;end)
&#9;end
end

function closeBackpack()
&#9;if backpackIsOpen then
&#9;&#9;toggleBackpack()
&#9;end
end

function setSelected(tab)
&#9;assert(tab)
&#9;assert(tab:IsA(&quot;TextButton&quot;))
&#9;
&#9;tab.BackgroundColor3 = Color3.new(1,1,1)
&#9;tab.TextColor3 = Color3.new(0,0,0)
&#9;tab.Selected = true
&#9;tab.ZIndex = 3
end

function setUnselected(tab)
&#9;assert(tab)
&#9;assert(tab:IsA(&quot;TextButton&quot;))
&#9;
&#9;tab.BackgroundColor3 = Color3.new(0,0,0)
&#9;tab.TextColor3 = Color3.new(1,1,1)
&#9;tab.Selected = false
&#9;tab.ZIndex = 1
end

function updateTabGui(selectedTab)
&#9;assert(selectedTab)
&#9;
&#9;if selectedTab == &quot;gear&quot; then
&#9;&#9;setSelected(inventoryButton)
&#9;&#9;setUnselected(wardrobeButton)
&#9;elseif selectedTab == &quot;wardrobe&quot; then
&#9;&#9;setSelected(wardrobeButton)
&#9;&#9;setUnselected(inventoryButton)
&#9;end
end

function mouseLeaveTab(button)
&#9;assert(button)
&#9;assert(button:IsA(&quot;TextButton&quot;))
&#9;
&#9;if button.Selected then return end
&#9;
&#9;button.BackgroundColor3 = Color3.new(0,0,0)
end

function mouseOverTab(button)
&#9;assert(button)
&#9;assert(button:IsA(&quot;TextButton&quot;))
&#9;
&#9;if button.Selected then return end
&#9;
&#9;button.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
end

function newTabClicked(tabName)
&#9;assert(tabName)
&#9;tabName = string.lower(tabName)
&#9;currentTab = tabName
&#9;
&#9;updateTabGui(tabName)
&#9;tabClickedEvent:Fire(tabName)
&#9;resetSearch()
end

function trim(s)
  return (s:gsub(&quot;^%s*(.-)%s*$&quot;, &quot;%1&quot;))
end

function splitByWhitespace(text)
&#9;if type(text) ~= &quot;string&quot; then return nil end
&#9;
&#9;local terms = {}
&#9;for token in string.gmatch(text, &quot;[^%s]+&quot;) do
&#9;   if string.len(token) &gt; 0 then
&#9;&#9;&#9;table.insert(terms,token)
&#9;   end
&#9;end
&#9;return terms
end

function resetSearchBoxGui()
&#9;resetButton.Visible = false
&#9;searchBox.Text = searchDefaultText
end

function doSearch()
&#9;local searchText = searchBox.Text
&#9;if searchText == &quot;&quot; then
&#9;&#9;resetSearch()
&#9;&#9;return
&#9;end
&#9;searchText = trim(searchText)
&#9;resetButton.Visible = true
&#9;termTable = splitByWhitespace(searchText)
&#9;searchRequestedEvent:Fire(searchText) -- todo: replace this with termtable when table passing is possible
end

function resetSearch()
&#9;resetSearchBoxGui()
&#9;searchRequestedEvent:Fire()
end

local backpackReady = function()
&#9;readyForNextEvent = true
end

--------------------------- End Internal Functions -------------------------------------


------------------------------ Public Functions Setup -------------------------------------
createPublicFunction(&quot;CloseBackpack&quot;, hideBackpack)
createPublicFunction(&quot;BackpackReady&quot;, backpackReady)
------------------------------ End Public Functions Setup ---------------------------------


------------------------ Connections/Script Main -------------------------------------------

inventoryButton.MouseButton1Click:connect(function() newTabClicked(&quot;gear&quot;) end)
inventoryButton.MouseEnter:connect(function() mouseOverTab(inventoryButton) end)
inventoryButton.MouseLeave:connect(function() mouseLeaveTab(inventoryButton) end)


closeButton.MouseButton1Click:connect(hideBackpack)

screen.Changed:connect(function(prop)
&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;resizeEvent:Fire(screen.AbsoluteSize)
&#9;end
end)

-- GuiService key setup
local testkey = &quot;&apos;&quot;
game:GetService(&quot;GuiService&quot;):AddKey(testkey)
game:GetService(&quot;GuiService&quot;):AddKey(tilde)
game:GetService(&quot;GuiService&quot;).KeyPressed:connect(function(key)
&#9;if not active then return end
&#9;if key == tilde or key == backquote then
&#9;&#9;toggleBackpack()
      showBackpack()
&#9;end
end)
backpackButton.MouseButton1Click:connect(function() 

toggleBackpack()
showBackpack()
--openCloseBackpack()

end)

if game.Players.LocalPlayer[&quot;Character&quot;] then
&#9;activateBackpack()
end
game.Players.LocalPlayer.CharacterAdded:connect(activateBackpack)

-- search functions
searchBox.FocusLost:connect(function(enterPressed)
&#9;if enterPressed or searchBox.Text ~= &quot;&quot; then
&#9;&#9;doSearch()
&#9;elseif searchBox.Text == &quot;&quot; then
&#9;&#9;resetSearch()
&#9;end
end)
searchButton.MouseButton1Click:connect(doSearch)
resetButton.MouseButton1Click:connect(resetSearch)

backpackButton.Visible = true</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX9">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">BackpackGear</string>
					<ProtectedString name="Source">local t = {}

local function ScopedConnect(parentInstance, instance, event, signalFunc, syncFunc, removeFunc)
&#9;local eventConnection = nil

&#9;--Connection on parentInstance is scoped by parentInstance (when destroyed, it goes away)
&#9;local tryConnect = function()
&#9;&#9;if game:IsAncestorOf(parentInstance) then
&#9;&#9;&#9;--Entering the world, make sure we are connected/synced
&#9;&#9;&#9;if not eventConnection then
&#9;&#9;&#9;&#9;eventConnection = instance[event]:connect(signalFunc)
&#9;&#9;&#9;&#9;if syncFunc then syncFunc() end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;--Probably leaving the world, so disconnect for now
&#9;&#9;&#9;if eventConnection then
&#9;&#9;&#9;&#9;eventConnection:disconnect()
&#9;&#9;&#9;&#9;if removeFunc then removeFunc() end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;--Hook it up to ancestryChanged signal
&#9;local connection = parentInstance.AncestryChanged:connect(tryConnect)
&#9;
&#9;--Now connect us if we&apos;re already in the world
&#9;tryConnect()
&#9;
&#9;return connection
end

local function getScreenGuiAncestor(instance)
&#9;local localInstance = instance
&#9;while localInstance and not localInstance:IsA(&quot;ScreenGui&quot;) do
&#9;&#9;localInstance = localInstance.Parent
&#9;end
&#9;return localInstance
end

local function CreateButtons(frame, buttons, yPos, ySize)
&#9;local buttonNum = 1
&#9;local buttonObjs = {}
&#9;for i, obj in ipairs(buttons) do 
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot; .. buttonNum
&#9;&#9;button.Font = Enum.Font.Arial
&#9;&#9;button.FontSize = Enum.FontSize.Size18
&#9;&#9;button.AutoButtonColor = true
&#9;&#9;button.Modal = true
&#9;&#9;if obj[&quot;Style&quot;] then
&#9;&#9;&#9;button.Style = obj.Style
&#9;&#9;else
&#9;&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;end
&#9;&#9;button.Text = obj.Text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.MouseButton1Click:connect(obj.Function)
&#9;&#9;button.Parent = frame
&#9;&#9;buttonObjs[buttonNum] = button

&#9;&#9;buttonNum = buttonNum + 1
&#9;end
&#9;local numButtons = buttonNum-1

&#9;if numButtons == 1 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.35, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.4,0,ySize.Scale, ySize.Offset)
&#9;elseif numButtons == 2 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.1, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.8/3,0, ySize.Scale, ySize.Offset)

&#9;&#9;frame.Button2.Position = UDim2.new(0.55, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button2.Size = UDim2.new(.35,0, ySize.Scale, ySize.Offset)
&#9;elseif numButtons &gt;= 3 then
&#9;&#9;local spacing = .1 / numButtons
&#9;&#9;local buttonSize = .9 / numButtons

&#9;&#9;buttonNum = 1
&#9;&#9;while buttonNum &lt;= numButtons do
&#9;&#9;&#9;buttonObjs[buttonNum].Position = UDim2.new(spacing*buttonNum + (buttonNum-1) * buttonSize, 0, yPos.Scale, yPos.Offset)
&#9;&#9;&#9;buttonObjs[buttonNum].Size = UDim2.new(buttonSize, 0, ySize.Scale, ySize.Offset)
&#9;&#9;&#9;buttonNum = buttonNum + 1
&#9;&#9;end
&#9;end
end

local function setSliderPos(newAbsPosX,slider,sliderPosition,bar,steps)

&#9;local newStep = steps - 1 --otherwise we really get one more step than we want
&#9;local relativePosX = math.min(1, math.max(0, (newAbsPosX - bar.AbsolutePosition.X) / bar.AbsoluteSize.X ))
&#9;local wholeNum, remainder = math.modf(relativePosX * newStep)
&#9;if remainder &gt; 0.5 then
&#9;&#9;wholeNum = wholeNum + 1
&#9;end
&#9;relativePosX = wholeNum/newStep

&#9;local result = math.ceil(relativePosX * newStep)
&#9;if sliderPosition.Value ~= (result + 1) then --only update if we moved a step
&#9;&#9;sliderPosition.Value = result + 1
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end
&#9;
end

local function cancelSlide(areaSoak)
&#9;areaSoak.Visible = false
&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
end

t.CreateStyledMessageDialog = function(title, message, style, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0, 165)
&#9;frame.Position = UDim2.new(0.25, 0, 0.5, -72.5)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound&#9;
&#9;
&#9;local styleImage = Instance.new(&quot;ImageLabel&quot;)
&#9;styleImage.Name = &quot;StyleImage&quot;
&#9;styleImage.BackgroundTransparency = 1
&#9;styleImage.Position = UDim2.new(0,5,0,15)
&#9;if style == &quot;error&quot; or style == &quot;Error&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;rbxasset://ui/error.png&quot;
&#9;elseif style == &quot;notify&quot; or style == &quot;Notify&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;rbxasset://ui/notify.png&quot;
&#9;elseif style == &quot;confirm&quot; or style == &quot;Confirm&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 74, 0, 76)
&#9;&#9;styleImage.Image = &quot;rbxasset://ui/confirm.png&quot;
&#9;else
&#9;&#9;return t.CreateMessageDialog(title,message,buttons)
&#9;end
&#9;styleImage.Parent = frame
&#9;
&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.TextStrokeTransparency = 0
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 80, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, -80, 0, 40)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextStrokeTransparency = 0
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 80, 0, 45)
&#9;messageLabel.Size = UDim2.new(0.95, -80, 0, 55)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0, 105), UDim.new(0, 40) )

&#9;return frame
end

t.CreateMessageDialog = function(title, message, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0.5, 0)
&#9;frame.Position = UDim2.new(0.25, 0, 0.25, 0)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound

&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 0, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, 0, 0.15, 0)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 0, 0.175, 0)
&#9;messageLabel.Size = UDim2.new(0.95, 0, .55, 0)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0.8,0), UDim.new(0.15, 0))

&#9;return frame
end

t.CreateDropDownMenu = function(items, onSelect, forRoblox)
&#9;local width = UDim.new(0, 100)
&#9;local height = UDim.new(0, 32)

&#9;local xPos = 0.055
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;DropDownMenu&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(width, height)

&#9;local dropDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;dropDownMenu.Name = &quot;DropDownMenuButton&quot;
&#9;dropDownMenu.TextWrap = true
&#9;dropDownMenu.TextColor3 = Color3.new(1,1,1)
&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;dropDownMenu.Font = Enum.Font.ArialBold
&#9;dropDownMenu.FontSize = Enum.FontSize.Size18
&#9;dropDownMenu.TextXAlignment = Enum.TextXAlignment.Left
&#9;dropDownMenu.TextYAlignment = Enum.TextYAlignment.Center
&#9;dropDownMenu.BackgroundTransparency = 1
&#9;dropDownMenu.AutoButtonColor = true
&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;dropDownMenu.Size = UDim2.new(1,0,1,0)
&#9;dropDownMenu.Parent = frame
&#9;dropDownMenu.ZIndex = 2

&#9;local dropDownIcon = Instance.new(&quot;ImageLabel&quot;)
&#9;dropDownIcon.Name = &quot;Icon&quot;
&#9;dropDownIcon.Active = false
&#9;dropDownIcon.Image = &quot;rbxasset://ui/dropdownicon.png&quot;
&#9;dropDownIcon.BackgroundTransparency = 1
&#9;dropDownIcon.Size = UDim2.new(0,11,0,6)
&#9;dropDownIcon.Position = UDim2.new(1,-11,0.5, -2)
&#9;dropDownIcon.Parent = dropDownMenu
&#9;dropDownIcon.ZIndex = 2
&#9;
&#9;local itemCount = #items
&#9;local dropDownItemCount = #items
&#9;local useScrollButtons = false
&#9;if dropDownItemCount &gt; 6 then
&#9;&#9;useScrollButtons = true
&#9;&#9;dropDownItemCount = 6
&#9;end
&#9;
&#9;local droppedDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;droppedDownMenu.Name = &quot;List&quot;
&#9;droppedDownMenu.Text = &quot;&quot;
&#9;droppedDownMenu.BackgroundTransparency = 1
&#9;--droppedDownMenu.AutoButtonColor = true
&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;droppedDownMenu.Visible = false
&#9;droppedDownMenu.Active = true&#9;--Blocks clicks
&#9;droppedDownMenu.Position = UDim2.new(0,0,0,0)
&#9;droppedDownMenu.Size = UDim2.new(1,0, (1 + dropDownItemCount)*.8, 0)
&#9;droppedDownMenu.Parent = frame
&#9;droppedDownMenu.ZIndex = 2

&#9;local choiceButton = Instance.new(&quot;TextButton&quot;)
&#9;choiceButton.Name = &quot;ChoiceButton&quot;
&#9;choiceButton.BackgroundTransparency = 1
&#9;choiceButton.BorderSizePixel = 0
&#9;choiceButton.Text = &quot;ReplaceMe&quot;
&#9;choiceButton.TextColor3 = Color3.new(1,1,1)
&#9;choiceButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;choiceButton.TextYAlignment = Enum.TextYAlignment.Center
&#9;choiceButton.BackgroundColor3 = Color3.new(1, 1, 1)
&#9;choiceButton.Font = Enum.Font.Arial
&#9;choiceButton.FontSize = Enum.FontSize.Size18
&#9;if useScrollButtons then
&#9;&#9;choiceButton.Size = UDim2.new(1,-13, .8/((dropDownItemCount + 1)*.8),0) 
&#9;else
&#9;&#9;choiceButton.Size = UDim2.new(1, 0, .8/((dropDownItemCount + 1)*.8),0) 
&#9;end
&#9;choiceButton.TextWrap = true
&#9;choiceButton.ZIndex = 2

&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = true
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 3

&#9;local dropDownSelected = false

&#9;local scrollUpButton 
&#9;local scrollDownButton
&#9;local scrollMouseCount = 0

&#9;local setZIndex = function(baseZIndex)
&#9;&#9;droppedDownMenu.ZIndex = baseZIndex +1
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex + 2
&#9;&#9;&#9;&#9;elseif child.Name == &quot;ClickCaptureButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollBarPosition = 1
&#9;local updateScroll = function()
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.Active = scrollBarPosition &gt; 1 
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.Active = scrollBarPosition + dropDownItemCount &lt;= itemCount 
&#9;&#9;end

&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if not children then return end

&#9;&#9;local childNum = 1&#9;&#9;&#9;
&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;if childNum &lt; scrollBarPosition or childNum &gt;= scrollBarPosition + dropDownItemCount then
&#9;&#9;&#9;&#9;&#9;obj.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;obj.Position = UDim2.new(0,0,((childNum-scrollBarPosition+1)*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;&#9;&#9;&#9;obj.Visible = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;obj.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;obj.BackgroundTransparency = 1

&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;local toggleVisibility = function()
&#9;&#9;dropDownSelected = not dropDownSelected

&#9;&#9;areaSoak.Visible = not areaSoak.Visible
&#9;&#9;dropDownMenu.Visible = not dropDownSelected
&#9;&#9;droppedDownMenu.Visible = dropDownSelected
&#9;&#9;if dropDownSelected then
&#9;&#9;&#9;setZIndex(4)
&#9;&#9;else
&#9;&#9;&#9;setZIndex(2)
&#9;&#9;end
&#9;&#9;if useScrollButtons then
&#9;&#9;&#9;updateScroll()
&#9;&#9;end
&#9;end
&#9;droppedDownMenu.MouseButton1Click:connect(toggleVisibility)

&#9;local updateSelection = function(text)
&#9;&#9;local foundItem = false
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;local childNum = 1
&#9;&#9;if children then
&#9;&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;if obj.Text == text then
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;&#9;foundItem = true&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;scrollBarPosition = childNum
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if not text then
&#9;&#9;&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;&#9;&#9;scrollBarPosition = 1
&#9;&#9;else
&#9;&#9;&#9;if not foundItem then
&#9;&#9;&#9;&#9;error(&quot;Invalid Selection Update -- &quot; .. text)
&#9;&#9;&#9;end

&#9;&#9;&#9;if scrollBarPosition + dropDownItemCount &gt; itemCount + 1 then
&#9;&#9;&#9;&#9;scrollBarPosition = itemCount - dropDownItemCount + 1
&#9;&#9;&#9;end

&#9;&#9;&#9;dropDownMenu.Text = text
&#9;&#9;end
&#9;end
&#9;
&#9;local function scrollDown()
&#9;&#9;if scrollBarPosition + dropDownItemCount &lt;= itemCount then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition + 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;local function scrollUp()
&#9;&#9;if scrollBarPosition &gt; 1 then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition - 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;
&#9;if useScrollButtons then
&#9;&#9;--Make some scroll buttons
&#9;&#9;scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;&#9;scrollUpButton.BackgroundTransparency = 1
&#9;&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollUpButton.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;scrollUpButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;
&#9;&#9;&#9;&#9;scrollUp()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollUp() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)

&#9;&#9;scrollUpButton.Parent = droppedDownMenu

&#9;&#9;scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;&#9;scrollDownButton.BackgroundTransparency = 1
&#9;&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollDownButton.Position = UDim2.new(1,-11,1,-11)
&#9;&#9;scrollDownButton.Parent = droppedDownMenu
&#9;&#9;scrollDownButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1

&#9;&#9;&#9;&#9;scrollDown()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollDown() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)&#9;

&#9;&#9;local scrollbar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;&#9;scrollbar.BackgroundTransparency = 1
&#9;&#9;scrollbar.Size = UDim2.new(0, 18, (dropDownItemCount*.8)/((dropDownItemCount+1)*.8), -(17) - 11 - 4)
&#9;&#9;scrollbar.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),17+2)
&#9;&#9;scrollbar.Parent = droppedDownMenu
&#9;end

&#9;for i,item in ipairs(items) do
&#9;&#9;-- needed to maintain local scope for items in event listeners below
&#9;&#9;local button = choiceButton:clone()
&#9;&#9;if forRoblox then
&#9;&#9;&#9;button.RobloxLocked = true
&#9;&#9;end&#9;&#9;
&#9;&#9;button.Text = item
&#9;&#9;button.Parent = droppedDownMenu
&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;button.BackgroundTransparency = 1

&#9;&#9;&#9;updateSelection(item)
&#9;&#9;&#9;onSelect(item)

&#9;&#9;&#9;toggleVisibility()
&#9;&#9;end)
&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;--Add Highlight&#9;
&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)

&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)
&#9;end

&#9;--This does the initial layout of the buttons&#9;
&#9;updateScroll()
&#9;
&#9;frame.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(frame)
&#9;&#9;end
&#9;end)

&#9;dropDownMenu.MouseButton1Click:connect(toggleVisibility)
&#9;areaSoak.MouseButton1Click:connect(toggleVisibility)
&#9;return frame, updateSelection
end

t.CreatePropertyDropDownMenu = function(instance, property, enum)

&#9;local items = enum:GetEnumItems()
&#9;local names = {}
&#9;local nameToItem = {}
&#9;for i,obj in ipairs(items) do
&#9;&#9;names[i] = obj.Name
&#9;&#9;nameToItem[obj.Name] = obj
&#9;end

&#9;local frame
&#9;local updateSelection
&#9;frame, updateSelection = t.CreateDropDownMenu(names, function(text) instance[property] = nameToItem[text] end)

&#9;ScopedConnect(frame, instance, &quot;Changed&quot;, 
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == property then
&#9;&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;&#9;end
&#9;&#9;end,
&#9;&#9;function()
&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;end)

&#9;return frame
end

t.GetFontHeight = function(font, fontSize)
&#9;if font == nil or fontSize == nil then
&#9;&#9;error(&quot;Font and FontSize must be non-nil&quot;)
&#9;end

&#9;if font == Enum.Font.Legacy then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 15
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 17
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 21
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 27
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 54
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 72
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;elseif font == Enum.Font.Arial or font == Enum.Font.ArialBold then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 8
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 9
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 10
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 11
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 24
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 48
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;error(&quot;Unknown Font &quot; .. font)
&#9;end
end

local function layoutGuiObjectsHelper(frame, guiObjects, settingsTable)
&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;local pixelsRemaining = frame.AbsoluteSize.Y
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if child:IsA(&quot;TextLabel&quot;) or child:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;local isLabel = child:IsA(&quot;TextLabel&quot;)
&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;end
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, pixelsRemaining)

&#9;&#9;&#9;if child.TextFits and child.TextBounds.Y &lt; pixelsRemaining then
&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextLabelSizePadY&quot;])
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextButtonSizePadY&quot;])
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;while not child.TextFits do
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.AbsoluteSize.Y + 1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y&#9;&#9;

&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;pixelsRemaining = -1
&#9;&#9;&#9;end&#9;&#9;&#9;

&#9;&#9;else
&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;child.Visible = (pixelsRemaining &gt;= 0)
&#9;&#9;end
&#9;end
end

t.LayoutGuiObjects = function(frame, guiObjects, settingsTable)
&#9;if not frame:IsA(&quot;GuiObject&quot;) then
&#9;&#9;error(&quot;Frame must be a GuiObject&quot;)
&#9;end
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if not child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements that are layed out must be of type GuiObject&quot;)
&#9;&#9;end
&#9;end

&#9;if not settingsTable then
&#9;&#9;settingsTable = {}
&#9;end

&#9;if not settingsTable[&quot;TextLabelSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelSizePadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextLabelPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelPositionPadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextButtonSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonSizePadY&quot;] = 12
&#9;end
&#9;if not settingsTable[&quot;TextButtonPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonPositionPadY&quot;] = 2
&#9;end

&#9;--Wrapper frame takes care of styled objects
&#9;local wrapperFrame = Instance.new(&quot;Frame&quot;)
&#9;wrapperFrame.Name = &quot;WrapperFrame&quot;
&#9;wrapperFrame.BackgroundTransparency = 1
&#9;wrapperFrame.Size = UDim2.new(1,0,1,0)
&#9;wrapperFrame.Parent = frame

&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;child.Parent = wrapperFrame
&#9;end

&#9;local recalculate = function()
&#9;&#9;wait()
&#9;&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
&#9;end
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(recalculate)

&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
end


t.CreateSlider = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 4
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local bar = Instance.new(&quot;TextButton&quot;)
&#9;bar.Text = &quot;&quot;
&#9;bar.AutoButtonColor = false
&#9;bar.Name = &quot;Bar&quot;
&#9;bar.BackgroundColor3 = Color3.new(0,0,0)
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width,0,5)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,5)
&#9;end
&#9;bar.BorderColor3 = Color3.new(95/255,95/255,95/255)
&#9;bar.ZIndex = 2
&#9;bar.Parent = sliderGui
&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end
&#9;
&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/Slider.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-10)
&#9;slider.Size = UDim2.new(0,20,0,20)
&#9;slider.ZIndex = 3
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)
&#9;
&#9;return sliderGui, sliderPosition, sliderSteps

end

t.CreateTrueScrollingFrame = function()
&#9;local lowY = nil
&#9;local highY = nil
&#9;
&#9;local dragCon = nil
&#9;local upCon = nil

&#9;local internalChange = false

&#9;local descendantsChangeConMap = {}

&#9;local scrollingFrame = Instance.new(&quot;Frame&quot;)
&#9;scrollingFrame.Name = &quot;ScrollingFrame&quot;
&#9;scrollingFrame.Active = true
&#9;scrollingFrame.Size = UDim2.new(1,0,1,0)
&#9;scrollingFrame.ClipsDescendants = true

&#9;local controlFrame = Instance.new(&quot;Frame&quot;)
&#9;controlFrame.Name = &quot;ControlFrame&quot;
&#9;controlFrame.BackgroundTransparency = 1
&#9;controlFrame.Size = UDim2.new(0,18,1,0)
&#9;controlFrame.Position = UDim2.new(1,-20,0,0)
&#9;controlFrame.Parent = scrollingFrame
&#9;
&#9;local scrollBottom = Instance.new(&quot;BoolValue&quot;)
&#9;scrollBottom.Value = false
&#9;scrollBottom.Name = &quot;ScrollBottom&quot;
&#9;scrollBottom.Parent = controlFrame
&#9;
&#9;local scrollUp = Instance.new(&quot;BoolValue&quot;)
&#9;scrollUp.Value = false
&#9;scrollUp.Name = &quot;scrollUp&quot;
&#9;scrollUp.Parent = controlFrame

&#9;local scrollUpButton = Instance.new(&quot;TextButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.Text = &quot;&quot;
&#9;scrollUpButton.AutoButtonColor = false
&#9;scrollUpButton.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollUpButton.BorderColor3 = Color3.new(1,1,1)
&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;scrollUpButton.Size = UDim2.new(0,18,0,18)
&#9;scrollUpButton.ZIndex = 2
&#9;scrollUpButton.Parent = controlFrame
&#9;for i = 1, 6 do
&#9;&#9;local triFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;triFrame.BorderColor3 = Color3.new(1,1,1)
&#9;&#9;triFrame.Name = &quot;tri&quot; .. tostring(i)
&#9;&#9;triFrame.ZIndex = 3
&#9;&#9;triFrame.BackgroundTransparency = 0.5
&#9;&#9;triFrame.Size = UDim2.new(0,12 - ((i -1) * 2),0,0)
&#9;&#9;triFrame.Position = UDim2.new(0,3 + (i -1),0.5,2 - (i -1))
&#9;&#9;triFrame.Parent = scrollUpButton
&#9;end
&#9;scrollUpButton.MouseEnter:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.1
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollUpButton.MouseLeave:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)

&#9;local scrollDownButton = scrollUpButton:clone()
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.Position = UDim2.new(0,0,1,-18)
&#9;local downChildren = scrollDownButton:GetChildren()
&#9;for i = 1, #downChildren do
&#9;&#9;downChildren[i].Position = UDim2.new(0,3 + (i -1),0.5,-2 + (i - 1))
&#9;end
&#9;scrollDownButton.MouseEnter:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.1
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.MouseLeave:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.5
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.Parent = controlFrame
&#9;
&#9;local scrollTrack = Instance.new(&quot;Frame&quot;)
&#9;scrollTrack.Name = &quot;ScrollTrack&quot;
&#9;scrollTrack.BackgroundTransparency = 1
&#9;scrollTrack.Size = UDim2.new(0,18,1,-38)
&#9;scrollTrack.Position = UDim2.new(0,0,0,19)
&#9;scrollTrack.Parent = controlFrame

&#9;local scrollbar = Instance.new(&quot;TextButton&quot;)
&#9;scrollbar.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollbar.BorderColor3 = Color3.new(1,1,1)
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.AutoButtonColor = false
&#9;scrollbar.Text = &quot;&quot;
&#9;scrollbar.Active = true
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.ZIndex = 2
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.Size = UDim2.new(0, 18, 0.1, 0)
&#9;scrollbar.Position = UDim2.new(0,0,0,0)
&#9;scrollbar.Parent = scrollTrack

&#9;local scrollNub = Instance.new(&quot;Frame&quot;)
&#9;scrollNub.Name = &quot;ScrollNub&quot;
&#9;scrollNub.BorderColor3 = Color3.new(1,1,1)
&#9;scrollNub.Size = UDim2.new(0,10,0,0)
&#9;scrollNub.Position = UDim2.new(0.5,-5,0.5,0)
&#9;scrollNub.ZIndex = 2
&#9;scrollNub.BackgroundTransparency = 0.5
&#9;scrollNub.Parent = scrollbar

&#9;local newNub = scrollNub:clone()
&#9;newNub.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;newNub.Parent = scrollbar
&#9;
&#9;local lastNub = scrollNub:clone()
&#9;lastNub.Position = UDim2.new(0.5,-5,0.5,2)
&#9;lastNub.Parent = scrollbar

&#9;scrollbar.MouseEnter:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.1
&#9;&#9;scrollNub.BackgroundTransparency = 0.1
&#9;&#9;newNub.BackgroundTransparency = 0.1
&#9;&#9;lastNub.BackgroundTransparency = 0.1
&#9;end)
&#9;scrollbar.MouseLeave:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.5
&#9;&#9;scrollNub.BackgroundTransparency = 0.5
&#9;&#9;newNub.BackgroundTransparency = 0.5
&#9;&#9;lastNub.BackgroundTransparency = 0.5
&#9;end)

&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10
&#9;
&#9;local function positionScrollBar(x,y,offset)
&#9;&#9;local oldPos = scrollbar.Position

&#9;&#9;if y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;
&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y

&#9;&#9;if y &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;local newScaleYPos = (y - scrollTrack.AbsolutePosition.y - offset)/scrollTrack.AbsoluteSize.y
&#9;&#9;if newScaleYPos + relativeSize &gt; 1 then
&#9;&#9;&#9;newScaleYPos = 1 - relativeSize
&#9;&#9;&#9;scrollBottom.Value = true
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;elseif newScaleYPos &lt;= 0 then
&#9;&#9;&#9;newScaleYPos = 0
&#9;&#9;&#9;scrollUp.Value = true
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;else
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;end
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,newScaleYPos,0)
&#9;&#9;
&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;end

&#9;local function drillDownSetHighLow(instance)
&#9;&#9;if not instance or not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if instance == controlFrame then return end
&#9;&#9;if instance:IsDescendantOf(controlFrame) then return end
&#9;&#9;if not instance.Visible then return end

&#9;&#9;if lowY and lowY &gt; instance.AbsolutePosition.Y then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;elseif not lowY then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;end
&#9;&#9;if highY and highY &lt; (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;local children = instance:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;drillDownSetHighLow(children[i])
&#9;&#9;end
&#9;end

&#9;local function resetHighLow()
&#9;&#9;local firstChildren = scrollingFrame:GetChildren()

&#9;&#9;for i = 1, #firstChildren do
&#9;&#9;&#9;drillDownSetHighLow(firstChildren[i])
&#9;&#9;end
&#9;end

&#9;local function recalculate()
&#9;&#9;internalChange = true

&#9;&#9;local percentFrame = 0
&#9;&#9;if scrollbar.Position.Y.Scale &gt; 0 then
&#9;&#9;&#9;if scrollbar.Visible then
&#9;&#9;&#9;&#9;percentFrame = scrollbar.Position.Y.Scale/((scrollTrack.AbsoluteSize.Y - scrollbar.AbsoluteSize.Y)/scrollTrack.AbsoluteSize.Y)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;percentFrame = 0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if percentFrame &gt; 0.99 then percentFrame = 1 end

&#9;&#9;local hiddenYAmount = (scrollingFrame.AbsoluteSize.Y - (highY - lowY)) * percentFrame
&#9;&#9;
&#9;&#9;local guiChildren = scrollingFrame:GetChildren()
&#9;&#9;for i = 1, #guiChildren do
&#9;&#9;&#9;if guiChildren[i] ~= controlFrame then
&#9;&#9;&#9;&#9;guiChildren[i].Position = UDim2.new(guiChildren[i].Position.X.Scale,guiChildren[i].Position.X.Offset,
&#9;&#9;&#9;&#9;&#9;0, math.ceil(guiChildren[i].AbsolutePosition.Y) - math.ceil(lowY) + hiddenYAmount)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()
&#9;&#9;internalChange = false
&#9;end

&#9;local function setSliderSizeAndPosition()
&#9;&#9;if not highY or not lowY then return end

&#9;&#9;local totalYSpan = math.abs(highY - lowY)
&#9;&#9;if totalYSpan == 0 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false

&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;local percentShown = scrollingFrame.AbsoluteSize.Y/totalYSpan
&#9;&#9;if percentShown &gt;= 1 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false
&#9;&#9;&#9;recalculate()
&#9;&#9;else
&#9;&#9;&#9;scrollbar.Visible = true
&#9;&#9;&#9;scrollDownButton.Visible = true
&#9;&#9;&#9;scrollUpButton.Visible = true

&#9;&#9;&#9;scrollbar.Size = UDim2.new(scrollbar.Size.X.Scale,scrollbar.Size.X.Offset,percentShown,0)
&#9;&#9;end

&#9;&#9;local percentPosition = (scrollingFrame.AbsolutePosition.Y - lowY)/totalYSpan
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,percentPosition,-scrollbar.AbsoluteSize.X/2)

&#9;&#9;if scrollbar.AbsolutePosition.y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;end

&#9;&#9;if (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.Y) &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;end
&#9;end
&#9;
&#9;local buttonScrollAmountPixels = 7
&#9;local reentrancyGuardScrollUp = false
&#9;local function doScrollUp()
&#9;&#9;if reentrancyGuardScrollUp then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollUp = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y - buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollUp = false
&#9;end
&#9;
&#9;local reentrancyGuardScrollDown = false
&#9;local function doScrollDown()
&#9;&#9;if reentrancyGuardScrollDown then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollDown = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y + buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollDown = false
&#9;end

&#9;local function scrollUp(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollbar.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function scrollDown(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;scrollbar.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollbar.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollbar.AbsolutePosition.y
&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;local prevY = y
&#9;&#9;&#9;local reentrancyGuardMouseScroll = false
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;if reentrancyGuardMouseScroll then return end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = true
&#9;&#9;&#9;&#9;&#9;if positionScrollBar(x,y,mouseOffset) then
&#9;&#9;&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = false
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(function()
&#9;&#9;scrollUp()
&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)

&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(function()
&#9;&#9; scrollDown()
&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;
&#9;local function heightCheck(instance)
&#9;&#9;if highY and (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) &gt; highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;setSliderSizeAndPosition()
&#9;end
&#9;
&#9;local function highLowRecheck()
&#9;&#9;local oldLowY = lowY
&#9;&#9;local oldHighY = highY
&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()

&#9;&#9;if (lowY ~= oldLowY) or (highY ~= oldHighY) then
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end

&#9;local function descendantChanged(this, prop)
&#9;&#9;if internalChange then return end
&#9;&#9;if not this.Visible then return end

&#9;&#9;if prop == &quot;Size&quot; or prop == &quot;Position&quot; then
&#9;&#9;&#9;wait()
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end
&#9;end

&#9;scrollingFrame.DescendantAdded:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end

&#9;&#9;if instance.Visible then
&#9;&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end

&#9;&#9;descendantsChangeConMap[instance] = instance.Changed:connect(function(prop) descendantChanged(instance, prop) end)
&#9;end)

&#9;scrollingFrame.DescendantRemoving:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if descendantsChangeConMap[instance] then
&#9;&#9;&#9;descendantsChangeConMap[instance]:disconnect()
&#9;&#9;&#9;descendantsChangeConMap[instance] = nil
&#9;&#9;end
&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;highLowRecheck()
&#9;end)
&#9;
&#9;scrollingFrame.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;if not highY or not lowY then return end

&#9;&#9;&#9;highLowRecheck()
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end)

&#9;return scrollingFrame, controlFrame
end

t.CreateScrollingFrame = function(orderList,scrollStyle)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;ScrollingFrame&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(1,0,1,0)
&#9;
&#9;local scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.BackgroundTransparency = 1
&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 

&#9;
&#9;local scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.BackgroundTransparency = 1
&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;
&#9;local scrollbar = Instance.new(&quot;ImageButton&quot;)
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;scrollbar.BackgroundTransparency = 1
&#9;scrollbar.Size = UDim2.new(0, 18, 0, 150)

&#9;local scrollStamp = 0
&#9;&#9;
&#9;local scrollDrag = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDrag.Image = &quot;rbxasset://ui/scrolldrag.png&quot;
&#9;scrollDrag.Size = UDim2.new(1, 0, 0, 16)
&#9;scrollDrag.BackgroundTransparency = 1
&#9;scrollDrag.Name = &quot;ScrollDrag&quot;
&#9;scrollDrag.Active = true
&#9;scrollDrag.Parent = scrollbar
&#9;
&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10

&#9;local style = &quot;simple&quot;
&#9;if scrollStyle and tostring(scrollStyle) then
&#9;&#9;style = scrollStyle
&#9;end
&#9;
&#9;local scrollPosition = 1
&#9;local rowSize = 0
&#9;local howManyDisplayed = 0
&#9;&#9;
&#9;local layoutGridScrollBar = function()
&#9;&#9;howManyDisplayed = 0
&#9;&#9;local guiObjects = {}
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;
&#9;&#9;local totalPixelsY = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemainingY = frame.AbsoluteSize.Y
&#9;&#9;
&#9;&#9;local totalPixelsX  = frame.AbsoluteSize.X
&#9;&#9;
&#9;&#9;local xCounter = 0
&#9;&#9;local rowSizeCounter = 0
&#9;&#9;local setRowSize = true

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;
&#9;&#9;local currentRowY = 0

&#9;&#9;pos = scrollPosition
&#9;&#9;--count up from current scroll position to fill out grid
&#9;&#9;while pos &lt;= #guiObjects and pixelsBelowScrollbar &lt; totalPixelsY do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;--previous pos was the end of a row
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;end
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos + 1
&#9;&#9;end
&#9;&#9;--Count wherever current row left off
&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;currentRowY = 0
&#9;&#9;
&#9;&#9;pos = scrollPosition - 1
&#9;&#9;xCounter = 0
&#9;&#9;
&#9;&#9;--objects with varying X,Y dimensions can rarely cause minor errors
&#9;&#9;--rechecking every new scrollPosition is necessary to avoid 100% of errors
&#9;&#9;
&#9;&#9;--count backwards from current scrollPosition to see if we can add more rows
&#9;&#9;while pixelsBelowScrollbar + currentRowY &lt; totalPixelsY and pos &gt;= 1 do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;rowSizeCounter = rowSizeCounter + 1
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;rowSizeCounter = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= rowSize then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1 
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - rowSize
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end

&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end
&#9;&#9;
&#9;&#9;--Do check last time if pos = 0
&#9;&#9;if (pos == 0) and (pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY) then
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;end

&#9;&#9;xCounter = 0
&#9;&#9;--pos = scrollPosition
&#9;&#9;rowSizeCounter = 0
&#9;&#9;setRowSize = true
&#9;&#9;local lastChildSize = 0
&#9;&#9;
&#9;&#9;local xOffset,yOffset = 0
&#9;&#9;if guiObjects[1] then
&#9;&#9;&#9;yOffset = math.ceil(math.floor(math.fmod(totalPixelsY,guiObjects[1].AbsoluteSize.X))/2)
&#9;&#9;&#9;xOffset = math.ceil(math.floor(math.fmod(totalPixelsX,guiObjects[1].AbsoluteSize.Y))/2)
&#9;&#9;end
&#9;&#9;
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemainingY &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;if setRowSize then rowSizeCounter = rowSizeCounter + 1 end
&#9;&#9;&#9;&#9;&#9;if xCounter + child.AbsoluteSize.X &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;&#9;&#9;if setRowSize then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;setRowSize = false
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;xCounter = 0
&#9;&#9;&#9;&#9;&#9;&#9;pixelsRemainingY = pixelsRemainingY - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale,xCounter + xOffset, 0, totalPixelsY - pixelsRemainingY + yOffset)
&#9;&#9;&#9;&#9;&#9;xCounter = xCounter + child.AbsoluteSize.X
&#9;&#9;&#9;&#9;&#9;child.Visible = ((pixelsRemainingY - child.AbsoluteSize.Y) &gt;= 0)
&#9;&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;lastChildSize = child.AbsoluteSize&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;if lastChildSize == 0 then 
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;else
&#9;&#9;&#9;scrollDownButton.Active = ((pixelsRemainingY - lastChildSize.Y) &lt; 0)
&#9;&#9;end
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end



&#9;local layoutSimpleScrollBar = function()
&#9;&#9;local guiObjects = {}&#9;
&#9;&#9;howManyDisplayed = 0
&#9;&#9;
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemaining = frame.AbsoluteSize.Y

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;while pixelsBelowScrollbar &lt; totalPixels and pos &gt;= 1 do
&#9;&#9;&#9;if pos &gt;= scrollPosition then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y &lt;= totalPixels then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= 1 then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--local (&quot;Backing up ScrollPosition from -- &quot; ..scrollPosition)
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end

&#9;&#9;pos = scrollPosition
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemaining &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if  (pixelsRemaining &gt;= 0) then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;scrollDownButton.Active = (pixelsRemaining &lt; 0)
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end
&#9;
&#9;&#9;
&#9;local moveDragger = function()&#9;
&#9;&#9;local guiObjects = 0
&#9;&#9;local children = frame:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;if not scrollDrag.Parent then return end
&#9;&#9;
&#9;&#9;local dragSizeY = scrollDrag.Parent.AbsoluteSize.y * (1/(guiObjects - howManyDisplayed + 1))
&#9;&#9;if dragSizeY &lt; 16 then dragSizeY = 16 end
&#9;&#9;scrollDrag.Size = UDim2.new(scrollDrag.Size.X.Scale,scrollDrag.Size.X.Offset,scrollDrag.Size.Y.Scale,dragSizeY)

&#9;&#9;local relativeYPos = (scrollPosition - 1)/(guiObjects - (howManyDisplayed))
&#9;&#9;if relativeYPos &gt; 1 then relativeYPos = 1
&#9;&#9;elseif relativeYPos &lt; 0 then relativeYPos = 0 end
&#9;&#9;local absYPos = 0
&#9;&#9;
&#9;&#9;if relativeYPos ~= 0 then
&#9;&#9;&#9;absYPos = (relativeYPos * scrollbar.AbsoluteSize.y) - (relativeYPos * scrollDrag.AbsoluteSize.y)
&#9;&#9;end
&#9;&#9;
&#9;&#9;scrollDrag.Position = UDim2.new(scrollDrag.Position.X.Scale,scrollDrag.Position.X.Offset,scrollDrag.Position.Y.Scale,absYPos)
&#9;end

&#9;local reentrancyGuard = false
&#9;local recalculate = function()
&#9;&#9;if reentrancyGuard then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;reentrancyGuard = true
&#9;&#9;wait()
&#9;&#9;local success, err = nil
&#9;&#9;if style == &quot;grid&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutGridScrollBar() end)
&#9;&#9;elseif style == &quot;simple&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutSimpleScrollBar() end)
&#9;&#9;end
&#9;&#9;if not success then print(err) end
&#9;&#9;moveDragger()
&#9;&#9;reentrancyGuard = false
&#9;end
&#9;
&#9;local doScrollUp = function()
&#9;&#9;scrollPosition = (scrollPosition) - rowSize
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;recalculate(nil)
&#9;end
&#9;
&#9;local doScrollDown = function()
&#9;&#9;scrollPosition = (scrollPosition) + rowSize
&#9;&#9;recalculate(nil)
&#9;end

&#9;local scrollUp = function(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollDrag.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollDown = function(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollDrag.AbsolutePosition.y + scrollDrag.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local y = 0
&#9;scrollDrag.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollDrag.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollDrag.AbsolutePosition.y
&#9;&#9;&#9;local dragCon
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;local barAbsPos = scrollbar.AbsolutePosition.y
&#9;&#9;&#9;&#9;local barAbsSize = scrollbar.AbsoluteSize.y
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local dragAbsSize = scrollDrag.AbsoluteSize.y
&#9;&#9;&#9;&#9;local barAbsOne = barAbsPos + barAbsSize - dragAbsSize
&#9;&#9;&#9;&#9;y = y - mouseOffset
&#9;&#9;&#9;&#9;y = y &lt; barAbsPos and barAbsPos or y &gt; barAbsOne and barAbsOne or y
&#9;&#9;&#9;&#9;y = y - barAbsPos
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local guiObjects = 0
&#9;&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local doublePercent = y/(barAbsSize-dragAbsSize)
&#9;&#9;&#9;&#9;local rowDiff = rowSize
&#9;&#9;&#9;&#9;local totalScrollCount = guiObjects - (howManyDisplayed - 1)
&#9;&#9;&#9;&#9;local newScrollPosition = math.floor((doublePercent * totalScrollCount) + 0.5) + rowDiff
&#9;&#9;&#9;&#9;if newScrollPosition &lt; scrollPosition then
&#9;&#9;&#9;&#9;&#9;rowDiff = -rowDiff
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if newScrollPosition &lt; 1 then
&#9;&#9;&#9;&#9;&#9;newScrollPosition = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;scrollPosition = newScrollPosition
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollUp()
&#9;&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)


&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollDown()&#9;
&#9;&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollbar.MouseButton1Down:connect(
&#9;&#9;function(x,y)
&#9;&#9;&#9;if y &gt; (scrollDrag.AbsoluteSize.y + scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollDown(y)
&#9;&#9;&#9;elseif y &lt; (scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollUp(y)
&#9;&#9;&#9;end
&#9;&#9;end)


&#9;frame.ChildAdded:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)

&#9;frame.ChildRemoved:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(function() recalculate(nil) end)

&#9;return frame, scrollUpButton, scrollDownButton, recalculate, scrollbar
end
local function binaryGrow(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local biggestLegal = min

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (biggestLegal == nil or biggestLegal &lt; mid) then
&#9;&#9;&#9;biggestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--Try growing
&#9;&#9;&#9;min = mid + 1
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, shrink
&#9;&#9;&#9;max = mid - 1
&#9;&#9;end
&#9;end
&#9;return biggestLegal
end


local function binaryShrink(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local smallestLegal = max

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (smallestLegal == nil or smallestLegal &gt; mid) then
&#9;&#9;&#9;smallestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--It fits, shrink
&#9;&#9;&#9;max = mid - 1&#9;&#9;&#9;
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, grow
&#9;&#9;&#9;min = mid + 1
&#9;&#9;end
&#9;end
&#9;return smallestLegal
end


local function getGuiOwner(instance)
&#9;while instance ~= nil do
&#9;&#9;if instance:IsA(&quot;ScreenGui&quot;) or instance:IsA(&quot;BillboardGui&quot;)  then
&#9;&#9;&#9;return instance
&#9;&#9;end
&#9;&#9;instance = instance.Parent
&#9;end
&#9;return nil
end

t.AutoTruncateTextObject = function(textLabel)
&#9;local text = textLabel.Text

&#9;local fullLabel = textLabel:Clone()
&#9;fullLabel.Name = &quot;Full&quot; .. textLabel.Name 
&#9;fullLabel.BorderSizePixel = 0
&#9;fullLabel.BackgroundTransparency = 0
&#9;fullLabel.Text = text
&#9;fullLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;fullLabel.Position = UDim2.new(0,-3,0,0)
&#9;fullLabel.Size = UDim2.new(0,100,1,0)
&#9;fullLabel.Visible = false
&#9;fullLabel.Parent = textLabel

&#9;local shortText = nil
&#9;local mouseEnterConnection = nil
&#9;local mouseLeaveConnection= nil

&#9;local checkForResize = function()
&#9;&#9;if getGuiOwner(textLabel) == nil then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;textLabel.Text = text
&#9;&#9;if textLabel.TextFits then 
&#9;&#9;&#9;--Tear down the rollover if it is active
&#9;&#9;&#9;if mouseEnterConnection then
&#9;&#9;&#9;&#9;mouseEnterConnection:disconnect()
&#9;&#9;&#9;&#9;mouseEnterConnection = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection then
&#9;&#9;&#9;&#9;mouseLeaveConnection:disconnect()
&#9;&#9;&#9;&#9;mouseLeaveConnection = nil
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local len = string.len(text)
&#9;&#9;&#9;textLabel.Text = text .. &quot;~&quot;

&#9;&#9;&#9;--Shrink the text
&#9;&#9;&#9;local textSize = binaryGrow(0, len, 
&#9;&#9;&#9;&#9;function(pos)
&#9;&#9;&#9;&#9;&#9;if pos == 0 then
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = string.sub(text, 1, pos) .. &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;shortText = string.sub(text, 1, textSize) .. &quot;~&quot;
&#9;&#9;&#9;textLabel.Text = shortText
&#9;&#9;&#9;
&#9;&#9;&#9;--Make sure the fullLabel fits
&#9;&#9;&#9;if not fullLabel.TextFits then
&#9;&#9;&#9;&#9;--Already too small, grow it really bit to start
&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, 10000, 1, 0)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;--Okay, now try to binary shrink it back down
&#9;&#9;&#9;local fullLabelSize = binaryShrink(textLabel.AbsoluteSize.X,fullLabel.AbsoluteSize.X, 
&#9;&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, size, 1, 0)
&#9;&#9;&#9;&#9;&#9;return fullLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;fullLabel.Size = UDim2.new(0,fullLabelSize+6,1,0)

&#9;&#9;&#9;--Now setup the rollover effects, if they are currently off
&#9;&#9;&#9;if mouseEnterConnection == nil then
&#9;&#9;&#9;&#9;mouseEnterConnection = textLabel.MouseEnter:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.ZIndex = textLabel.ZIndex + 1
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection == nil then
&#9;&#9;&#9;&#9;mouseLeaveConnection = textLabel.MouseLeave:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = shortText
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;textLabel.AncestryChanged:connect(checkForResize)
&#9;textLabel.Changed:connect(
&#9;&#9;function(prop) 
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then 
&#9;&#9;&#9;&#9;checkForResize() &#9;
&#9;&#9;&#9;end 
&#9;&#9;end)

&#9;checkForResize()

&#9;local function changeText(newText)
&#9;&#9;text = newText
&#9;&#9;fullLabel.Text = text
&#9;&#9;checkForResize()
&#9;end

&#9;return textLabel, changeText
end

local function TransitionTutorialPages(fromPage, toPage, transitionFrame, currentPageValue)&#9;
&#9;if fromPage then
&#9;&#9;fromPage.Visible = false
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = fromPage.Size
&#9;&#9;&#9;transitionFrame.Position = fromPage.Position
&#9;&#9;end
&#9;else
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = UDim2.new(0.0,50,0.0,50)
&#9;&#9;&#9;transitionFrame.Position = UDim2.new(0.5,-25,0.5,-25)
&#9;&#9;end
&#9;end
&#9;transitionFrame.Visible = true
&#9;currentPageValue.Value = nil

&#9;local newsize, newPosition
&#9;if toPage then
&#9;&#9;--Make it visible so it resizes
&#9;&#9;toPage.Visible = true

&#9;&#9;newSize = toPage.Size
&#9;&#9;newPosition = toPage.Position

&#9;&#9;toPage.Visible = false
&#9;else
&#9;&#9;newSize = UDim2.new(0.0,50,0.0,50)
&#9;&#9;newPosition = UDim2.new(0.5,-25,0.5,-25)
&#9;end
&#9;transitionFrame:TweenSizeAndPosition(newSize, newPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, 0.3, true,
&#9;&#9;function(state)
&#9;&#9;&#9;if state == Enum.TweenStatus.Completed then
&#9;&#9;&#9;&#9;transitionFrame.Visible = false
&#9;&#9;&#9;&#9;if toPage then
&#9;&#9;&#9;&#9;&#9;toPage.Visible = true
&#9;&#9;&#9;&#9;&#9;currentPageValue.Value = toPage
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
end

t.CreateTutorial = function(name, tutorialKey, createButtons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;Tutorial-&quot; .. name
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)

&#9;local transitionFrame = Instance.new(&quot;Frame&quot;)
&#9;transitionFrame.Name = &quot;TransitionFrame&quot;
&#9;transitionFrame.Style = Enum.FrameStyle.RobloxRound
&#9;transitionFrame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;transitionFrame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;transitionFrame.Visible = false
&#9;transitionFrame.Parent = frame

&#9;local currentPageValue = Instance.new(&quot;ObjectValue&quot;)
&#9;currentPageValue.Name = &quot;CurrentTutorialPage&quot;
&#9;currentPageValue.Value = nil
&#9;currentPageValue.Parent = frame

&#9;local boolValue = Instance.new(&quot;BoolValue&quot;)
&#9;boolValue.Name = &quot;Buttons&quot;
&#9;boolValue.Value = createButtons
&#9;boolValue.Parent = frame

&#9;local pages = Instance.new(&quot;Frame&quot;)
&#9;pages.Name = &quot;Pages&quot;
&#9;pages.BackgroundTransparency = 1
&#9;pages.Size = UDim2.new(1,0,1,0)
&#9;pages.Parent = frame

&#9;local function getVisiblePageAndHideOthers()
&#9;&#9;local visiblePage = nil
&#9;&#9;local children = pages:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i,child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;if visiblePage then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;visiblePage = child
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return visiblePage
&#9;end

&#9;local showTutorial = function(alwaysShow)
&#9;&#9;if alwaysShow or UserSettings().GameSettings:GetTutorialState(tutorialKey) == false then
&#9;&#9;&#9;print(&quot;Showing tutorial-&quot;,tutorialKey)
&#9;&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;&#9;local firstPage = pages:FindFirstChild(&quot;TutorialPage1&quot;)
&#9;&#9;&#9;if firstPage then
&#9;&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, firstPage, transitionFrame, currentPageValue)&#9;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;Could not find TutorialPage1&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local dismissTutorial = function()
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;if currentTutorialPage then
&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, nil, transitionFrame, currentPageValue)
&#9;&#9;end

&#9;&#9;UserSettings().GameSettings:SetTutorialState(tutorialKey, true)
&#9;end

&#9;local gotoPage = function(pageNum)
&#9;&#9;local page = pages:FindFirstChild(&quot;TutorialPage&quot; .. pageNum)
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()
&#9;&#9;TransitionTutorialPages(currentTutorialPage, page, transitionFrame, currentPageValue)
&#9;end

&#9;return frame, showTutorial, dismissTutorial, gotoPage
end 

local function CreateBasicTutorialPage(name, handleResize, skipTutorial, giveDoneButton)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TutorialPage&quot;
&#9;frame.Style = Enum.FrameStyle.RobloxRound
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;frame.Visible = false
&#9;
&#9;local frameHeader = Instance.new(&quot;TextLabel&quot;)
&#9;frameHeader.Name = &quot;Header&quot;
&#9;frameHeader.Text = name
&#9;frameHeader.BackgroundTransparency = 1
&#9;frameHeader.FontSize = Enum.FontSize.Size24
&#9;frameHeader.Font = Enum.Font.ArialBold
&#9;frameHeader.TextColor3 = Color3.new(1,1,1)
&#9;frameHeader.TextXAlignment = Enum.TextXAlignment.Center
&#9;frameHeader.TextWrap = true
&#9;frameHeader.Size = UDim2.new(1,-55, 0, 22)
&#9;frameHeader.Position = UDim2.new(0,0,0,0)
&#9;frameHeader.Parent = frame

&#9;local skipButton = Instance.new(&quot;ImageButton&quot;)
&#9;skipButton.Name = &quot;SkipButton&quot;
&#9;skipButton.AutoButtonColor = false
&#9;skipButton.BackgroundTransparency = 1
&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;skipButton.MouseButton1Click:connect(function()
&#9;&#9;skipTutorial()
&#9;end)
&#9;skipButton.MouseEnter:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton_dn.png&quot;
&#9;end)
&#9;skipButton.MouseLeave:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;end)
&#9;skipButton.Size = UDim2.new(0, 25, 0, 25)
&#9;skipButton.Position = UDim2.new(1, -25, 0, 0)
&#9;skipButton.Parent = frame
&#9;
&#9;
&#9;if giveDoneButton then
&#9;&#9;local doneButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;doneButton.Name = &quot;DoneButton&quot;
&#9;&#9;doneButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;doneButton.Text = &quot;Done&quot;
&#9;&#9;doneButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;doneButton.Font = Enum.Font.ArialBold
&#9;&#9;doneButton.FontSize = Enum.FontSize.Size18
&#9;&#9;doneButton.Size = UDim2.new(0,100,0,50)
&#9;&#9;doneButton.Position = UDim2.new(0.5,-50,1,-50)
&#9;&#9;
&#9;&#9;if skipTutorial then
&#9;&#9;&#9;doneButton.MouseButton1Click:connect(function() skipTutorial() end)
&#9;&#9;end
&#9;&#9;
&#9;&#9;doneButton.Parent = frame
&#9;end

&#9;local innerFrame = Instance.new(&quot;Frame&quot;)
&#9;innerFrame.Name = &quot;ContentFrame&quot;
&#9;innerFrame.BackgroundTransparency = 1
&#9;innerFrame.Position = UDim2.new(0,0,0,25)
&#9;innerFrame.Parent = frame

&#9;local nextButton = Instance.new(&quot;TextButton&quot;)
&#9;nextButton.Name = &quot;NextButton&quot;
&#9;nextButton.Text = &quot;Next&quot;
&#9;nextButton.TextColor3 = Color3.new(1,1,1)
&#9;nextButton.Font = Enum.Font.Arial
&#9;nextButton.FontSize = Enum.FontSize.Size18
&#9;nextButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;nextButton.Size = UDim2.new(0,80, 0, 32)
&#9;nextButton.Position = UDim2.new(0.5, 5, 1, -32)
&#9;nextButton.Active = false
&#9;nextButton.Visible = false
&#9;nextButton.Parent = frame

&#9;local prevButton = Instance.new(&quot;TextButton&quot;)
&#9;prevButton.Name = &quot;PrevButton&quot;
&#9;prevButton.Text = &quot;Previous&quot;
&#9;prevButton.TextColor3 = Color3.new(1,1,1)
&#9;prevButton.Font = Enum.Font.Arial
&#9;prevButton.FontSize = Enum.FontSize.Size18
&#9;prevButton.Style = Enum.ButtonStyle.RobloxButton
&#9;prevButton.Size = UDim2.new(0,80, 0, 32)
&#9;prevButton.Position = UDim2.new(0.5, -85, 1, -32)
&#9;prevButton.Active = false
&#9;prevButton.Visible = false
&#9;prevButton.Parent = frame

&#9;if giveDoneButton then
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-75)
&#9;else
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-22)
&#9;end

&#9;local parentConnection = nil

&#9;local function basicHandleResize()
&#9;&#9;if frame.Visible and frame.Parent then
&#9;&#9;&#9;local maxSize = math.min(frame.Parent.AbsoluteSize.X, frame.Parent.AbsoluteSize.Y)
&#9;&#9;&#9;handleResize(200,maxSize)
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;Parent&quot; then
&#9;&#9;&#9;&#9;if parentConnection ~= nil then
&#9;&#9;&#9;&#9;&#9;parentConnection:disconnect()
&#9;&#9;&#9;&#9;&#9;parentConnection = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if frame.Parent and frame.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;parentConnection = frame.Parent.Changed:connect(
&#9;&#9;&#9;&#9;&#9;&#9;function(parentProp)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if parentProp == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;if prop == &quot;Visible&quot; then 
&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;end
&#9;&#9;end)

&#9;return frame, innerFrame
end

t.CreateTextTutorialPage = function(name, text, skipTutorialFunc)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local textLabel = Instance.new(&quot;TextLabel&quot;)
&#9;textLabel.BackgroundTransparency = 1
&#9;textLabel.TextColor3 = Color3.new(1,1,1)
&#9;textLabel.Text = text
&#9;textLabel.TextWrap = true
&#9;textLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;textLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;textLabel.Font = Enum.Font.Arial
&#9;textLabel.FontSize = Enum.FontSize.Size14
&#9;textLabel.Size = UDim2.new(1,0,1,0)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;end)
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc)
&#9;textLabel.Parent = contentFrame

&#9;return frame
end

t.CreateImageTutorialPage = function(name, imageAsset, x, y, skipTutorialFunc, giveDoneButton)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local imageLabel = Instance.new(&quot;ImageLabel&quot;)
&#9;imageLabel.BackgroundTransparency = 1
&#9;imageLabel.Image = imageAsset
&#9;imageLabel.Size = UDim2.new(0,x,0,y)
&#9;imageLabel.Position = UDim2.new(0.5,-x/2,0.5,-y/2)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;return size &gt;= x and size &gt;= y
&#9;&#9;&#9;end)
&#9;&#9;if size &gt;= x and size &gt;= y then
&#9;&#9;&#9;imageLabel.Size = UDim2.new(0,x, 0,y)
&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5,-x/2, 0.5, -y/2)
&#9;&#9;else
&#9;&#9;&#9;if x &gt; y then
&#9;&#9;&#9;&#9;--X is limiter, so 
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(1,0,y/x,0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0,0, 0.5 - (y/x)/2, 0)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--Y is limiter
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(x/y,0,1, 0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5-(x/y)/2, 0, 0, 0)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;size = size + 50
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc, giveDoneButton)
&#9;imageLabel.Parent = contentFrame

&#9;return frame
end

t.AddTutorialPage = function(tutorial, tutorialPage)
&#9;local transitionFrame = tutorial.TransitionFrame
&#9;local currentPageValue = tutorial.CurrentTutorialPage

&#9;if not tutorial.Buttons.Value then
&#9;&#9;tutorialPage.NextButton.Parent = nil
&#9;&#9;tutorialPage.PrevButton.Parent = nil
&#9;end

&#9;local children = tutorial.Pages:GetChildren()
&#9;if children and #children &gt; 0 then
&#9;&#9;tutorialPage.Name = &quot;TutorialPage&quot; .. (#children+1)
&#9;&#9;local previousPage = children[#children]
&#9;&#9;if not previousPage:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements under Pages must be GuiObjects&quot;)
&#9;&#9;end

&#9;&#9;if tutorial.Buttons.Value then
&#9;&#9;&#9;if previousPage.NextButton.Active then
&#9;&#9;&#9;&#9;error(&quot;NextButton already Active on previousPage, please only add pages with RbxGui.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;previousPage.NextButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(previousPage, tutorialPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;previousPage.NextButton.Active = true
&#9;&#9;&#9;previousPage.NextButton.Visible = true

&#9;&#9;&#9;if tutorialPage.PrevButton.Active then
&#9;&#9;&#9;&#9;error(&quot;PrevButton already Active on tutorialPage, please only add pages with RbxGui.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;tutorialPage.PrevButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(tutorialPage, previousPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;tutorialPage.PrevButton.Active = true
&#9;&#9;&#9;tutorialPage.PrevButton.Visible = true
&#9;&#9;end

&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;else
&#9;&#9;--First child
&#9;&#9;tutorialPage.Name = &quot;TutorialPage1&quot;
&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;end
end 

t.CreateSetPanel = function(userIdsForSets, objectSelected, dialogClosed, size, position, showAdminCategories, useAssetVersionId)

&#9;if not userIdsForSets then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is nil, should be a table of number ids&quot;)
&#9;end
&#9;if type(userIdsForSets) ~= &quot;table&quot; and type(userIdsForSets) ~= &quot;userdata&quot; then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is of type &quot; ..type(userIdsForSets) .. &quot;, should be of type table or userdata&quot;)
&#9;end
&#9;if not objectSelected then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is nil, should be a callback function!&quot;)
&#9;end
&#9;if type(objectSelected) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is of type &quot; .. type(objectSelected) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;if dialogClosed and type(dialogClosed) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: dialogClosed (third arg) is of type &quot; .. type(dialogClosed) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;
&#9;if showAdminCategories == nil then -- by default, don&apos;t show beta sets
&#9;&#9;showAdminCategories = false
&#9;end

&#9;local arrayPosition = 1
&#9;local insertButtons = {}
&#9;local insertButtonCons = {}
&#9;local contents = nil
&#9;local setGui = nil

&#9;-- used for water selections
&#9;local waterForceDirection = &quot;NegX&quot;
&#9;local waterForce = &quot;None&quot;
&#9;local waterGui, waterTypeChangedEvent = nil
&#9;
&#9;local Data = {}
&#9;Data.CurrentCategory = nil
&#9;Data.Category = {}
&#9;local SetCache = {}
&#9;
&#9;local userCategoryButtons = nil
&#9;
&#9;local buttonWidth = 64
&#9;local buttonHeight = buttonWidth
&#9;
&#9;local SmallThumbnailUrl = nil
&#9;local LargeThumbnailUrl = nil
&#9;local BaseUrl = game:GetService(&quot;ContentProvider&quot;).BaseUrl:lower()
&#9;
&#9;if useAssetVersionId then
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;assetversionid=&quot;
&#9;else
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;aid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;aid=&quot;
&#9;end
&#9;&#9;
&#9;local function drillDownSetZIndex(parent, index)
&#9;&#9;local children = parent:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;if children[i]:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;children[i].ZIndex = index
&#9;&#9;&#9;end
&#9;&#9;&#9;drillDownSetZIndex(children[i], index)
&#9;&#9;end
&#9;end
&#9;
&#9;-- for terrain stamping
&#9;local currTerrainDropDownFrame = nil
&#9;local terrainShapes = {&quot;Block&quot;,&quot;Vertical Ramp&quot;,&quot;Corner Wedge&quot;,&quot;Inverse Corner Wedge&quot;,&quot;Horizontal Ramp&quot;,&quot;Auto-Wedge&quot;}
&#9;local terrainShapeMap = {}
&#9;for i = 1, #terrainShapes do
&#9;&#9;terrainShapeMap[terrainShapes[i]] = i - 1
&#9;end&#9;
&#9;terrainShapeMap[terrainShapes[#terrainShapes]] = 6

&#9;local function createWaterGui()
&#9;&#9;local waterForceDirections = {&quot;NegX&quot;,&quot;X&quot;,&quot;NegY&quot;,&quot;Y&quot;,&quot;NegZ&quot;,&quot;Z&quot;}
&#9;&#9;local waterForces = {&quot;None&quot;, &quot;Small&quot;, &quot;Medium&quot;, &quot;Strong&quot;, &quot;Max&quot;}

&#9;&#9;local waterFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;waterFrame.Name = &quot;WaterFrame&quot;
&#9;&#9;waterFrame.Style = Enum.FrameStyle.RobloxSquare
&#9;&#9;waterFrame.Size = UDim2.new(0,150,0,110)
&#9;&#9;waterFrame.Visible = false

&#9;&#9;local waterForceLabel = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;waterForceLabel.Name = &quot;WaterForceLabel&quot;
&#9;&#9;waterForceLabel.BackgroundTransparency = 1
&#9;&#9;waterForceLabel.Size = UDim2.new(1,0,0,12)
&#9;&#9;waterForceLabel.Font = Enum.Font.ArialBold
&#9;&#9;waterForceLabel.FontSize = Enum.FontSize.Size12
&#9;&#9;waterForceLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;waterForceLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;waterForceLabel.Text = &quot;Water Force&quot;
&#9;&#9;waterForceLabel.Parent = waterFrame

&#9;&#9;local waterForceDirLabel = waterForceLabel:Clone()
&#9;&#9;waterForceDirLabel.Name = &quot;WaterForceDirectionLabel&quot;
&#9;&#9;waterForceDirLabel.Text = &quot;Water Force Direction&quot;
&#9;&#9;waterForceDirLabel.Position = UDim2.new(0,0,0,50)
&#9;&#9;waterForceDirLabel.Parent = waterFrame

&#9;&#9;local waterTypeChangedEvent = Instance.new(&quot;BindableEvent&quot;,waterFrame)
&#9;&#9;waterTypeChangedEvent.Name = &quot;WaterTypeChangedEvent&quot;

&#9;&#9;local waterForceDirectionSelectedFunc = function(newForceDirection)
&#9;&#9;&#9;waterForceDirection = newForceDirection
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end
&#9;&#9;local waterForceSelectedFunc = function(newForce)
&#9;&#9;&#9;waterForce = newForce
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end

&#9;&#9;local waterForceDirectionDropDown, forceWaterDirectionSelection = t.CreateDropDownMenu(waterForceDirections, waterForceDirectionSelectedFunc)
&#9;&#9;waterForceDirectionDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDirectionDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;forceWaterDirectionSelection(&quot;NegX&quot;)
&#9;&#9;waterForceDirectionDropDown.Parent = waterForceDirLabel

&#9;&#9;local waterForceDropDown, forceWaterForceSelection = t.CreateDropDownMenu(waterForces, waterForceSelectedFunc)
&#9;&#9;forceWaterForceSelection(&quot;None&quot;)
&#9;&#9;waterForceDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;waterForceDropDown.Parent = waterForceLabel

&#9;&#9;return waterFrame, waterTypeChangedEvent
&#9;end

&#9;-- Helper Function that contructs gui elements
&#9;local function createSetGui()
&#9;
&#9;&#9;local setGui = Instance.new(&quot;ScreenGui&quot;)
&#9;&#9;setGui.Name = &quot;SetGui&quot;
&#9;&#9;
&#9;&#9;local setPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;setPanel.Name = &quot;SetPanel&quot;
&#9;&#9;setPanel.Active = true
&#9;&#9;setPanel.BackgroundTransparency = 1
&#9;&#9;if position then
&#9;&#9;&#9;setPanel.Position = position
&#9;&#9;else
&#9;&#9;&#9;setPanel.Position = UDim2.new(0.2, 29, 0.1, 24)
&#9;&#9;end
&#9;&#9;if size then
&#9;&#9;&#9;setPanel.Size = size
&#9;&#9;else
&#9;&#9;&#9;setPanel.Size = UDim2.new(0.6, -58, 0.64, 0)
&#9;&#9;end
&#9;&#9;setPanel.Style = Enum.FrameStyle.RobloxRound
&#9;&#9;setPanel.ZIndex = 6
&#9;&#9;setPanel.Parent = setGui
&#9;&#9;
&#9;&#9;&#9;-- Children of SetPanel
&#9;&#9;&#9;local itemPreview = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;itemPreview.Name = &quot;ItemPreview&quot;
&#9;&#9;&#9;itemPreview.BackgroundTransparency = 1
&#9;&#9;&#9;itemPreview.Position = UDim2.new(0.8,5,0.085,0)
&#9;&#9;&#9;itemPreview.Size = UDim2.new(0.21,0,0.9,0)
&#9;&#9;&#9;itemPreview.ZIndex = 6
&#9;&#9;&#9;itemPreview.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of ItemPreview
&#9;&#9;&#9;&#9;local textPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;textPanel.Name = &quot;TextPanel&quot;
&#9;&#9;&#9;&#9;textPanel.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;textPanel.Position = UDim2.new(0,0,0.45,0)
&#9;&#9;&#9;&#9;textPanel.Size = UDim2.new(1,0,0.55,0)
&#9;&#9;&#9;&#9;textPanel.ZIndex = 6
&#9;&#9;&#9;&#9;textPanel.Parent = itemPreview
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- Children of TextPanel
&#9;&#9;&#9;&#9;&#9;local rolloverText = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;&#9;rolloverText.Name = &quot;RolloverText&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;rolloverText.Size = UDim2.new(1,0,0,48)
&#9;&#9;&#9;&#9;&#9;rolloverText.ZIndex = 6
&#9;&#9;&#9;&#9;&#9;rolloverText.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;rolloverText.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;&#9;rolloverText.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;&#9;rolloverText.TextWrap = true
&#9;&#9;&#9;&#9;&#9;rolloverText.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;&#9;rolloverText.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;&#9;rolloverText.Parent = textPanel
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local largePreview = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;largePreview.Name = &quot;LargePreview&quot;
&#9;&#9;&#9;&#9;largePreview.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;largePreview.Image = &quot;&quot;
&#9;&#9;&#9;&#9;largePreview.Size = UDim2.new(1,0,0,170)
&#9;&#9;&#9;&#9;largePreview.ZIndex = 6
&#9;&#9;&#9;&#9;largePreview.Parent = itemPreview
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;local sets = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;sets.Name = &quot;Sets&quot;
&#9;&#9;&#9;sets.BackgroundTransparency = 1
&#9;&#9;&#9;sets.Position = UDim2.new(0,0,0,5)
&#9;&#9;&#9;sets.Size = UDim2.new(0.23,0,1,-5)
&#9;&#9;&#9;sets.ZIndex = 6
&#9;&#9;&#9;sets.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Sets
&#9;&#9;&#9;&#9;local line = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;line.Name = &quot;Line&quot;
&#9;&#9;&#9;&#9;line.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;line.BackgroundTransparency = 0.7
&#9;&#9;&#9;&#9;line.BorderSizePixel = 0
&#9;&#9;&#9;&#9;line.Position = UDim2.new(1,-3,0.06,0)
&#9;&#9;&#9;&#9;line.Size = UDim2.new(0,3,0.9,0)
&#9;&#9;&#9;&#9;line.ZIndex = 6
&#9;&#9;&#9;&#9;line.Parent = sets
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsLists, controlFrame = t.CreateTrueScrollingFrame()
&#9;&#9;&#9;&#9;setsLists.Size = UDim2.new(1,-6,0.94,0)
&#9;&#9;&#9;&#9;setsLists.Position = UDim2.new(0,0,0.06,0)
&#9;&#9;&#9;&#9;setsLists.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsLists.Name = &quot;SetsLists&quot;
&#9;&#9;&#9;&#9;setsLists.ZIndex = 6
&#9;&#9;&#9;&#9;setsLists.Parent = sets
&#9;&#9;&#9;&#9;drillDownSetZIndex(controlFrame, 7)
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsHeader = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;setsHeader.Name = &quot;SetsHeader&quot;
&#9;&#9;&#9;&#9;setsHeader.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsHeader.Size = UDim2.new(0,47,0,24)
&#9;&#9;&#9;&#9;setsHeader.ZIndex = 6
&#9;&#9;&#9;&#9;setsHeader.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;setsHeader.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;setsHeader.Text = &quot;Sets&quot;
&#9;&#9;&#9;&#9;setsHeader.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setsHeader.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;setsHeader.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;setsHeader.Parent = sets
&#9;&#9;&#9;
&#9;&#9;&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;&#9;&#9;cancelButton.Position = UDim2.new(1,-32,0,-2)
&#9;&#9;&#9;cancelButton.Size = UDim2.new(0,34,0,34)
&#9;&#9;&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;&#9;cancelButton.ZIndex = 6
&#9;&#9;&#9;cancelButton.Text = &quot;&quot;
&#9;&#9;&#9;cancelButton.Modal = true
&#9;&#9;&#9;cancelButton.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Cancel Button
&#9;&#9;&#9;&#9;local cancelImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;cancelImage.Name = &quot;CancelImage&quot;
&#9;&#9;&#9;&#9;cancelImage.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;cancelImage.Image = &quot;rbxasset://ui/cancel.png&quot;
&#9;&#9;&#9;&#9;cancelImage.Position = UDim2.new(0,-2,0,-2)
&#9;&#9;&#9;&#9;cancelImage.Size = UDim2.new(0,16,0,16)
&#9;&#9;&#9;&#9;cancelImage.ZIndex = 6
&#9;&#9;&#9;&#9;cancelImage.Parent = cancelButton
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;return setGui
&#9;end
&#9;
&#9;local function createSetButton(text)
&#9;&#9;local setButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;
&#9;&#9;if text then setButton.Text = text
&#9;&#9;else setButton.Text = &quot;&quot; end
&#9;&#9;
&#9;&#9;setButton.AutoButtonColor = false
&#9;&#9;setButton.BackgroundTransparency = 1
&#9;&#9;setButton.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.BorderSizePixel = 0
&#9;&#9;setButton.Size = UDim2.new(1,-5,0,18)
&#9;&#9;setButton.ZIndex = 6
&#9;&#9;setButton.Visible = false
&#9;&#9;setButton.Font = Enum.Font.Arial
&#9;&#9;setButton.FontSize = Enum.FontSize.Size18
&#9;&#9;setButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;
&#9;&#9;return setButton
&#9;end
&#9;
&#9;local function buildSetButton(name, setId, setImageId, i,  count)
&#9;&#9;local button = createSetButton(name)
&#9;&#9;button.Text = name
&#9;&#9;button.Name = &quot;SetButton&quot;
&#9;&#9;button.Visible = true
&#9;&#9;
&#9;&#9;local setValue = Instance.new(&quot;IntValue&quot;)
&#9;&#9;setValue.Name = &quot;SetId&quot;
&#9;&#9;setValue.Value = setId
&#9;&#9;setValue.Parent = button

&#9;&#9;local setName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;setName.Name = &quot;SetName&quot;
&#9;&#9;setName.Value = name
&#9;&#9;setName.Parent = button

&#9;&#9;return button
&#9;end
&#9;
&#9;local function processCategory(sets)
&#9;&#9;local setButtons = {}
&#9;&#9;local numSkipped = 0
&#9;&#9;for i = 1, #sets do
&#9;&#9;&#9;if not showAdminCategories and sets[i].Name == &quot;Beta&quot; then
&#9;&#9;&#9;&#9;numSkipped = numSkipped + 1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;setButtons[i - numSkipped] = buildSetButton(sets[i].Name, sets[i].CategoryId, sets[i].ImageAssetId, i - numSkipped, #sets)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return setButtons
&#9;end
&#9;
&#9;local function handleResize()
&#9;&#9;wait() -- neccessary to insure heartbeat happened
&#9;&#9;
&#9;&#9;local itemPreview = setGui.SetPanel.ItemPreview
&#9;&#9;
&#9;&#9;itemPreview.LargePreview.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.X)
&#9;&#9;itemPreview.LargePreview.Position = UDim2.new(0.5,-itemPreview.LargePreview.AbsoluteSize.X/2,0,0)
&#9;&#9;itemPreview.TextPanel.Position = UDim2.new(0,0,0,itemPreview.LargePreview.AbsoluteSize.Y)
&#9;&#9;itemPreview.TextPanel.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.Y - itemPreview.LargePreview.AbsoluteSize.Y)
&#9;end
&#9;
&#9;local function makeInsertAssetButton()
&#9;&#9;local insertAssetButtonExample = Instance.new(&quot;Frame&quot;)
&#9;&#9;insertAssetButtonExample.Name = &quot;InsertAssetButtonExample&quot;
&#9;&#9;insertAssetButtonExample.Position = UDim2.new(0,128,0,64)
&#9;&#9;insertAssetButtonExample.Size = UDim2.new(0,64,0,64)
&#9;&#9;insertAssetButtonExample.BackgroundTransparency = 1
&#9;&#9;insertAssetButtonExample.ZIndex = 6
&#9;&#9;insertAssetButtonExample.Visible = false

&#9;&#9;local assetId = Instance.new(&quot;IntValue&quot;)
&#9;&#9;assetId.Name = &quot;AssetId&quot;
&#9;&#9;assetId.Value = 0
&#9;&#9;assetId.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;local assetName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;assetName.Name = &quot;AssetName&quot;
&#9;&#9;assetName.Value = &quot;&quot;
&#9;&#9;assetName.Parent = insertAssetButtonExample

&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot;
&#9;&#9;button.Text = &quot;&quot;
&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;button.Position = UDim2.new(0.025,0,0.025,0)
&#9;&#9;button.Size = UDim2.new(0.95,0,0.95,0)
&#9;&#9;button.ZIndex = 6
&#9;&#9;button.Parent = insertAssetButtonExample

&#9;&#9;local buttonImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;buttonImage.Name = &quot;ButtonImage&quot;
&#9;&#9;buttonImage.Image = &quot;&quot;
&#9;&#9;buttonImage.Position = UDim2.new(0,-7,0,-7)
&#9;&#9;buttonImage.Size = UDim2.new(1,14,1,14)
&#9;&#9;buttonImage.BackgroundTransparency = 1
&#9;&#9;buttonImage.ZIndex = 7
&#9;&#9;buttonImage.Parent = button

&#9;&#9;local configIcon = buttonImage:clone()
&#9;&#9;configIcon.Name = &quot;ConfigIcon&quot;
&#9;&#9;configIcon.Visible = false
&#9;&#9;configIcon.Position = UDim2.new(1,-23,1,-24)
&#9;&#9;configIcon.Size = UDim2.new(0,16,0,16)
&#9;&#9;configIcon.Image = &quot;&quot;
&#9;&#9;configIcon.ZIndex = 6
&#9;&#9;configIcon.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;return insertAssetButtonExample
&#9;end
&#9;
&#9;local function showLargePreview(insertButton)
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetId&quot;) then
&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(LargeThumbnailUrl .. tostring(insertButton.AssetId.Value))
&#9;&#9;&#9;&#9;setGui.SetPanel.ItemPreview.LargePreview.Image = LargeThumbnailUrl .. tostring(insertButton.AssetId.Value)
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetName&quot;) then
&#9;&#9;&#9;setGui.SetPanel.ItemPreview.TextPanel.RolloverText.Text = insertButton.AssetName.Value
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectTerrainShape(shape)
&#9;&#9;if currTerrainDropDownFrame then
&#9;&#9;&#9;objectSelected(tostring(currTerrainDropDownFrame.AssetName.Value), tonumber(currTerrainDropDownFrame.AssetId.Value), shape)
&#9;&#9;end
&#9;end
&#9;
&#9;local function createTerrainTypeButton(name, parent)
&#9;&#9;local dropDownTextButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;dropDownTextButton.Name = name .. &quot;Button&quot;
&#9;&#9;dropDownTextButton.Font = Enum.Font.ArialBold
&#9;&#9;dropDownTextButton.FontSize = Enum.FontSize.Size14
&#9;&#9;dropDownTextButton.BorderSizePixel = 0
&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;dropDownTextButton.Text = name
&#9;&#9;dropDownTextButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;dropDownTextButton.ZIndex = parent.ZIndex + 1
&#9;&#9;dropDownTextButton.Size = UDim2.new(0,parent.Size.X.Offset - 2,0,16)
&#9;&#9;dropDownTextButton.Position = UDim2.new(0,1,0,0)

&#9;&#9;dropDownTextButton.MouseEnter:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 0
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(0,0,0)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseLeave:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;if dropDownTextButton.Parent and dropDownTextButton.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;dropDownTextButton.Parent.Visible = false
&#9;&#9;&#9;end
&#9;&#9;&#9;selectTerrainShape(terrainShapeMap[dropDownTextButton.Text])
&#9;&#9;end)

&#9;&#9;return dropDownTextButton
&#9;end
&#9;
&#9;local function createTerrainDropDownMenu(zIndex)
&#9;&#9;local dropDown = Instance.new(&quot;Frame&quot;)
&#9;&#9;dropDown.Name = &quot;TerrainDropDown&quot;
&#9;&#9;dropDown.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;dropDown.BorderColor3 = Color3.new(1,0,0)
&#9;&#9;dropDown.Size = UDim2.new(0,200,0,0)
&#9;&#9;dropDown.Visible = false
&#9;&#9;dropDown.ZIndex = zIndex
&#9;&#9;dropDown.Parent = setGui

&#9;&#9;for i = 1, #terrainShapes do
&#9;&#9;&#9;local shapeButton = createTerrainTypeButton(terrainShapes[i],dropDown)
&#9;&#9;&#9;shapeButton.Position = UDim2.new(0,1,0,(i - 1) * (shapeButton.Size.Y.Offset))
&#9;&#9;&#9;shapeButton.Parent = dropDown
&#9;&#9;&#9;dropDown.Size = UDim2.new(0,200,0,dropDown.Size.Y.Offset + (shapeButton.Size.Y.Offset))
&#9;&#9;end

&#9;&#9;dropDown.MouseLeave:connect(function()
&#9;&#9;&#9;dropDown.Visible = false
&#9;&#9;end)
&#9;end

&#9;
&#9;local function createDropDownMenuButton(parent)
&#9;&#9;local dropDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;dropDownButton.Name = &quot;DropDownButton&quot;
&#9;&#9;dropDownButton.Image = &quot;rbxasset://ui/dropdownbutton.png&quot;
&#9;&#9;dropDownButton.BackgroundTransparency = 1
&#9;&#9;dropDownButton.Size = UDim2.new(0,16,0,16)
&#9;&#9;dropDownButton.Position = UDim2.new(1,-24,0,6)
&#9;&#9;dropDownButton.ZIndex = parent.ZIndex + 2
&#9;&#9;dropDownButton.Parent = parent
&#9;&#9;
&#9;&#9;if not setGui:FindFirstChild(&quot;TerrainDropDown&quot;) then
&#9;&#9;&#9;createTerrainDropDownMenu(8)
&#9;&#9;end
&#9;&#9;
&#9;&#9;dropDownButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;setGui.TerrainDropDown.Visible = true
&#9;&#9;&#9;setGui.TerrainDropDown.Position = UDim2.new(0,parent.AbsolutePosition.X,0,parent.AbsolutePosition.Y)
&#9;&#9;&#9;currTerrainDropDownFrame = parent
&#9;&#9;end)
&#9;end
&#9;
&#9;local function buildInsertButton()
&#9;&#9;local insertButton = makeInsertAssetButton()
&#9;&#9;insertButton.Name = &quot;InsertAssetButton&quot;
&#9;&#9;insertButton.Visible = true

&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;createDropDownMenuButton(insertButton)
&#9;&#9;end

&#9;&#9;local lastEnter = nil
&#9;&#9;local mouseEnterCon = insertButton.MouseEnter:connect(function()
&#9;&#9;&#9;lastEnter = insertButton
&#9;&#9;&#9;delay(0.1,function()
&#9;&#9;&#9;&#9;if lastEnter == insertButton then
&#9;&#9;&#9;&#9;&#9;showLargePreview(insertButton)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end)
&#9;&#9;return insertButton, mouseEnterCon
&#9;end
&#9;
&#9;local function realignButtonGrid(columns)
&#9;&#9;local x = 0
&#9;&#9;local y = 0 
&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;insertButtons[i].Position = UDim2.new(0, buttonWidth * x, 0, buttonHeight * y)
&#9;&#9;&#9;x = x + 1
&#9;&#9;&#9;if x &gt;= columns then
&#9;&#9;&#9;&#9;x = 0
&#9;&#9;&#9;&#9;y = y + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function setInsertButtonImageBehavior(insertFrame, visible, name, assetId)
&#9;&#9;if visible then
&#9;&#9;&#9;insertFrame.AssetName.Value = name
&#9;&#9;&#9;insertFrame.AssetId.Value = assetId
&#9;&#9;&#9;local newImageUrl = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;if newImageUrl ~= insertFrame.Button.ButtonImage.Image then
&#9;&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(SmallThumbnailUrl  .. assetId)
&#9;&#9;&#9;&#9;&#9;insertFrame.Button.ButtonImage.Image = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;table.insert(insertButtonCons,
&#9;&#9;&#9;&#9;insertFrame.Button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;-- special case for water, show water selection gui
&#9;&#9;&#9;&#9;&#9;local isWaterSelected = (name == &quot;Water&quot;) and (Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot;)
&#9;&#9;&#9;&#9;&#9;waterGui.Visible = isWaterSelected
&#9;&#9;&#9;&#9;&#9;if isWaterSelected then
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId), nil)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId))
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;)
&#9;&#9;&#9;insertFrame.Visible = true
&#9;&#9;else
&#9;&#9;&#9;insertFrame.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local function loadSectionOfItems(setGui, rows, columns)
&#9;&#9;local pageSize = rows * columns

&#9;&#9;if arrayPosition &gt; #contents then return end

&#9;&#9;local origArrayPos = arrayPosition

&#9;&#9;local yCopy = 0
&#9;&#9;for i = 1, pageSize + 1 do 
&#9;&#9;&#9;if arrayPosition &gt;= #contents + 1 then
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end

&#9;&#9;&#9;local buttonCon
&#9;&#9;&#9;insertButtons[arrayPosition], buttonCon = buildInsertButton()
&#9;&#9;&#9;table.insert(insertButtonCons,buttonCon)
&#9;&#9;&#9;insertButtons[arrayPosition].Parent = setGui.SetPanel.ItemsFrame
&#9;&#9;&#9;arrayPosition = arrayPosition + 1
&#9;&#9;end
&#9;&#9;realignButtonGrid(columns)

&#9;&#9;local indexCopy = origArrayPos
&#9;&#9;for index = origArrayPos, arrayPosition do
&#9;&#9;&#9;if insertButtons[index] then
&#9;&#9;&#9;&#9;if contents[index] then

&#9;&#9;&#9;&#9;&#9;-- we don&apos;t want water to have a drop down button
&#9;&#9;&#9;&#9;&#9;if contents[index].Name == &quot;Water&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;insertButtons[index]:FindFirstChild(&quot;DropDownButton&quot;,true):Destroy()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;local assetId
&#9;&#9;&#9;&#9;&#9;if useAssetVersionId then
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetVersionId
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;setInsertButtonImageBehavior(insertButtons[index], true, contents[index].Name, assetId)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;&#9;indexCopy = index
&#9;&#9;end
&#9;end
&#9;
&#9;local function setSetIndex()
&#9;&#9;Data.Category[Data.CurrentCategory].Index = 0

&#9;&#9;rows = 7
&#9;&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;&#9;contents = Data.Category[Data.CurrentCategory].Contents
&#9;&#9;if contents then
&#9;&#9;&#9;-- remove our buttons and their connections
&#9;&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;&#9;insertButtons[i]:remove()
&#9;&#9;&#9;end
&#9;&#9;&#9;for i = 1, #insertButtonCons do
&#9;&#9;&#9;&#9;if insertButtonCons[i] then insertButtonCons[i]:disconnect() end
&#9;&#9;&#9;end
&#9;&#9;&#9;insertButtonCons = {}
&#9;&#9;&#9;insertButtons = {}

&#9;&#9;&#9;arrayPosition = 1
&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectSet(button, setName, setId, setIndex)
&#9;&#9;if button and Data.Category[Data.CurrentCategory] ~= nil then
&#9;&#9;&#9;if button ~= Data.Category[Data.CurrentCategory].Button then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = button

&#9;&#9;&#9;&#9;if SetCache[setId] == nil then
&#9;&#9;&#9;&#9;&#9;SetCache[setId] = game:GetService(&quot;InsertService&quot;):GetCollection(setId)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Contents = SetCache[setId]

&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetName = setName
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetId = setId
&#9;&#9;&#9;end
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategoryPage(buttons, page)
&#9;&#9;if buttons ~= Data.CurrentCategory then
&#9;&#9;&#9;if Data.CurrentCategory then
&#9;&#9;&#9;&#9;for key, button in pairs(Data.CurrentCategory) do
&#9;&#9;&#9;&#9;&#9;button.Visible = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;Data.CurrentCategory = buttons
&#9;&#9;&#9;if Data.Category[Data.CurrentCategory] == nil then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory] = {}
&#9;&#9;&#9;&#9;if #buttons &gt; 0 then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[1], buttons[1].SetName.Value, buttons[1].SetId.Value, 0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = nil
&#9;&#9;&#9;&#9;selectSet(Data.Category[Data.CurrentCategory].ButtonFrame, Data.Category[Data.CurrentCategory].SetName, Data.Category[Data.CurrentCategory].SetId, Data.Category[Data.CurrentCategory].Index)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategory(category)
&#9;&#9;selectCategoryPage(category, 0)
&#9;end
&#9;
&#9;local function resetAllSetButtonSelection()
&#9;&#9;local setButtons = setGui.SetPanel.Sets.SetsLists:GetChildren()
&#9;&#9;for i = 1, #setButtons do
&#9;&#9;&#9;if setButtons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;setButtons[i].Selected = false
&#9;&#9;&#9;&#9;setButtons[i].BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setButtons[i].TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setButtons[i].BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function populateSetsFrame()
&#9;&#9;local currRow = 0
&#9;&#9;for i = 1, #userCategoryButtons do
&#9;&#9;&#9;local button = userCategoryButtons[i]
&#9;&#9;&#9;button.Visible = true
&#9;&#9;&#9;button.Position = UDim2.new(0,5,0,currRow * button.Size.Y.Offset)
&#9;&#9;&#9;button.Parent = setGui.SetPanel.Sets.SetsLists
&#9;&#9;&#9;
&#9;&#9;&#9;if i == 1 then -- we will have this selected by default, so show it
&#9;&#9;&#9;&#9;button.Selected = true
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;end

&#9;&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;resetAllSetButtonSelection()
&#9;&#9;&#9;&#9;button.Selected = not button.Selected
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;selectSet(button, button.Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;end)

&#9;&#9;&#9;currRow = currRow + 1
&#9;&#9;end

&#9;&#9;local buttons =  setGui.SetPanel.Sets.SetsLists:GetChildren()

&#9;&#9;-- set first category as loaded for default
&#9;&#9;if buttons then
&#9;&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;&#9;if buttons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[i], buttons[i].Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;&#9;&#9;selectCategory(userCategoryButtons)
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;setGui = createSetGui()
&#9;waterGui, waterTypeChangedEvent = createWaterGui()
&#9;waterGui.Position = UDim2.new(0,55,0,0)
&#9;waterGui.Parent = setGui
&#9;setGui.Changed:connect(function(prop) -- this resizes the preview image to always be the right size
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;handleResize()
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end)
&#9;
&#9;local scrollFrame, controlFrame = t.CreateTrueScrollingFrame()
&#9;scrollFrame.Size = UDim2.new(0.54,0,0.85,0)
&#9;scrollFrame.Position = UDim2.new(0.24,0,0.085,0)
&#9;scrollFrame.Name = &quot;ItemsFrame&quot;
&#9;scrollFrame.ZIndex = 6
&#9;scrollFrame.Parent = setGui.SetPanel
&#9;scrollFrame.BackgroundTransparency = 1

&#9;drillDownSetZIndex(controlFrame,7)

&#9;controlFrame.Parent = setGui.SetPanel
&#9;controlFrame.Position = UDim2.new(0.76, 5, 0, 0)

&#9;local debounce = false
&#9;controlFrame.ScrollBottom.Changed:connect(function(prop)
&#9;&#9;if controlFrame.ScrollBottom.Value == true then
&#9;&#9;&#9;if debounce then return end
&#9;&#9;&#9;debounce = true
&#9;&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;&#9;debounce = false
&#9;&#9;end
&#9;end)

&#9;local userData = {}
&#9;for id = 1, #userIdsForSets do
&#9;&#9;local newUserData = game:GetService(&quot;InsertService&quot;):GetUserSets(userIdsForSets[id])
&#9;&#9;if newUserData and #newUserData &gt; 2 then
&#9;&#9;&#9;-- start at #3 to skip over My Decals and My Models for each account
&#9;&#9;&#9;for category = 3, #newUserData do
&#9;&#9;&#9;&#9;if newUserData[category].Name == &quot;High Scalability&quot; then -- we want high scalability parts to show first
&#9;&#9;&#9;&#9;&#9;table.insert(userData,1,newUserData[category])
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;table.insert(userData, newUserData[category])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;
&#9;end
&#9;if userData then
&#9;&#9;userCategoryButtons = processCategory(userData)
&#9;end

&#9;rows = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;populateSetsFrame()

&#9;insertPanelCloseCon = setGui.SetPanel.CancelButton.MouseButton1Click:connect(function()
&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;if dialogClosed then dialogClosed() end
&#9;end)
&#9;
&#9;local setVisibilityFunction = function(visible)
&#9;&#9;if visible then
&#9;&#9;&#9;setGui.SetPanel.Visible = true
&#9;&#9;else
&#9;&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local getVisibilityFunction = function()
&#9;&#9;if setGui then
&#9;&#9;&#9;if setGui:FindFirstChild(&quot;SetPanel&quot;) then
&#9;&#9;&#9;&#9;return setGui.SetPanel.Visible
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;return false
&#9;end
&#9;
&#9;return setGui, setVisibilityFunction, getVisibilityFunction, waterTypeChangedEvent
end

t.CreateTerrainMaterialSelector = function(size,position)
&#9;local terrainMaterialSelectionChanged = Instance.new(&quot;BindableEvent&quot;)
&#9;terrainMaterialSelectionChanged.Name = &quot;TerrainMaterialSelectionChanged&quot;

&#9;local selectedButton = nil

&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TerrainMaterialSelector&quot;
&#9;if size then
&#9;&#9;frame.Size = size
&#9;else
&#9;&#9;frame.Size = UDim2.new(0, 245, 0, 230)
&#9;end
&#9;if position then
&#9;&#9;frame.Position = position
&#9;end
&#9;frame.BorderSizePixel = 0
&#9;frame.BackgroundColor3 = Color3.new(0,0,0)
&#9;frame.Active = true

&#9;terrainMaterialSelectionChanged.Parent = frame

&#9;local waterEnabled = true -- todo: turn this on when water is ready

&#9;local materialToImageMap = {}
&#9;local materialNames = {&quot;Grass&quot;, &quot;Sand&quot;, &quot;Brick&quot;, &quot;Granite&quot;, &quot;Asphalt&quot;, &quot;Iron&quot;, &quot;Aluminum&quot;, &quot;Gold&quot;, &quot;Plank&quot;, &quot;Log&quot;, &quot;Gravel&quot;, &quot;Cinder Block&quot;, &quot;Stone Wall&quot;, &quot;Concrete&quot;, &quot;Plastic (red)&quot;, &quot;Plastic (blue)&quot;}
&#9;if waterEnabled then
&#9;&#9;table.insert(materialNames,&quot;Water&quot;)
&#9;end
&#9;local currentMaterial = 1

&#9;function getEnumFromName(choice)
&#9;&#9;if choice == &quot;Grass&quot; then return 1 end
&#9;&#9;if choice == &quot;Sand&quot; then return 2 end 
&#9;&#9;if choice == &quot;Erase&quot; then return 0 end
&#9;&#9;if choice == &quot;Brick&quot; then return 3 end
&#9;&#9;if choice == &quot;Granite&quot; then return 4 end
&#9;&#9;if choice == &quot;Asphalt&quot; then return 5 end
&#9;&#9;if choice == &quot;Iron&quot; then return 6 end
&#9;&#9;if choice == &quot;Aluminum&quot; then return 7 end
&#9;&#9;if choice == &quot;Gold&quot; then return 8 end
&#9;&#9;if choice == &quot;Plank&quot; then return 9 end
&#9;&#9;if choice == &quot;Log&quot; then return 10 end
&#9;&#9;if choice == &quot;Gravel&quot; then return 11 end
&#9;&#9;if choice == &quot;Cinder Block&quot; then return 12 end
&#9;&#9;if choice == &quot;Stone Wall&quot; then return 13 end
&#9;&#9;if choice == &quot;Concrete&quot; then return 14 end
&#9;&#9;if choice == &quot;Plastic (red)&quot; then return 15 end
&#9;&#9;if choice == &quot;Plastic (blue)&quot; then return 16 end
&#9;&#9;if choice == &quot;Water&quot; then return 17 end
&#9;end

&#9;function getNameFromEnum(choice)
&#9;&#9;if choice == Enum.CellMaterial.Grass or choice == 1 then return &quot;Grass&quot;end
&#9;&#9;if choice == Enum.CellMaterial.Sand or choice == 2 then return &quot;Sand&quot; end 
&#9;&#9;if choice == Enum.CellMaterial.Empty or choice == 0 then return &quot;Erase&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Brick or choice == 3 then return &quot;Brick&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Granite or choice == 4 then return &quot;Granite&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Asphalt or choice == 5 then return &quot;Asphalt&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Iron or choice == 6 then return &quot;Iron&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Aluminum or choice == 7 then return &quot;Aluminum&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gold or choice == 8 then return &quot;Gold&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodPlank or choice == 9 then return &quot;Plank&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodLog or choice == 10 then return &quot;Log&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gravel or choice == 11 then return &quot;Gravel&quot; end
&#9;&#9;if choice == Enum.CellMaterial.CinderBlock or choice == 12 then return &quot;Cinder Block&quot; end
&#9;&#9;if choice == Enum.CellMaterial.MossyStone or choice == 13 then return &quot;Stone Wall&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Cement or choice == 14 then return &quot;Concrete&quot; end
&#9;&#9;if choice == Enum.CellMaterial.RedPlastic or choice == 15 then return &quot;Plastic (red)&quot; end
&#9;&#9;if choice == Enum.CellMaterial.BluePlastic or choice == 16 then return &quot;Plastic (blue)&quot; end

&#9;&#9;if waterEnabled then
&#9;&#9;&#9;if choice == Enum.CellMaterial.Water or choice == 17 then return &quot;Water&quot; end
&#9;&#9;end
&#9;end


&#9;local function updateMaterialChoice(choice)
&#9;&#9;currentMaterial = getEnumFromName(choice)
&#9;&#9;terrainMaterialSelectionChanged:Fire(currentMaterial)
&#9;end

&#9;-- we so need a better way to do this
&#9;for i,v in pairs(materialNames) do
&#9;&#9;materialToImageMap[v] = {}
&#9;&#9;if v == &quot;Grass&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Grass.png&quot;
&#9;&#9;elseif v == &quot;Sand&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Sand.png&quot;
&#9;&#9;elseif v == &quot;Brick&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Brick.png&quot;
&#9;&#9;elseif v == &quot;Granite&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Granite.png&quot;
&#9;&#9;elseif v == &quot;Asphalt&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Asphalt.png&quot;
&#9;&#9;elseif v == &quot;Iron&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Iron.png&quot;
&#9;&#9;elseif v == &quot;Aluminum&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Aluminum.png&quot;
&#9;&#9;elseif v == &quot;Gold&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Gold.png&quot;
&#9;&#9;elseif v == &quot;Plastic (red)&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/PlasticRed.png&quot;
&#9;&#9;elseif v == &quot;Plastic (blue)&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/PlasticBlue.png&quot;
&#9;&#9;elseif v == &quot;Plank&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Plank.png&quot;
&#9;&#9;elseif v == &quot;Log&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Log.png&quot;
&#9;&#9;elseif v == &quot;Gravel&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Gravel.png&quot;
&#9;&#9;elseif v == &quot;Cinder Block&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/CinderBlock.png&quot;
&#9;&#9;elseif v == &quot;Stone Wall&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/StoneWall.png&quot;
&#9;&#9;elseif v == &quot;Concrete&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Concrete.png&quot;
&#9;&#9;elseif v == &quot;Water&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Water.png&quot;
&#9;&#9;else materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/unknown.png&quot; -- fill in the rest here!!
&#9;&#9;end
&#9;end

&#9;local scrollFrame, scrollUp, scrollDown, recalculateScroll = t.CreateScrollingFrame(nil,&quot;grid&quot;)
&#9;scrollFrame.Size = UDim2.new(0.85,0,1,0)
&#9;scrollFrame.Position = UDim2.new(0,0,0,0)
&#9;scrollFrame.Parent = frame

&#9;scrollUp.Parent = frame
&#9;scrollUp.Visible = true
&#9;scrollUp.Position = UDim2.new(1,-19,0,0)

&#9;scrollDown.Parent = frame
&#9;scrollDown.Visible = true
&#9;scrollDown.Position = UDim2.new(1,-19,1,-17)

&#9;local function goToNewMaterial(buttonWrap, materialName)
&#9;&#9;updateMaterialChoice(materialName)
&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;selectedButton.BackgroundTransparency = 1
&#9;&#9;selectedButton = buttonWrap
&#9;end

&#9;local function createMaterialButton(name)&#9;
&#9;&#9;local buttonWrap = Instance.new(&quot;TextButton&quot;)
&#9;&#9;buttonWrap.Text = &quot;&quot;
&#9;&#9;buttonWrap.Size = UDim2.new(0,32,0,32)
&#9;&#9;buttonWrap.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;buttonWrap.BorderSizePixel = 0
&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;buttonWrap.AutoButtonColor = false
&#9;&#9;buttonWrap.Name = tostring(name)
&#9;&#9;
&#9;&#9;local imageButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;imageButton.AutoButtonColor = false
&#9;&#9;imageButton.BackgroundTransparency = 1
&#9;&#9;imageButton.Size = UDim2.new(0,30,0,30)
&#9;&#9;imageButton.Position = UDim2.new(0,1,0,1)
&#9;&#9;imageButton.Name = tostring(name)
&#9;&#9;imageButton.Parent = buttonWrap
&#9;&#9;imageButton.Image = materialToImageMap[name].Regular

&#9;&#9;local enumType = Instance.new(&quot;NumberValue&quot;)
&#9;&#9;enumType.Name = &quot;EnumType&quot;
&#9;&#9;enumType.Parent = buttonWrap
&#9;&#9;enumType.Value = 0
&#9;&#9;
&#9;&#9;imageButton.MouseEnter:connect(function()
&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;imageButton.MouseLeave:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;imageButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;goToNewMaterial(buttonWrap, tostring(name))
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;
&#9;&#9;return buttonWrap 
&#9;end

&#9;for i = 1, #materialNames do
&#9;&#9;local imageButton = createMaterialButton(materialNames[i])
&#9;&#9;
&#9;&#9;if materialNames[i] == &quot;Grass&quot; then -- always start with grass as the default
&#9;&#9;&#9;selectedButton = imageButton
&#9;&#9;&#9;imageButton.BackgroundTransparency = 0
&#9;&#9;end
&#9;&#9;
&#9;&#9;imageButton.Parent = scrollFrame
&#9;end

&#9;local forceTerrainMaterialSelection = function(newMaterialType)
&#9;&#9;if not newMaterialType then return end
&#9;&#9;if currentMaterial == newMaterialType then return end

&#9;&#9;local matName = getNameFromEnum(newMaterialType)
&#9;&#9;local buttons = scrollFrame:GetChildren()
&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (blue)&quot; and matName == &quot;Plastic (blue)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (red)&quot; and matName == &quot;Plastic (red)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if string.find(buttons[i].Name, matName) then
&#9;&#9;&#9;&#9;goToNewMaterial(buttons[i],matName)
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(function ( prop )
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;recalculateScroll()
&#9;&#9;end
&#9;end)

&#9;recalculateScroll()
&#9;return frame, terrainMaterialSelectionChanged, forceTerrainMaterialSelection
end

t.CreateLoadingFrame = function(name,size,position)
&#9;game:GetService(&quot;ContentProvider&quot;):Preload(&quot;rbxasset://ui/loadingbar.png&quot;)

&#9;local loadingFrame = Instance.new(&quot;Frame&quot;)
&#9;loadingFrame.Name = &quot;LoadingFrame&quot;
&#9;loadingFrame.Style = Enum.FrameStyle.RobloxRound

&#9;if size then loadingFrame.Size = size
&#9;else loadingFrame.Size = UDim2.new(0,300,0,160) end
&#9;if position then loadingFrame.Position = position 
&#9;else loadingFrame.Position = UDim2.new(0.5, -150, 0.5,-80) end

&#9;local loadingBar = Instance.new(&quot;Frame&quot;)
&#9;loadingBar.Name = &quot;LoadingBar&quot;
&#9;loadingBar.BackgroundColor3 = Color3.new(0,0,0)
&#9;loadingBar.BorderColor3 = Color3.new(79/255,79/255,79/255)
&#9;loadingBar.Position = UDim2.new(0,0,0,41)
&#9;loadingBar.Size = UDim2.new(1,0,0,30)
&#9;loadingBar.Parent = loadingFrame

&#9;&#9;local loadingGreenBar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;loadingGreenBar.Name = &quot;LoadingGreenBar&quot;
&#9;&#9;loadingGreenBar.Image = &quot;rbxasset://ui/loadingbar.png&quot;
&#9;&#9;loadingGreenBar.Position = UDim2.new(0,0,0,0)
&#9;&#9;loadingGreenBar.Size = UDim2.new(0,0,1,0)
&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;loadingGreenBar.Parent = loadingBar

&#9;&#9;local loadingPercent = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;loadingPercent.Name = &quot;LoadingPercent&quot;
&#9;&#9;loadingPercent.BackgroundTransparency = 1
&#9;&#9;loadingPercent.Position = UDim2.new(0,0,1,0)
&#9;&#9;loadingPercent.Size = UDim2.new(1,0,0,14)
&#9;&#9;loadingPercent.Font = Enum.Font.Arial
&#9;&#9;loadingPercent.Text = &quot;0%&quot;
&#9;&#9;loadingPercent.FontSize = Enum.FontSize.Size14
&#9;&#9;loadingPercent.TextColor3 = Color3.new(1,1,1)
&#9;&#9;loadingPercent.Parent = loadingBar

&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;cancelButton.Position = UDim2.new(0.5,-60,1,-40)
&#9;cancelButton.Size = UDim2.new(0,120,0,40)
&#9;cancelButton.Font = Enum.Font.Arial
&#9;cancelButton.FontSize = Enum.FontSize.Size18
&#9;cancelButton.TextColor3 = Color3.new(1,1,1)
&#9;cancelButton.Text = &quot;Cancel&quot;
&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButton
&#9;cancelButton.Parent = loadingFrame

&#9;local loadingName = Instance.new(&quot;TextLabel&quot;)
&#9;loadingName.Name = &quot;loadingName&quot;
&#9;loadingName.BackgroundTransparency = 1
&#9;loadingName.Size = UDim2.new(1,0,0,18)
&#9;loadingName.Position = UDim2.new(0,0,0,2)
&#9;loadingName.Font = Enum.Font.Arial
&#9;loadingName.Text = name
&#9;loadingName.TextColor3 = Color3.new(1,1,1)
&#9;loadingName.TextStrokeTransparency = 1
&#9;loadingName.FontSize = Enum.FontSize.Size18
&#9;loadingName.Parent = loadingFrame

&#9;local cancelButtonClicked = Instance.new(&quot;BindableEvent&quot;)
&#9;cancelButtonClicked.Name = &quot;CancelButtonClicked&quot;
&#9;cancelButtonClicked.Parent = cancelButton
&#9;cancelButton.MouseButton1Click:connect(function()
&#9;&#9;cancelButtonClicked:Fire()
&#9;end)

&#9;local updateLoadingGuiPercent = function(percent, tweenAction, tweenLength)
&#9;&#9;if percent and type(percent) ~= &quot;number&quot; then
&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent expects number as argument, got&quot;,type(percent),&quot;instead&quot;)
&#9;&#9;end

&#9;&#9;local newSize = nil
&#9;&#9;if percent &lt; 0 then
&#9;&#9;&#9;newSize = UDim2.new(0,0,1,0)
&#9;&#9;elseif percent &gt; 1 then
&#9;&#9;&#9;newSize = UDim2.new(1,0,1,0)
&#9;&#9;else
&#9;&#9;&#9;newSize = UDim2.new(percent,0,1,0)
&#9;&#9;end

&#9;&#9;if tweenAction then
&#9;&#9;&#9;if not tweenLength then
&#9;&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent is set to tween new percentage, but got no tween time length! Please pass this in as third argument&quot;)
&#9;&#9;&#9;end

&#9;&#9;&#9;if (newSize.X.Scale &gt; 0) then
&#9;&#9;&#9;&#9;loadingGreenBar.Visible = true
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function() 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (newSize.X.Scale &lt; 0) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end

&#9;&#9;else
&#9;&#9;&#9;loadingGreenBar.Size = newSize
&#9;&#9;&#9;loadingGreenBar.Visible = (newSize.X.Scale &gt; 0)
&#9;&#9;end
&#9;end

&#9;loadingGreenBar.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Size&quot; then
&#9;&#9;&#9;loadingPercent.Text = tostring( math.ceil(loadingGreenBar.Size.X.Scale * 100) ) .. &quot;%&quot;
&#9;&#9;end
&#9;end)

&#9;return loadingFrame, updateLoadingGuiPercent, cancelButtonClicked
end

t.CreatePluginFrame = function (name,size,position,scrollable,parent)
&#9;function createMenuButton(size,position,text,fontsize,name,parent)
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;,parent)
&#9;&#9;button.AutoButtonColor = false
&#9;&#9;button.Name = name
&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;button.Position = position
&#9;&#9;button.Size = size
&#9;&#9;button.Font = Enum.Font.ArialBold
&#9;&#9;button.FontSize = fontsize
&#9;&#9;button.Text =  text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.BorderSizePixel = 0
&#9;&#9;button.BackgroundColor3 = Color3.new(20/255,20/255,20/255)

&#9;&#9;button.MouseEnter:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;button.MouseLeave:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)

&#9;&#9;return button

&#9;end

&#9;local dragBar = Instance.new(&quot;Frame&quot;,parent)
&#9;dragBar.Name = tostring(name) .. &quot;DragBar&quot;
&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;dragBar.BorderColor3 = Color3.new(0,0,0)
&#9;if size then
&#9;&#9;dragBar.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,20)  + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;dragBar.Size = UDim2.new(0,183,0,20)
&#9;end
&#9;if position then
&#9;&#9;dragBar.Position = position
&#9;end
&#9;dragBar.Active = true
&#9;dragBar.Draggable = true
&#9;--dragBar.Visible = false
&#9;dragBar.MouseEnter:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(49/255,49/255,49/255)
&#9;end)
&#9;dragBar.MouseLeave:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;end)

&#9;-- plugin name label
&#9;local pluginNameLabel = Instance.new(&quot;TextLabel&quot;,dragBar)
&#9;pluginNameLabel.Name = &quot;BarNameLabel&quot;
&#9;pluginNameLabel.Text = &quot; &quot; .. tostring(name)
&#9;pluginNameLabel.TextColor3 = Color3.new(1,1,1)
&#9;pluginNameLabel.TextStrokeTransparency = 0
&#9;pluginNameLabel.Size = UDim2.new(1,0,1,0)
&#9;pluginNameLabel.Font = Enum.Font.ArialBold
&#9;pluginNameLabel.FontSize = Enum.FontSize.Size18
&#9;pluginNameLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;pluginNameLabel.BackgroundTransparency = 1

&#9;-- close button
&#9;local closeButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-16,0.5,-8),&quot;X&quot;,Enum.FontSize.Size14,&quot;CloseButton&quot;,dragBar)
&#9;local closeEvent = Instance.new(&quot;BindableEvent&quot;)
&#9;closeEvent.Name = &quot;CloseEvent&quot;
&#9;closeEvent.Parent = closeButton
&#9;closeButton.MouseButton1Click:connect(function ()
&#9;&#9;closeEvent:Fire()
&#9;&#9;closeButton.BackgroundTransparency = 1
&#9;end)

&#9;-- help button
&#9;local helpButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-51,0.5,-8),&quot;?&quot;,Enum.FontSize.Size14,&quot;HelpButton&quot;,dragBar)
&#9;local helpFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;helpFrame.Name = &quot;HelpFrame&quot;
&#9;helpFrame.BackgroundColor3 = Color3.new(0,0,0)
&#9;helpFrame.Size = UDim2.new(0,300,0,552)
&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;helpFrame.Active = true
&#9;helpFrame.BorderSizePixel = 0
&#9;helpFrame.Visible = false

&#9;helpButton.MouseButton1Click:connect(function(  )
&#9;&#9;helpFrame.Visible = not helpFrame.Visible
&#9;&#9;if helpFrame.Visible then
&#9;&#9;&#9;helpButton.Selected = true
&#9;&#9;&#9;helpButton.BackgroundTransparency = 0
&#9;&#9;&#9;local screenGui = getScreenGuiAncestor(helpFrame)
&#9;&#9;&#9;if screenGui then
&#9;&#9;&#9;&#9;if helpFrame.AbsolutePosition.X + helpFrame.AbsoluteSize.X &gt; screenGui.AbsoluteSize.X then --position on left hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(0,-5 - helpFrame.AbsoluteSize.X,0,0)
&#9;&#9;&#9;&#9;else -- position on right hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;helpButton.Selected = false
&#9;&#9;&#9;helpButton.BackgroundTransparency = 1
&#9;&#9;end
&#9;end)

&#9;local minimizeButton = createMenuButton(UDim2.new(0,16,0,17),UDim2.new(1,-34,0.5,-8),&quot;-&quot;,Enum.FontSize.Size14,&quot;MinimizeButton&quot;,dragBar)
&#9;minimizeButton.TextYAlignment = Enum.TextYAlignment.Top

&#9;local minimizeFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;minimizeFrame.Name = &quot;MinimizeFrame&quot;
&#9;minimizeFrame.BackgroundColor3 = Color3.new(73/255,73/255,73/255)
&#9;minimizeFrame.BorderColor3 = Color3.new(0,0,0)
&#9;minimizeFrame.Position = UDim2.new(0,0,1,0)
&#9;if size then
&#9;&#9;minimizeFrame.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,50) + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;minimizeFrame.Size = UDim2.new(0,183,0,50)
&#9;end
&#9;minimizeFrame.Visible = false

&#9;local minimizeBigButton = Instance.new(&quot;TextButton&quot;,minimizeFrame)
&#9;minimizeBigButton.Position = UDim2.new(0.5,-50,0.5,-20)
&#9;minimizeBigButton.Name = &quot;MinimizeButton&quot;
&#9;minimizeBigButton.Size = UDim2.new(0,100,0,40)
&#9;minimizeBigButton.Style = Enum.ButtonStyle.RobloxButton
&#9;minimizeBigButton.Font = Enum.Font.ArialBold
&#9;minimizeBigButton.FontSize = Enum.FontSize.Size18
&#9;minimizeBigButton.TextColor3 = Color3.new(1,1,1)
&#9;minimizeBigButton.Text = &quot;Show&quot;

&#9;local separatingLine = Instance.new(&quot;Frame&quot;,dragBar)
&#9;separatingLine.Name = &quot;SeparatingLine&quot;
&#9;separatingLine.BackgroundColor3 = Color3.new(115/255,115/255,115/255)
&#9;separatingLine.BorderSizePixel = 0
&#9;separatingLine.Position = UDim2.new(1,-18,0.5,-7)
&#9;separatingLine.Size = UDim2.new(0,1,0,14)

&#9;local otherSeparatingLine = separatingLine:clone()
&#9;otherSeparatingLine.Position = UDim2.new(1,-35,0.5,-7)
&#9;otherSeparatingLine.Parent = dragBar

&#9;local widgetContainer = Instance.new(&quot;Frame&quot;,dragBar)
&#9;widgetContainer.Name = &quot;WidgetContainer&quot;
&#9;widgetContainer.BackgroundTransparency = 1
&#9;widgetContainer.Position = UDim2.new(0,0,1,0)
&#9;widgetContainer.BorderColor3 = Color3.new(0,0,0)
&#9;if not scrollable then
&#9;&#9;widgetContainer.BackgroundTransparency = 0
&#9;&#9;widgetContainer.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;end

&#9;if size then
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = size
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,size.Y.Scale,size.Y.Offset)
&#9;&#9;end
&#9;else
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,163,0,400)
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,0,400)
&#9;&#9;end
&#9;end
&#9;if position then
&#9;&#9;widgetContainer.Position = position + UDim2.new(0,0,0,20)
&#9;end

&#9;local frame,control,verticalDragger = nil
&#9;if scrollable then
&#9;&#9;--frame for widgets
&#9;&#9;frame,control = t.CreateTrueScrollingFrame()
&#9;&#9;frame.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;frame.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;frame.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;frame.Active = true
&#9;&#9;frame.Parent = widgetContainer
&#9;&#9;control.Parent = dragBar
&#9;&#9;control.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;control.BorderSizePixel = 0
&#9;&#9;control.BackgroundTransparency = 0
&#9;&#9;control.Position = UDim2.new(1,-21,1,1)
&#9;&#9;if size then
&#9;&#9;&#9;control.Size = UDim2.new(0,21,size.Y.Scale,size.Y.Offset)
&#9;&#9;else
&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,400)
&#9;&#9;end
&#9;&#9;control:FindFirstChild(&quot;ScrollDownButton&quot;).Position = UDim2.new(0,0,1,-20)

&#9;&#9;local fakeLine = Instance.new(&quot;Frame&quot;,control)
&#9;&#9;fakeLine.Name = &quot;FakeLine&quot;
&#9;&#9;fakeLine.BorderSizePixel = 0
&#9;&#9;fakeLine.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;fakeLine.Size = UDim2.new(0,1,1,1)
&#9;&#9;fakeLine.Position = UDim2.new(1,0,0,0)

&#9;&#9;verticalDragger = Instance.new(&quot;TextButton&quot;,widgetContainer)
&#9;&#9;verticalDragger.ZIndex = 2
&#9;&#9;verticalDragger.AutoButtonColor = false
&#9;&#9;verticalDragger.Name = &quot;VerticalDragger&quot;
&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;verticalDragger.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;verticalDragger.Size = UDim2.new(1,20,0,20)
&#9;&#9;verticalDragger.Position = UDim2.new(0,0,1,0)
&#9;&#9;verticalDragger.Active = true
&#9;&#9;verticalDragger.Text = &quot;&quot;

&#9;&#9;local scrubFrame = Instance.new(&quot;Frame&quot;,verticalDragger)
&#9;&#9;scrubFrame.Name = &quot;ScrubFrame&quot;
&#9;&#9;scrubFrame.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;scrubFrame.BorderSizePixel = 0
&#9;&#9;scrubFrame.Position = UDim2.new(0.5,-5,0.5,0)
&#9;&#9;scrubFrame.Size = UDim2.new(0,10,0,1)
&#9;&#9;scrubFrame.ZIndex = 5
&#9;&#9;local scrubTwo = scrubFrame:clone()
&#9;&#9;scrubTwo.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;&#9;scrubTwo.Parent = verticalDragger
&#9;&#9;local scrubThree = scrubFrame:clone()
&#9;&#9;scrubThree.Position = UDim2.new(0.5,-5,0.5,2)
&#9;&#9;scrubThree.Parent = verticalDragger

&#9;&#9;local areaSoak = Instance.new(&quot;TextButton&quot;,getScreenGuiAncestor(parent))
&#9;&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;&#9;areaSoak.BackgroundTransparency = 1
&#9;&#9;areaSoak.BorderSizePixel = 0
&#9;&#9;areaSoak.Text = &quot;&quot;
&#9;&#9;areaSoak.ZIndex = 10
&#9;&#9;areaSoak.Visible = false
&#9;&#9;areaSoak.Active = true

&#9;&#9;local draggingVertical = false
&#9;&#9;local startYPos = nil
&#9;&#9;verticalDragger.MouseEnter:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(60/255,60/255,60/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseLeave:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseButton1Down:connect(function(x,y)
&#9;&#9;&#9;draggingVertical = true
&#9;&#9;&#9;areaSoak.Visible = true
&#9;&#9;&#9;startYPos = y
&#9;&#9;end)
&#9;&#9;areaSoak.MouseButton1Up:connect(function (  )
&#9;&#9;&#9;draggingVertical = false
&#9;&#9;&#9;areaSoak.Visible = false
&#9;&#9;end)
&#9;&#9;areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;if not draggingVertical then return end

&#9;&#9;&#9;local yDelta = y - startYPos
&#9;&#9;&#9;if not control.ScrollDownButton.Visible and yDelta &gt; 0 then
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;if (widgetContainer.Size.Y.Offset + yDelta) &lt; 150 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,150)
&#9;&#9;&#9;&#9;control.Size = UDim2.new (0,21,0,150)
&#9;&#9;&#9;&#9;return 
&#9;&#9;&#9;end 

&#9;&#9;&#9;startYPos = y

&#9;&#9;&#9;if widgetContainer.Size.Y.Offset + yDelta &gt;= 0 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,widgetContainer.Size.Y.Offset + yDelta)
&#9;&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,control.Size.Y.Offset + yDelta )
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end

&#9;local function switchMinimize()
&#9;&#9;minimizeFrame.Visible = not minimizeFrame.Visible
&#9;&#9;if scrollable then
&#9;&#9;&#9;frame.Visible = not frame.Visible
&#9;&#9;&#9;verticalDragger.Visible = not verticalDragger.Visible
&#9;&#9;&#9;control.Visible = not control.Visible
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Visible = not widgetContainer.Visible
&#9;&#9;end

&#9;&#9;if minimizeFrame.Visible then
&#9;&#9;&#9;minimizeButton.Text = &quot;+&quot;
&#9;&#9;else
&#9;&#9;&#9;minimizeButton.Text = &quot;-&quot;
&#9;&#9;end
&#9;end

&#9;minimizeBigButton.MouseButton1Click:connect(function (  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;minimizeButton.MouseButton1Click:connect(function(  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;if scrollable then
&#9;&#9;return dragBar, frame, helpFrame, closeEvent
&#9;else
&#9;&#9;return dragBar, widgetContainer, helpFrame, closeEvent
&#9;end
end

t.Help = 
&#9;function(funcNameOrFunc) 
&#9;&#9;--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
&#9;&#9;if funcNameOrFunc == &quot;CreatePropertyDropDownMenu&quot; or funcNameOrFunc == t.CreatePropertyDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreatePropertyDropDownMenu.  &quot; ..
&#9;&#9;&#9;&#9;   &quot;Arguments: (instance, propertyName, enumType).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: returns a container with a drop-down-box that is linked to the &apos;property&apos; field of &apos;instance&apos; which is of type &apos;enumType&apos;&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateDropDownMenu&quot; or funcNameOrFunc == t.CreateDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreateDropDownMenu.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (items, onItemSelected).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: Returns 2 results, a container to the gui object and a &apos;updateSelection&apos; function for external updating.  The container is a drop-down-box created around a list of items&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateMessageDialog&quot; or funcNameOrFunc == t.CreateMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button&quot;
&#9;&#9;end&#9;&#9;
&#9;&#9;if funcNameOrFunc == &quot;CreateStyledMessageDialog&quot; or funcNameOrFunc == t.CreateStyledMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateStyledMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, style, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button, &apos;style&apos; is a string, either Error, Notify or Confirm&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;GetFontHeight&quot; or funcNameOrFunc == t.GetFontHeight then
&#9;&#9;&#9;return &quot;Function GetFontHeight.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (font, fontSize). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: returns the size in pixels of the given font + fontSize&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;LayoutGuiObjects&quot; or funcNameOrFunc == t.LayoutGuiObjects then
&#9;&#9;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateScrollingFrame&quot; or funcNameOrFunc == t.CreateScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (orderList, style) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 4 objects, (scrollFrame, scrollUpButton, scrollDownButton, recalculateFunction).  &apos;scrollFrame&apos; can be filled with GuiObjects.  It will lay them out and allow scrollUpButton/scrollDownButton to interact with them.  Orderlist is optional (and specifies the order to layout the children.  Without orderlist, it uses the children order. style is also optional, and allows for a &apos;grid&apos; styling if style is passed &apos;grid&apos; as a string.  recalculateFunction can be called when a relayout is needed (when orderList changes)&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTrueScrollingFrame&quot; or funcNameOrFunc == t.CreateTrueScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateTrueScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (nil) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (scrollFrame, controlFrame).  &apos;scrollFrame&apos; can be filled with GuiObjects, and they will be clipped if not inside the frame&apos;s bounds. controlFrame has children scrollup and scrolldown, as well as a slider.  controlFrame can be parented to any guiobject and it will readjust itself to fit.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;AutoTruncateTextObject&quot; or funcNameOrFunc == t.AutoTruncateTextObject then
&#9;&#9;&#9;return &quot;Function AutoTruncateTextObject.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (textLabel) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (textLabel, changeText).  The &apos;textLabel&apos; input is modified to automatically truncate text (with ellipsis), if it gets too small to fit.  &apos;changeText&apos; is a function that can be used to change the text, it takes 1 string as an argument&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSlider&quot; or funcNameOrFunc == t.CreateSlider then
&#9;&#9;&#9;return &quot;Function CreateSlider.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateLoadingFrame&quot; or funcNameOrFunc == t.CreateLoadingFrame then
&#9;&#9;&#9;return &quot;Function CreateLoadingFrame.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (name, size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Creates a gui that can be manipulated to show progress for a particular action.  Name appears above the loading bar, and size and position are udim2 values (both size and position are optional arguments).  Returns 3 arguments, the first being the gui created. The second being updateLoadingGuiPercent, which is a bindable function.  This function takes one argument (two optionally), which should be a number between 0 and 1, representing the percentage the loading gui should be at.  The second argument to this function is a boolean value that if set to true will tween the current percentage value to the new percentage value, therefore our third argument is how long this tween should take. Our third returned argument is a BindableEvent, that when fired means that someone clicked the cancel button on the dialog.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTerrainMaterialSelector&quot; or funcNameOrFunc == t.CreateTerrainMaterialSelector then
&#9;&#9;&#9;return &quot;Function CreateTerrainMaterialSelector.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Size and position are UDim2 values that specifies the selector&apos;s size and position.  Both size and position are optional arguments. This method returns 3 objects (terrainSelectorGui, terrainSelected, forceTerrainSelection).  terrainSelectorGui is just the gui object that we generate with this function, parent it as you like. TerrainSelected is a BindableEvent that is fired whenever a new terrain type is selected in the gui.  ForceTerrainSelection is a function that takes an argument of Enum.CellMaterial and will force the gui to show that material as currently selected.&quot;
&#9;&#9;end
&#9;end

--RBXGUI END
&#9;
-- A couple of necessary functions
local function waitForChild(instance, name)
&#9;assert(instance)
&#9;assert(name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
&#9;return instance:FindFirstChild(name)
end
local function waitForProperty(instance, property)
&#9;assert(instance)
&#9;assert(property)
&#9;while not instance[property] do
&#9;&#9;instance.Changed:wait()
&#9;end
end

waitForChild(game,&quot;Players&quot;)
waitForProperty(game.Players,&quot;LocalPlayer&quot;)
local player = game.Players.LocalPlayer

local RbxGui, msg = t
if not RbxGui then print(&quot;could not find RbxGui!&quot;) return end

--- Begin Locals
local StaticTabName = &quot;gear&quot;

local backpack = script.Parent.Backpack
local screen = script.Parent

local backpackItems = {}
local buttons = {}

local debounce = false
local browsingMenu = false

local mouseEnterCons = {}
local mouseClickCons = {}

local characterChildAddedCon = nil
local characterChildRemovedCon = nil
local backpackAddCon = nil

local playerBackpack = waitForChild(player,&quot;Backpack&quot;)

waitForChild(backpack,&quot;Tabs&quot;)

waitForChild(backpack,&quot;Gear&quot;)
local gearPreview = waitForChild(backpack.Gear,&quot;GearPreview&quot;)

local scroller = waitForChild(backpack.Gear,&quot;GearGridScrollingArea&quot;)

local currentLoadout = waitForChild(backpack.Parent,&quot;CurrentLoadout&quot;)

local grid = waitForChild(backpack.Gear,&quot;GearGrid&quot;)
local gearButton = waitForChild(grid,&quot;GearButton&quot;)

local swapSlot = waitForChild(script.Parent,&quot;SwapSlot&quot;)

local backpackManager = waitForChild(script.Parent,&quot;CoreScripts/BackpackScripts/BackpackManager&quot;)
local backpackOpenEvent = waitForChild(backpackManager,&quot;BackpackOpenEvent&quot;)
local backpackCloseEvent = waitForChild(backpackManager,&quot;BackpackCloseEvent&quot;)
local tabClickedEvent = waitForChild(backpackManager,&quot;TabClickedEvent&quot;)
local resizeEvent = waitForChild(backpackManager,&quot;ResizeEvent&quot;)
local searchRequestedEvent = waitForChild(backpackManager,&quot;SearchRequestedEvent&quot;)
local tellBackpackReadyFunc = waitForChild(backpackManager,&quot;BackpackReady&quot;)

-- creating scroll bar early as to make sure items get placed correctly
local scrollFrame, scrollUp, scrollDown, recalculateScroll = RbxGui.CreateScrollingFrame(nil,&quot;grid&quot;)

scrollFrame.Position = UDim2.new(0,0,0,30)
scrollFrame.Size = UDim2.new(1,0,1,-30)
scrollFrame.Parent = backpack.Gear.GearGrid

local scrollBar = Instance.new(&quot;Frame&quot;)
scrollBar.Name = &quot;ScrollBar&quot;
scrollBar.BackgroundTransparency = 0.9
scrollBar.BackgroundColor3 = Color3.new(1,1,1)
scrollBar.BorderSizePixel = 0
scrollBar.Size = UDim2.new(0, 17, 1, -36)
scrollBar.Position = UDim2.new(0,0,0,18)
scrollBar.Parent = scroller

scrollDown.Position = UDim2.new(0,0,1,-17)

scrollUp.Parent = scroller
scrollDown.Parent = scroller

local scrollFrameLoadout, scrollUpLoadout, scrollDownLoadout, recalculateScrollLoadout = RbxGui.CreateScrollingFrame()

scrollFrameLoadout.Position = UDim2.new(0,0,0,0)
scrollFrameLoadout.Size = UDim2.new(1,0,1,0)
scrollFrameLoadout.Parent = backpack.Gear.GearLoadouts.LoadoutsList

local LoadoutButton = Instance.new(&quot;TextButton&quot;)

LoadoutButton.Name = &quot;LoadoutButton&quot;
LoadoutButton.Font = Enum.Font.ArialBold
LoadoutButton.FontSize = Enum.FontSize.Size14
LoadoutButton.Position = UDim2.new(0,0,0,0)
LoadoutButton.Size = UDim2.new(1,0,0,32)
LoadoutButton.Style = Enum.ButtonStyle.RobloxButton
LoadoutButton.Text = &quot;Loadout #1&quot;
LoadoutButton.TextColor3 = Color3.new(1,1,1)
LoadoutButton.Parent = scrollFrameLoadout

local LoadoutButtonTwo = LoadoutButton:clone()
LoadoutButtonTwo.Text = &quot;Loadout #2&quot;
LoadoutButtonTwo.Parent = scrollFrameLoadout

local LoadoutButtonThree = LoadoutButton:clone()
LoadoutButtonThree.Text = &quot;Loadout #3&quot;
LoadoutButtonThree.Parent = scrollFrameLoadout

local LoadoutButtonFour = LoadoutButton:clone()
LoadoutButtonFour.Text = &quot;Loadout #4&quot;
LoadoutButtonFour.Parent = scrollFrameLoadout

local scrollBarLoadout = Instance.new(&quot;Frame&quot;)
scrollBarLoadout.Name = &quot;ScrollBarLoadout&quot;
scrollBarLoadout.BackgroundTransparency = 0.9
scrollBarLoadout.BackgroundColor3 = Color3.new(1,1,1)
scrollBarLoadout.BorderSizePixel = 0
scrollBarLoadout.Size = UDim2.new(0, 17, 1, -36)
scrollBarLoadout.Position = UDim2.new(0,0,0,18)
scrollBarLoadout.Parent = backpack.Gear.GearLoadouts.GearLoadoutsScrollingArea

scrollDownLoadout.Position = UDim2.new(0,0,1,-17)

scrollUpLoadout.Parent = backpack.Gear.GearLoadouts.GearLoadoutsScrollingArea
scrollDownLoadout.Parent = backpack.Gear.GearLoadouts.GearLoadoutsScrollingArea


-- Begin Functions
function removeFromMap(map,object)
&#9;for i = 1, #map do
&#9;&#9;if map[i] == object then
&#9;&#9;&#9;table.remove(map,i)
&#9;&#9;&#9;break
&#9;&#9;end
&#9;end
end

function robloxLock(instance)
end

function resize()
&#9;local size = 0
&#9;if gearPreview.AbsoluteSize.Y &gt; gearPreview.AbsoluteSize.X then
&#9;&#9;size = gearPreview.AbsoluteSize.X * 0.75
&#9;else
&#9;&#9;size = gearPreview.AbsoluteSize.Y * 0.75
&#9;end

&#9;waitForChild(gearPreview,&quot;GearImage&quot;)
&#9;gearPreview.GearImage.Size = UDim2.new(0,size,0,size)
&#9;gearPreview.GearImage.Position = UDim2.new(0,gearPreview.AbsoluteSize.X/2 - size/2,0.75,-size)
&#9;
&#9;resizeGrid()
end

function addToGrid(child)
&#9;if not child:IsA(&quot;Tool&quot;) then
&#9;&#9;if not child:IsA(&quot;HopperBin&quot;) then 
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end
&#9;if child:FindFirstChild(&quot;RobloxBuildTool&quot;) then return end
&#9;
&#9;for i,v in pairs(backpackItems) do  -- check to see if we already have this gear registered
&#9;&#9;if v == child then return end
&#9;end

&#9;table.insert(backpackItems,child)
&#9;
&#9;local changeCon = child.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Name&quot; then
&#9;&#9;&#9;if buttons[child] then
&#9;&#9;&#9;&#9;if buttons[child].Image == &quot;&quot; then
&#9;&#9;&#9;&#9;&#9;buttons[child].GearText.Text = child.Name
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;local ancestryCon = nil
&#9;ancestryCon = child.AncestryChanged:connect(function(theChild,theParent)
&#9;&#9;local thisObject = nil
&#9;&#9;for k,v in pairs(backpackItems) do
&#9;&#9;&#9;if v == child then
&#9;&#9;&#9;&#9;thisObject = v
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;waitForProperty(player,&quot;Character&quot;)
&#9;&#9;waitForChild(player,&quot;Backpack&quot;)
&#9;&#9;if (child.Parent ~= player.Backpack and child.Parent ~= player.Character) then
&#9;&#9;&#9;if ancestryCon then ancestryCon:disconnect() end
&#9;&#9;&#9;if changeCon then changeCon:disconnect() end
&#9;&#9;&#9;
&#9;&#9;&#9;for k,v in pairs(backpackItems) do
&#9;&#9;&#9;&#9;if v == thisObject then
&#9;&#9;&#9;&#9;&#9;if mouseEnterCons[buttons[v]] then mouseEnterCons[buttons[v]]:disconnect() end
&#9;&#9;&#9;&#9;&#9;if mouseClickCons[buttons[v]] then mouseClickCons[buttons[v]]:disconnect() end
&#9;&#9;&#9;&#9;&#9;buttons[v].Parent = nil
&#9;&#9;&#9;&#9;&#9;buttons[v] = nil
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;removeFromMap(backpackItems,thisObject)
&#9;&#9;&#9;
&#9;&#9;&#9;resizeGrid()
&#9;&#9;else
&#9;&#9;&#9;resizeGrid()
&#9;&#9;end
&#9;&#9;updateGridActive()
&#9;end)
&#9;resizeGrid()
end

function buttonClick(button)
&#9;if button:FindFirstChild(&quot;UnequipContextMenu&quot;) and not button.Active then
&#9;&#9;button.UnequipContextMenu.Visible = true
&#9;&#9;browsingMenu = true
&#9;end
end

function previewGear(button)
&#9;if not browsingMenu then
&#9;&#9;gearPreview.GearImage.Image = button.Image
&#9;&#9;gearPreview.GearStats.GearName.Text = button.GearReference.Value.Name
&#9;end
end

function findEmptySlot()
&#9;local smallestNum = nil
&#9;local loadout = currentLoadout:GetChildren()
&#9;for i = 1, #loadout do
&#9;&#9;if loadout[i]:IsA(&quot;Frame&quot;) and #loadout[i]:GetChildren() &lt;= 0 then
&#9;&#9;&#9;local frameNum = tonumber(string.sub(loadout[i].Name,5))
&#9;&#9;&#9;if frameNum == 0 then frameNum = 10 end
&#9;&#9;&#9;if not smallestNum or (smallestNum &gt; frameNum) then
&#9;&#9;&#9;&#9;smallestNum = frameNum
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;if smallestNum == 10 then smallestNum = 0 end
&#9;return smallestNum
end

function checkForSwap(button,x,y)
&#9;local loadoutChildren = currentLoadout:GetChildren()
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) and string.find(loadoutChildren[i].Name,&quot;Slot&quot;) then
&#9;&#9;&#9;if x &gt;= loadoutChildren[i].AbsolutePosition.x and x &lt;= (loadoutChildren[i].AbsolutePosition.x + loadoutChildren[i].AbsoluteSize.x) then
&#9;&#9;&#9;&#9;if y &gt;= loadoutChildren[i].AbsolutePosition.y and y &lt;= (loadoutChildren[i].AbsolutePosition.y + loadoutChildren[i].AbsoluteSize.y) then
&#9;&#9;&#9;&#9;&#9;local slot = tonumber(string.sub(loadoutChildren[i].Name,5))
&#9;&#9;&#9;&#9;&#9;swapGearSlot(slot,button)
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return false
end

function resizeGrid()
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if not v:FindFirstChild(&quot;RobloxBuildTool&quot;) then
&#9;&#9;&#9;if not buttons[v] then
&#9;&#9;&#9;&#9;local buttonClone = gearButton:clone()
&#9;&#9;&#9;&#9;buttonClone.Parent = grid.ScrollingFrame
&#9;&#9;&#9;&#9;buttonClone.Visible = true
&#9;&#9;&#9;&#9;buttonClone.Image = v.TextureId
&#9;&#9;&#9;&#9;if buttonClone.Image == &quot;&quot; then
&#9;&#9;&#9;&#9;&#9;buttonClone.GearText.Text = v.Name
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;buttonClone.GearReference.Value = v
&#9;&#9;&#9;&#9;buttonClone.Draggable = true 
&#9;&#9;&#9;&#9;buttons[v] = buttonClone
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local unequipMenu = getGearContextMenu()
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;unequipMenu.Visible = false
&#9;&#9;&#9;&#9;unequipMenu.Parent = buttonClone
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local beginPos = nil
&#9;&#9;&#9;&#9;buttonClone.DragBegin:connect(function(value)
&#9;&#9;&#9;&#9;&#9;buttonClone.ZIndex = 9
&#9;&#9;&#9;&#9;&#9;beginPos = value
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;buttonClone.DragStopped:connect(function(x,y)
&#9;&#9;&#9;&#9;&#9;buttonClone.ZIndex = 1
&#9;&#9;&#9;&#9;&#9;if beginPos ~= buttonClone.Position then
&#9;&#9;&#9;&#9;&#9;&#9;if not checkForSwap(buttonClone,x,y) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone:TweenPosition(beginPos,Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.5, true)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.Draggable = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;delay(0.5,function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.Draggable = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.Position = beginPos
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end&#9;
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;local clickTime = tick()
&#9;&#9;&#9;&#9;mouseEnterCons[buttonClone] = buttonClone.MouseEnter:connect(function() previewGear(buttonClone) end)
&#9;&#9;&#9;&#9;mouseClickCons[buttonClone] = buttonClone.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;local newClickTime = tick()
&#9;&#9;&#9;&#9;&#9;if buttonClone.Active and (newClickTime - clickTime) &lt; 0.5 then
&#9;&#9;&#9;&#9;&#9;&#9;local slot = findEmptySlot()
&#9;&#9;&#9;&#9;&#9;&#9;if slot then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.ZIndex = 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;swapGearSlot(slot,buttonClone)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;buttonClick(buttonClone)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;clickTime = newClickTime
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;recalculateScroll()
end

function showPartialGrid(subset)
&#9;for k,v in pairs(buttons) do
&#9;&#9;v.Parent = nil
&#9;end
&#9;if subset then
&#9;&#9;for k,v in pairs(subset) do
&#9;&#9;&#9;v.Parent =  grid.ScrollingFrame
&#9;&#9;end
&#9;end
&#9;recalculateScroll()
end

function showEntireGrid()
&#9;for k,v in pairs(buttons) do
&#9;&#9;v.Parent = grid.ScrollingFrame
&#9;end
&#9;recalculateScroll()
end

function inLoadout(gear)
&#9;local children = currentLoadout:GetChildren()
&#9;for i = 1, #children do
&#9;&#9;if children[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;local button = children[i]:GetChildren()
&#9;&#9;&#9;if #button &gt; 0 then
&#9;&#9;&#9;&#9;if button[1].GearReference.Value and button[1].GearReference.Value == gear then
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return false
end&#9;

function updateGridActive()
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if buttons[v] then
&#9;&#9;&#9;local gear = nil
&#9;&#9;&#9;local gearRef = buttons[v]:FindFirstChild(&quot;GearReference&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;if gearRef then gear = gearRef.Value end
&#9;&#9;&#9;
&#9;&#9;&#9;if not gear then
&#9;&#9;&#9;&#9;buttons[v].Active = false
&#9;&#9;&#9;elseif inLoadout(gear) then
&#9;&#9;&#9;&#9;buttons[v].Active = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;buttons[v].Active = true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function centerGear(loadoutChildren)
&#9;local gearButtons = {}
&#9;local lastSlotAdd = nil
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) and #loadoutChildren[i]:GetChildren() &gt; 0 then
&#9;&#9;&#9;if loadoutChildren[i].Name == &quot;Slot0&quot; then 
&#9;&#9;&#9;&#9;lastSlotAdd = loadoutChildren[i]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;table.insert(gearButtons, loadoutChildren[i])
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;if lastSlotAdd then table.insert(gearButtons,lastSlotAdd) end
&#9;
&#9;local startPos = ( 1 - (#gearButtons * 0.1) ) / 2
&#9;for i = 1, #gearButtons do&#9;
&#9;&#9;gearButtons[i]:TweenPosition(UDim2.new(startPos + ((i - 1) * 0.1),0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.25, true)
&#9;end
end

function tabClickHandler(tabName)
&#9;if tabName == StaticTabName then
&#9;&#9;backpackOpenHandler(tabName)
&#9;else
&#9;&#9;backpackCloseHandler(tabName)
&#9;end
end

function backpackOpenHandler(currentTab)
&#9;if currentTab and currentTab ~= StaticTabName then 
&#9;&#9;backpack.Gear.Visible = false
&#9;&#9;return
&#9;end
&#9;
&#9;backpack.Gear.Visible = true
&#9;updateGridActive()

&#9;resizeGrid()
&#9;resize()
&#9;tellBackpackReadyFunc:Invoke()
end

function backpackCloseHandler(currentTab)
&#9;if currentTab and currentTab ~= StaticTabName then
&#9;&#9;backpack.Gear.Visible = false
&#9;&#9;return
&#9;end
&#9;
&#9;backpack.Gear.Visible = false

&#9;resizeGrid()
&#9;resize()
&#9;tellBackpackReadyFunc:Invoke()
end

function loadoutCheck(child, selectState)
&#9;if not child:IsA(&quot;ImageButton&quot;) then return end
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if buttons[v] then
&#9;&#9;&#9;if child:FindFirstChild(&quot;GearReference&quot;) and buttons[v]:FindFirstChild(&quot;GearReference&quot;) then
&#9;&#9;&#9;&#9;if buttons[v].GearReference.Value == child.GearReference.Value then
&#9;&#9;&#9;&#9;&#9;buttons[v].Active = selectState
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function clearPreview()
&#9;gearPreview.GearImage.Image = &quot;&quot;
&#9;gearPreview.GearStats.GearName.Text = &quot;&quot;
end

function removeAllEquippedGear(physGear)
&#9;local stuff = player.Character:GetChildren()
&#9;for i = 1, #stuff do
&#9;&#9;if ( stuff[i]:IsA(&quot;Tool&quot;) or stuff[i]:IsA(&quot;HopperBin&quot;) ) and stuff[i] ~= physGear then
&#9;&#9;&#9;stuff[i].Parent = playerBackpack
&#9;&#9;end
&#9;end
end

function equipGear(physGear)
&#9;removeAllEquippedGear(physGear)
&#9;physGear.Parent = player.Character
&#9;updateGridActive()
end

function unequipGear(physGear)
&#9;physGear.Parent = playerBackpack
&#9;updateGridActive()
end

function highlight(button)
&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;button.BackgroundColor3 = Color3.new(0.8,0.8,0.8)
end
function clearHighlight(button)
&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;button.BackgroundColor3 = Color3.new(0,0,0)
end

function swapGearSlot(slot,gearButton)
&#9;if not swapSlot.Value then -- signal loadout to swap a gear out
&#9;&#9;swapSlot.Slot.Value = slot
&#9;&#9;swapSlot.GearButton.Value = gearButton
&#9;&#9;swapSlot.Value = true
&#9;&#9;updateGridActive()
&#9;end
end


local UnequipGearMenuClick = function(element, menu)
&#9;if type(element.Action) ~= &quot;number&quot; then return end
&#9;local num = element.Action
&#9;if num == 1 then -- remove from loadout
&#9;&#9;unequipGear(menu.Parent.GearReference.Value)
&#9;&#9;local inventoryButton = menu.Parent
&#9;&#9;local gearToUnequip = inventoryButton.GearReference.Value
&#9;&#9;local loadoutChildren = currentLoadout:GetChildren()
&#9;&#9;local slot = -1
&#9;&#9;for i = 1, #loadoutChildren do
&#9;&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;local button = loadoutChildren[i]:GetChildren()
&#9;&#9;&#9;&#9;if button[1] and button[1].GearReference.Value == gearToUnequip then
&#9;&#9;&#9;&#9;&#9;slot = button[1].SlotNumber.Text
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;swapGearSlot(slot,nil)
&#9;end
end

function setupCharacterConnections()

&#9;if backpackAddCon then backpackAddCon:disconnect() end
&#9;backpackAddCon = game.Players.LocalPlayer.Backpack.ChildAdded:connect(function(child) addToGrid(child) end)
&#9;
&#9;-- make sure we get all the children
&#9;local backpackChildren = game.Players.LocalPlayer.Backpack:GetChildren()
&#9;for i = 1, #backpackChildren do
&#9;&#9;addToGrid(backpackChildren[i])
&#9;end

&#9;if characterChildAddedCon then characterChildAddedCon:disconnect() end
&#9;characterChildAddedCon = 
&#9;&#9;game.Players.LocalPlayer.Character.ChildAdded:connect(function(child)
&#9;&#9;&#9;addToGrid(child)
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;&#9;
&#9;if characterChildRemovedCon then characterChildRemovedCon:disconnect() end
&#9;characterChildRemovedCon = 
&#9;&#9;game.Players.LocalPlayer.Character.ChildRemoved:connect(function(child)
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)

&#9;wait()
&#9;centerGear(currentLoadout:GetChildren())
end

function removeCharacterConnections()
&#9;if characterChildAddedCon then characterChildAddedCon:disconnect() end
&#9;if characterChildRemovedCon then characterChildRemovedCon:disconnect() end
&#9;if backpackAddCon then backpackAddCon:disconnect() end
end

function trim(s)
  return (s:gsub(&quot;^%s*(.-)%s*$&quot;, &quot;%1&quot;))
end

function filterGear(terms)
&#9;local filteredGear = {}
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if buttons[v] then
&#9;&#9;&#9;local gearString = string.lower(buttons[v].GearReference.Value.Name)
&#9;&#9;&#9;gearString = trim(gearString)
&#9;&#9;&#9;for i = 1, #terms do
&#9;&#9;&#9;&#9;if string.match(gearString,terms[i]) then
&#9;&#9;&#9;&#9;&#9;table.insert(filteredGear,buttons[v])
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;return filteredGear
end
function splitByWhitespace(text)
&#9;if type(text) ~= &quot;string&quot; then return nil end
&#9;
&#9;local terms = {}
&#9;for token in string.gmatch(text, &quot;[^%s]+&quot;) do
&#9;   if string.len(token) &gt; 0 then
&#9;&#9;&#9;table.insert(terms,token)
&#9;   end
&#9;end
&#9;return terms
end
function showSearchGear(searchTerms)
&#9;if not backpack.Gear.Visible then return end -- currently not active tab

&#9;local searchTermTable = splitByWhitespace(searchTerms)
&#9;if searchTermTable and (#searchTermTable &gt; 0) then
&#9;&#9;currSearchTerms = searchTermTable
&#9;else
&#9;&#9;currSearchTerms = nil
&#9;end

&#9;if searchTermTable == nil then
&#9;&#9;showEntireGrid()
&#9;&#9;return
&#9;end

&#9;local filteredButtons = filterGear(currSearchTerms)
&#9;showPartialGrid(filteredButtons)
end

function nukeBackpack()
&#9;while #buttons &gt; 0 do
&#9;&#9;table.remove(buttons)
&#9;end
&#9;buttons = {}
&#9;while #backpackItems &gt; 0 do
&#9;&#9;table.remove(backpackItems)
&#9;end
&#9;backpackItems = {}
&#9;local scrollingFrameChildren = grid.ScrollingFrame:GetChildren()
&#9;for i = 1, #scrollingFrameChildren do
&#9;&#9;scrollingFrameChildren[i]:remove()
&#9;end
end

function getGearContextMenu()
&#9;local gearContextMenu = Instance.new(&quot;Frame&quot;)
&#9;gearContextMenu.Active = true
&#9;gearContextMenu.Name = &quot;UnequipContextMenu&quot;
&#9;gearContextMenu.Size = UDim2.new(0,115,0,70)
&#9;gearContextMenu.Position = UDim2.new(0,-16,0,-16)
&#9;gearContextMenu.BackgroundTransparency = 1
&#9;gearContextMenu.Visible = false

&#9;local gearContextMenuButton = Instance.new(&quot;TextButton&quot;)
&#9;gearContextMenuButton.Name = &quot;UnequipContextMenuButton&quot;
&#9;gearContextMenuButton.Text = &quot;&quot;
&#9;gearContextMenuButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;gearContextMenuButton.ZIndex = 8
&#9;gearContextMenuButton.Size = UDim2.new(1, 0, 1, -20)
&#9;gearContextMenuButton.Visible = true
&#9;gearContextMenuButton.Parent = gearContextMenu
&#9;
&#9;local elementHeight = 12
&#9;
&#9;local contextMenuElements = {}&#9;&#9;
&#9;local contextMenuElementsName = {&quot;Remove Hotkey&quot;}

&#9;for i = 1, #contextMenuElementsName do
&#9;&#9;local element = {}
&#9;&#9;element.Type = &quot;Button&quot;
&#9;&#9;element.Text = contextMenuElementsName[i]
&#9;&#9;element.Action = i
&#9;&#9;element.DoIt = UnequipGearMenuClick
&#9;&#9;table.insert(contextMenuElements,element)
&#9;end

&#9;for i, contextElement in ipairs(contextMenuElements) do
&#9;&#9;local element = contextElement
&#9;&#9;if element.Type == &quot;Button&quot; then
&#9;&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;button.Name = &quot;UnequipContextButton&quot; .. i
&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;button.BorderSizePixel = 0
&#9;&#9;&#9;button.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;button.Text = &quot; &quot; .. contextElement.Text
&#9;&#9;&#9;button.Font = Enum.Font.Arial
&#9;&#9;&#9;button.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;button.Size = UDim2.new(1, 8, 0, elementHeight)
&#9;&#9;&#9;button.Position = UDim2.new(0,0,0,elementHeight * i)
&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;button.ZIndex = 9
&#9;&#9;&#9;button.Parent = gearContextMenuButton

&#9;&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;if button.Active and not gearContextMenu.Parent.Active then
&#9;&#9;&#9;&#9;&#9;local success, result = pcall(function() element.DoIt(element, gearContextMenu) end)
&#9;&#9;&#9;&#9;&#9;browsingMenu = false
&#9;&#9;&#9;&#9;&#9;gearContextMenu.Visible = false
&#9;&#9;&#9;&#9;&#9;clearHighlight(button)
&#9;&#9;&#9;&#9;&#9;clearPreview()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;if button.Active and gearContextMenu.Parent.Active then
&#9;&#9;&#9;&#9;&#9;highlight(button)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;if button.Active and gearContextMenu.Parent.Active then
&#9;&#9;&#9;&#9;&#9;clearHighlight(button)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;contextElement.Button = button
&#9;&#9;&#9;contextElement.Element = button
&#9;&#9;elseif element.Type == &quot;Label&quot; then
&#9;&#9;&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;frame.Name = &quot;ContextLabel&quot; .. i
&#9;&#9;&#9;frame.BackgroundTransparency = 1
&#9;&#9;&#9;frame.Size = UDim2.new(1, 8, 0, elementHeight)

&#9;&#9;&#9;local label = Instance.new(&quot;TextLabel&quot;)&#9;
&#9;&#9;&#9;label.Name = &quot;Text1&quot;
&#9;&#9;&#9;label.BackgroundTransparency = 1
&#9;&#9;&#9;label.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;label.BorderSizePixel = 0
&#9;&#9;&#9;label.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;label.Font = Enum.Font.ArialBold
&#9;&#9;&#9;label.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;label.Position = UDim2.new(0.0, 0, 0, 0)
&#9;&#9;&#9;label.Size = UDim2.new(0.5, 0, 1, 0)
&#9;&#9;&#9;label.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;label.ZIndex = 9
&#9;&#9;&#9;label.Parent = frame
&#9;&#9;&#9;element.Label1 = label
&#9;&#9;
&#9;&#9;&#9;if element.GetText2 then
&#9;&#9;&#9;&#9;label = Instance.new(&quot;TextLabel&quot;)&#9;
&#9;&#9;&#9;&#9;label.Name = &quot;Text2&quot;
&#9;&#9;&#9;&#9;label.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;label.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;label.BorderSizePixel = 0
&#9;&#9;&#9;&#9;label.TextXAlignment = Enum.TextXAlignment.Right
&#9;&#9;&#9;&#9;label.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;label.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;&#9;label.Position = UDim2.new(0.5, 0, 0, 0)
&#9;&#9;&#9;&#9;label.Size = UDim2.new(0.5, 0, 1, 0)
&#9;&#9;&#9;&#9;label.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;label.ZIndex = 9
&#9;&#9;&#9;&#9;label.Parent = frame
&#9;&#9;&#9;&#9;element.Label2 = label
&#9;&#9;&#9;end
&#9;&#9;&#9;frame.Parent = gearContextMenuButton
&#9;&#9;&#9;element.Label = frame
&#9;&#9;&#9;element.Element =  frame
&#9;&#9;end
&#9;end

&#9;gearContextMenu.ZIndex = 4
&#9;gearContextMenu.MouseLeave:connect(function()
&#9;&#9;browsingMenu = false
&#9;&#9;gearContextMenu.Visible = false
&#9;&#9;clearPreview()
&#9;end)

&#9;
&#9;return gearContextMenu
end

local backpackChildren = player.Backpack:GetChildren()
for i = 1, #backpackChildren do
&#9;addToGrid(backpackChildren[i])
end

------------------------- Start Lifelong Connections -----------------------


resizeEvent.Event:connect(function(absSize)
&#9;if debounce then return end
&#9;
&#9;debounce = true
&#9;wait()
&#9;resize()
&#9;resizeGrid()
&#9;debounce = false
end)

currentLoadout.ChildAdded:connect(function(child) loadoutCheck(child, false) end)
currentLoadout.ChildRemoved:connect(function(child) loadoutCheck(child, true) end)

currentLoadout.DescendantAdded:connect(function(descendant)
&#9;if not backpack.Visible and ( descendant:IsA(&quot;ImageButton&quot;) or descendant:IsA(&quot;TextButton&quot;) ) then
&#9;&#9;centerGear(currentLoadout:GetChildren())
&#9;end
end)
currentLoadout.DescendantRemoving:connect(function(descendant)
&#9;if not backpack.Visible and ( descendant:IsA(&quot;ImageButton&quot;) or descendant:IsA(&quot;TextButton&quot;) ) then
&#9;&#9;wait()
&#9;&#9;centerGear(currentLoadout:GetChildren())
&#9;end
end)
&#9;
grid.MouseEnter:connect(function() clearPreview() end)
grid.MouseLeave:connect(function() clearPreview() end)

player.CharacterRemoving:connect(function()
&#9;removeCharacterConnections()
&#9;nukeBackpack()
end)
player.CharacterAdded:connect(function() setupCharacterConnections() end)

player.ChildAdded:connect(function(child)
&#9;if child:IsA(&quot;Backpack&quot;) then
&#9;&#9;playerBackpack = child
&#9;&#9;if backpackAddCon then backpackAddCon:disconnect() end
&#9;&#9;backpackAddCon = game.Players.LocalPlayer.Backpack.ChildAdded:connect(function(child) addToGrid(child) end)
&#9;end
end)

swapSlot.Changed:connect(function()
&#9;if not swapSlot.Value then
&#9;&#9;updateGridActive()
&#9;end
end)

local loadoutChildren = currentLoadout:GetChildren()
for i = 1, #loadoutChildren do
&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) and string.find(loadoutChildren[i].Name,&quot;Slot&quot;) then
&#9;&#9;loadoutChildren[i].ChildRemoved:connect(function()
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;&#9;loadoutChildren[i].ChildAdded:connect(function()
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;end
end
------------------------- End Lifelong Connections -----------------------

resize()
resizeGrid()

-- make sure any items in the loadout are accounted for in inventory
local loadoutChildren = currentLoadout:GetChildren()
for i = 1, #loadoutChildren do
&#9;loadoutCheck(loadoutChildren[i], false)
end
if not backpack.Visible then centerGear(currentLoadout:GetChildren()) end

-- make sure that inventory is listening to gear reparenting
if characterChildAddedCon == nil and game.Players.LocalPlayer[&quot;Character&quot;] then
&#9;setupCharacterConnections()
end
if not backpackAddCon then
&#9;backpackAddCon = game.Players.LocalPlayer.Backpack.ChildAdded:connect(function(child) addToGrid(child) end)
end

backpackOpenEvent.Event:connect(backpackOpenHandler)
backpackCloseEvent.Event:connect(backpackCloseHandler)
tabClickedEvent.Event:connect(tabClickHandler)
searchRequestedEvent.Event:connect(showSearchGear)

recalculateScrollLoadout()</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX10">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">BackpackResizer</string>
					<ProtectedString name="Source">print(&quot;Making sure BackpackResizer script is doing it&apos;s work...&quot;)
print(&quot;Backpack has been built. Time for the resizer script.&quot;)
script.Parent.BackpackResizer.Parent = script.Parent.Backpack
local t = {}

local function ScopedConnect(parentInstance, instance, event, signalFunc, syncFunc, removeFunc)
&#9;local eventConnection = nil

&#9;--Connection on parentInstance is scoped by parentInstance (when destroyed, it goes away)
&#9;local tryConnect = function()
&#9;&#9;if game:IsAncestorOf(parentInstance) then
&#9;&#9;&#9;--Entering the world, make sure we are connected/synced
&#9;&#9;&#9;if not eventConnection then
&#9;&#9;&#9;&#9;eventConnection = instance[event]:connect(signalFunc)
&#9;&#9;&#9;&#9;if syncFunc then syncFunc() end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;--Probably leaving the world, so disconnect for now
&#9;&#9;&#9;if eventConnection then
&#9;&#9;&#9;&#9;eventConnection:disconnect()
&#9;&#9;&#9;&#9;if removeFunc then removeFunc() end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;--Hook it up to ancestryChanged signal
&#9;local connection = parentInstance.AncestryChanged:connect(tryConnect)
&#9;
&#9;--Now connect us if we&apos;re already in the world
&#9;tryConnect()
&#9;
&#9;return connection
end

local function getScreenGuiAncestor(instance)
&#9;local localInstance = instance
&#9;while localInstance and not localInstance:IsA(&quot;ScreenGui&quot;) do
&#9;&#9;localInstance = localInstance.Parent
&#9;end
&#9;return localInstance
end

local function CreateButtons(frame, buttons, yPos, ySize)
&#9;local buttonNum = 1
&#9;local buttonObjs = {}
&#9;for i, obj in ipairs(buttons) do 
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot; .. buttonNum
&#9;&#9;button.Font = Enum.Font.Arial
&#9;&#9;button.FontSize = Enum.FontSize.Size18
&#9;&#9;button.AutoButtonColor = true
&#9;&#9;button.Modal = true
&#9;&#9;if obj[&quot;Style&quot;] then
&#9;&#9;&#9;button.Style = obj.Style
&#9;&#9;else
&#9;&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;end
&#9;&#9;button.Text = obj.Text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.MouseButton1Click:connect(obj.Function)
&#9;&#9;button.Parent = frame
&#9;&#9;buttonObjs[buttonNum] = button

&#9;&#9;buttonNum = buttonNum + 1
&#9;end
&#9;local numButtons = buttonNum-1

&#9;if numButtons == 1 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.35, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.4,0,ySize.Scale, ySize.Offset)
&#9;elseif numButtons == 2 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.1, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.8/3,0, ySize.Scale, ySize.Offset)

&#9;&#9;frame.Button2.Position = UDim2.new(0.55, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button2.Size = UDim2.new(.35,0, ySize.Scale, ySize.Offset)
&#9;elseif numButtons &gt;= 3 then
&#9;&#9;local spacing = .1 / numButtons
&#9;&#9;local buttonSize = .9 / numButtons

&#9;&#9;buttonNum = 1
&#9;&#9;while buttonNum &lt;= numButtons do
&#9;&#9;&#9;buttonObjs[buttonNum].Position = UDim2.new(spacing*buttonNum + (buttonNum-1) * buttonSize, 0, yPos.Scale, yPos.Offset)
&#9;&#9;&#9;buttonObjs[buttonNum].Size = UDim2.new(buttonSize, 0, ySize.Scale, ySize.Offset)
&#9;&#9;&#9;buttonNum = buttonNum + 1
&#9;&#9;end
&#9;end
end

local function setSliderPos(newAbsPosX,slider,sliderPosition,bar,steps)

&#9;local newStep = steps - 1 --otherwise we really get one more step than we want
&#9;local relativePosX = math.min(1, math.max(0, (newAbsPosX - bar.AbsolutePosition.X) / bar.AbsoluteSize.X ))
&#9;local wholeNum, remainder = math.modf(relativePosX * newStep)
&#9;if remainder &gt; 0.5 then
&#9;&#9;wholeNum = wholeNum + 1
&#9;end
&#9;relativePosX = wholeNum/newStep

&#9;local result = math.ceil(relativePosX * newStep)
&#9;if sliderPosition.Value ~= (result + 1) then --only update if we moved a step
&#9;&#9;sliderPosition.Value = result + 1
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end
&#9;
end

local function cancelSlide(areaSoak)
&#9;areaSoak.Visible = false
&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
end

t.CreateStyledMessageDialog = function(title, message, style, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0, 165)
&#9;frame.Position = UDim2.new(0.25, 0, 0.5, -72.5)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound&#9;
&#9;
&#9;local styleImage = Instance.new(&quot;ImageLabel&quot;)
&#9;styleImage.Name = &quot;StyleImage&quot;
&#9;styleImage.BackgroundTransparency = 1
&#9;styleImage.Position = UDim2.new(0,5,0,15)
&#9;if style == &quot;error&quot; or style == &quot;Error&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;rbxasset://ui/error.png&quot;
&#9;elseif style == &quot;notify&quot; or style == &quot;Notify&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;rbxasset://ui/notify.png&quot;
&#9;elseif style == &quot;confirm&quot; or style == &quot;Confirm&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 74, 0, 76)
&#9;&#9;styleImage.Image = &quot;rbxasset://ui/confirm.png&quot;
&#9;else
&#9;&#9;return t.CreateMessageDialog(title,message,buttons)
&#9;end
&#9;styleImage.Parent = frame
&#9;
&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.TextStrokeTransparency = 0
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 80, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, -80, 0, 40)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextStrokeTransparency = 0
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 80, 0, 45)
&#9;messageLabel.Size = UDim2.new(0.95, -80, 0, 55)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0, 105), UDim.new(0, 40) )

&#9;return frame
end

t.CreateMessageDialog = function(title, message, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0.5, 0)
&#9;frame.Position = UDim2.new(0.25, 0, 0.25, 0)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound

&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 0, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, 0, 0.15, 0)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 0, 0.175, 0)
&#9;messageLabel.Size = UDim2.new(0.95, 0, .55, 0)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0.8,0), UDim.new(0.15, 0))

&#9;return frame
end

t.CreateDropDownMenu = function(items, onSelect, forRoblox)
&#9;local width = UDim.new(0, 100)
&#9;local height = UDim.new(0, 32)

&#9;local xPos = 0.055
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;DropDownMenu&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(width, height)

&#9;local dropDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;dropDownMenu.Name = &quot;DropDownMenuButton&quot;
&#9;dropDownMenu.TextWrap = true
&#9;dropDownMenu.TextColor3 = Color3.new(1,1,1)
&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;dropDownMenu.Font = Enum.Font.ArialBold
&#9;dropDownMenu.FontSize = Enum.FontSize.Size18
&#9;dropDownMenu.TextXAlignment = Enum.TextXAlignment.Left
&#9;dropDownMenu.TextYAlignment = Enum.TextYAlignment.Center
&#9;dropDownMenu.BackgroundTransparency = 1
&#9;dropDownMenu.AutoButtonColor = true
&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;dropDownMenu.Size = UDim2.new(1,0,1,0)
&#9;dropDownMenu.Parent = frame
&#9;dropDownMenu.ZIndex = 2

&#9;local dropDownIcon = Instance.new(&quot;ImageLabel&quot;)
&#9;dropDownIcon.Name = &quot;Icon&quot;
&#9;dropDownIcon.Active = false
&#9;dropDownIcon.Image = &quot;rbxasset://ui/dropdownicon.png&quot;
&#9;dropDownIcon.BackgroundTransparency = 1
&#9;dropDownIcon.Size = UDim2.new(0,11,0,6)
&#9;dropDownIcon.Position = UDim2.new(1,-11,0.5, -2)
&#9;dropDownIcon.Parent = dropDownMenu
&#9;dropDownIcon.ZIndex = 2
&#9;
&#9;local itemCount = #items
&#9;local dropDownItemCount = #items
&#9;local useScrollButtons = false
&#9;if dropDownItemCount &gt; 6 then
&#9;&#9;useScrollButtons = true
&#9;&#9;dropDownItemCount = 6
&#9;end
&#9;
&#9;local droppedDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;droppedDownMenu.Name = &quot;List&quot;
&#9;droppedDownMenu.Text = &quot;&quot;
&#9;droppedDownMenu.BackgroundTransparency = 1
&#9;--droppedDownMenu.AutoButtonColor = true
&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;droppedDownMenu.Visible = false
&#9;droppedDownMenu.Active = true&#9;--Blocks clicks
&#9;droppedDownMenu.Position = UDim2.new(0,0,0,0)
&#9;droppedDownMenu.Size = UDim2.new(1,0, (1 + dropDownItemCount)*.8, 0)
&#9;droppedDownMenu.Parent = frame
&#9;droppedDownMenu.ZIndex = 2

&#9;local choiceButton = Instance.new(&quot;TextButton&quot;)
&#9;choiceButton.Name = &quot;ChoiceButton&quot;
&#9;choiceButton.BackgroundTransparency = 1
&#9;choiceButton.BorderSizePixel = 0
&#9;choiceButton.Text = &quot;ReplaceMe&quot;
&#9;choiceButton.TextColor3 = Color3.new(1,1,1)
&#9;choiceButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;choiceButton.TextYAlignment = Enum.TextYAlignment.Center
&#9;choiceButton.BackgroundColor3 = Color3.new(1, 1, 1)
&#9;choiceButton.Font = Enum.Font.Arial
&#9;choiceButton.FontSize = Enum.FontSize.Size18
&#9;if useScrollButtons then
&#9;&#9;choiceButton.Size = UDim2.new(1,-13, .8/((dropDownItemCount + 1)*.8),0) 
&#9;else
&#9;&#9;choiceButton.Size = UDim2.new(1, 0, .8/((dropDownItemCount + 1)*.8),0) 
&#9;end
&#9;choiceButton.TextWrap = true
&#9;choiceButton.ZIndex = 2

&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = true
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 3

&#9;local dropDownSelected = false

&#9;local scrollUpButton 
&#9;local scrollDownButton
&#9;local scrollMouseCount = 0

&#9;local setZIndex = function(baseZIndex)
&#9;&#9;droppedDownMenu.ZIndex = baseZIndex +1
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex + 2
&#9;&#9;&#9;&#9;elseif child.Name == &quot;ClickCaptureButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollBarPosition = 1
&#9;local updateScroll = function()
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.Active = scrollBarPosition &gt; 1 
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.Active = scrollBarPosition + dropDownItemCount &lt;= itemCount 
&#9;&#9;end

&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if not children then return end

&#9;&#9;local childNum = 1&#9;&#9;&#9;
&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;if childNum &lt; scrollBarPosition or childNum &gt;= scrollBarPosition + dropDownItemCount then
&#9;&#9;&#9;&#9;&#9;obj.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;obj.Position = UDim2.new(0,0,((childNum-scrollBarPosition+1)*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;&#9;&#9;&#9;obj.Visible = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;obj.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;obj.BackgroundTransparency = 1

&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;local toggleVisibility = function()
&#9;&#9;dropDownSelected = not dropDownSelected

&#9;&#9;areaSoak.Visible = not areaSoak.Visible
&#9;&#9;dropDownMenu.Visible = not dropDownSelected
&#9;&#9;droppedDownMenu.Visible = dropDownSelected
&#9;&#9;if dropDownSelected then
&#9;&#9;&#9;setZIndex(4)
&#9;&#9;else
&#9;&#9;&#9;setZIndex(2)
&#9;&#9;end
&#9;&#9;if useScrollButtons then
&#9;&#9;&#9;updateScroll()
&#9;&#9;end
&#9;end
&#9;droppedDownMenu.MouseButton1Click:connect(toggleVisibility)

&#9;local updateSelection = function(text)
&#9;&#9;local foundItem = false
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;local childNum = 1
&#9;&#9;if children then
&#9;&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;if obj.Text == text then
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;&#9;foundItem = true&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;scrollBarPosition = childNum
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if not text then
&#9;&#9;&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;&#9;&#9;scrollBarPosition = 1
&#9;&#9;else
&#9;&#9;&#9;if not foundItem then
&#9;&#9;&#9;&#9;error(&quot;Invalid Selection Update -- &quot; .. text)
&#9;&#9;&#9;end

&#9;&#9;&#9;if scrollBarPosition + dropDownItemCount &gt; itemCount + 1 then
&#9;&#9;&#9;&#9;scrollBarPosition = itemCount - dropDownItemCount + 1
&#9;&#9;&#9;end

&#9;&#9;&#9;dropDownMenu.Text = text
&#9;&#9;end
&#9;end
&#9;
&#9;local function scrollDown()
&#9;&#9;if scrollBarPosition + dropDownItemCount &lt;= itemCount then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition + 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;local function scrollUp()
&#9;&#9;if scrollBarPosition &gt; 1 then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition - 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;
&#9;if useScrollButtons then
&#9;&#9;--Make some scroll buttons
&#9;&#9;scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;&#9;scrollUpButton.BackgroundTransparency = 1
&#9;&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollUpButton.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;scrollUpButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;
&#9;&#9;&#9;&#9;scrollUp()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollUp() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)

&#9;&#9;scrollUpButton.Parent = droppedDownMenu

&#9;&#9;scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;&#9;scrollDownButton.BackgroundTransparency = 1
&#9;&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollDownButton.Position = UDim2.new(1,-11,1,-11)
&#9;&#9;scrollDownButton.Parent = droppedDownMenu
&#9;&#9;scrollDownButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1

&#9;&#9;&#9;&#9;scrollDown()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollDown() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)&#9;

&#9;&#9;local scrollbar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;&#9;scrollbar.BackgroundTransparency = 1
&#9;&#9;scrollbar.Size = UDim2.new(0, 18, (dropDownItemCount*.8)/((dropDownItemCount+1)*.8), -(17) - 11 - 4)
&#9;&#9;scrollbar.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),17+2)
&#9;&#9;scrollbar.Parent = droppedDownMenu
&#9;end

&#9;for i,item in ipairs(items) do
&#9;&#9;-- needed to maintain local scope for items in event listeners below
&#9;&#9;local button = choiceButton:clone()
&#9;&#9;if forRoblox then
&#9;&#9;&#9;button.RobloxLocked = true
&#9;&#9;end&#9;&#9;
&#9;&#9;button.Text = item
&#9;&#9;button.Parent = droppedDownMenu
&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;button.BackgroundTransparency = 1

&#9;&#9;&#9;updateSelection(item)
&#9;&#9;&#9;onSelect(item)

&#9;&#9;&#9;toggleVisibility()
&#9;&#9;end)
&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;--Add Highlight&#9;
&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)

&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)
&#9;end

&#9;--This does the initial layout of the buttons&#9;
&#9;updateScroll()
&#9;
&#9;frame.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(frame)
&#9;&#9;end
&#9;end)

&#9;dropDownMenu.MouseButton1Click:connect(toggleVisibility)
&#9;areaSoak.MouseButton1Click:connect(toggleVisibility)
&#9;return frame, updateSelection
end

t.CreatePropertyDropDownMenu = function(instance, property, enum)

&#9;local items = enum:GetEnumItems()
&#9;local names = {}
&#9;local nameToItem = {}
&#9;for i,obj in ipairs(items) do
&#9;&#9;names[i] = obj.Name
&#9;&#9;nameToItem[obj.Name] = obj
&#9;end

&#9;local frame
&#9;local updateSelection
&#9;frame, updateSelection = t.CreateDropDownMenu(names, function(text) instance[property] = nameToItem[text] end)

&#9;ScopedConnect(frame, instance, &quot;Changed&quot;, 
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == property then
&#9;&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;&#9;end
&#9;&#9;end,
&#9;&#9;function()
&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;end)

&#9;return frame
end

t.GetFontHeight = function(font, fontSize)
&#9;if font == nil or fontSize == nil then
&#9;&#9;error(&quot;Font and FontSize must be non-nil&quot;)
&#9;end

&#9;if font == Enum.Font.Legacy then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 15
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 17
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 21
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 27
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 54
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 72
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;elseif font == Enum.Font.Arial or font == Enum.Font.ArialBold then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 8
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 9
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 10
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 11
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 24
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 48
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;error(&quot;Unknown Font &quot; .. font)
&#9;end
end

local function layoutGuiObjectsHelper(frame, guiObjects, settingsTable)
&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;local pixelsRemaining = frame.AbsoluteSize.Y
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if child:IsA(&quot;TextLabel&quot;) or child:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;local isLabel = child:IsA(&quot;TextLabel&quot;)
&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;end
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, pixelsRemaining)

&#9;&#9;&#9;if child.TextFits and child.TextBounds.Y &lt; pixelsRemaining then
&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextLabelSizePadY&quot;])
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextButtonSizePadY&quot;])
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;while not child.TextFits do
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.AbsoluteSize.Y + 1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y&#9;&#9;

&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;pixelsRemaining = -1
&#9;&#9;&#9;end&#9;&#9;&#9;

&#9;&#9;else
&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;child.Visible = (pixelsRemaining &gt;= 0)
&#9;&#9;end
&#9;end
end

t.LayoutGuiObjects = function(frame, guiObjects, settingsTable)
&#9;if not frame:IsA(&quot;GuiObject&quot;) then
&#9;&#9;error(&quot;Frame must be a GuiObject&quot;)
&#9;end
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if not child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements that are layed out must be of type GuiObject&quot;)
&#9;&#9;end
&#9;end

&#9;if not settingsTable then
&#9;&#9;settingsTable = {}
&#9;end

&#9;if not settingsTable[&quot;TextLabelSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelSizePadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextLabelPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelPositionPadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextButtonSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonSizePadY&quot;] = 12
&#9;end
&#9;if not settingsTable[&quot;TextButtonPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonPositionPadY&quot;] = 2
&#9;end

&#9;--Wrapper frame takes care of styled objects
&#9;local wrapperFrame = Instance.new(&quot;Frame&quot;)
&#9;wrapperFrame.Name = &quot;WrapperFrame&quot;
&#9;wrapperFrame.BackgroundTransparency = 1
&#9;wrapperFrame.Size = UDim2.new(1,0,1,0)
&#9;wrapperFrame.Parent = frame

&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;child.Parent = wrapperFrame
&#9;end

&#9;local recalculate = function()
&#9;&#9;wait()
&#9;&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
&#9;end
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(recalculate)

&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
end


t.CreateSlider = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 4
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local bar = Instance.new(&quot;TextButton&quot;)
&#9;bar.Text = &quot;&quot;
&#9;bar.AutoButtonColor = false
&#9;bar.Name = &quot;Bar&quot;
&#9;bar.BackgroundColor3 = Color3.new(0,0,0)
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width,0,5)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,5)
&#9;end
&#9;bar.BorderColor3 = Color3.new(95/255,95/255,95/255)
&#9;bar.ZIndex = 2
&#9;bar.Parent = sliderGui
&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end
&#9;
&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/Slider.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-10)
&#9;slider.Size = UDim2.new(0,20,0,20)
&#9;slider.ZIndex = 3
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)
&#9;
&#9;return sliderGui, sliderPosition, sliderSteps

end

t.CreateTrueScrollingFrame = function()
&#9;local lowY = nil
&#9;local highY = nil
&#9;
&#9;local dragCon = nil
&#9;local upCon = nil

&#9;local internalChange = false

&#9;local descendantsChangeConMap = {}

&#9;local scrollingFrame = Instance.new(&quot;Frame&quot;)
&#9;scrollingFrame.Name = &quot;ScrollingFrame&quot;
&#9;scrollingFrame.Active = true
&#9;scrollingFrame.Size = UDim2.new(1,0,1,0)
&#9;scrollingFrame.ClipsDescendants = true

&#9;local controlFrame = Instance.new(&quot;Frame&quot;)
&#9;controlFrame.Name = &quot;ControlFrame&quot;
&#9;controlFrame.BackgroundTransparency = 1
&#9;controlFrame.Size = UDim2.new(0,18,1,0)
&#9;controlFrame.Position = UDim2.new(1,-20,0,0)
&#9;controlFrame.Parent = scrollingFrame
&#9;
&#9;local scrollBottom = Instance.new(&quot;BoolValue&quot;)
&#9;scrollBottom.Value = false
&#9;scrollBottom.Name = &quot;ScrollBottom&quot;
&#9;scrollBottom.Parent = controlFrame
&#9;
&#9;local scrollUp = Instance.new(&quot;BoolValue&quot;)
&#9;scrollUp.Value = false
&#9;scrollUp.Name = &quot;scrollUp&quot;
&#9;scrollUp.Parent = controlFrame

&#9;local scrollUpButton = Instance.new(&quot;TextButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.Text = &quot;&quot;
&#9;scrollUpButton.AutoButtonColor = false
&#9;scrollUpButton.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollUpButton.BorderColor3 = Color3.new(1,1,1)
&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;scrollUpButton.Size = UDim2.new(0,18,0,18)
&#9;scrollUpButton.ZIndex = 2
&#9;scrollUpButton.Parent = controlFrame
&#9;for i = 1, 6 do
&#9;&#9;local triFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;triFrame.BorderColor3 = Color3.new(1,1,1)
&#9;&#9;triFrame.Name = &quot;tri&quot; .. tostring(i)
&#9;&#9;triFrame.ZIndex = 3
&#9;&#9;triFrame.BackgroundTransparency = 0.5
&#9;&#9;triFrame.Size = UDim2.new(0,12 - ((i -1) * 2),0,0)
&#9;&#9;triFrame.Position = UDim2.new(0,3 + (i -1),0.5,2 - (i -1))
&#9;&#9;triFrame.Parent = scrollUpButton
&#9;end
&#9;scrollUpButton.MouseEnter:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.1
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollUpButton.MouseLeave:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)

&#9;local scrollDownButton = scrollUpButton:clone()
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.Position = UDim2.new(0,0,1,-18)
&#9;local downChildren = scrollDownButton:GetChildren()
&#9;for i = 1, #downChildren do
&#9;&#9;downChildren[i].Position = UDim2.new(0,3 + (i -1),0.5,-2 + (i - 1))
&#9;end
&#9;scrollDownButton.MouseEnter:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.1
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.MouseLeave:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.5
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.Parent = controlFrame
&#9;
&#9;local scrollTrack = Instance.new(&quot;Frame&quot;)
&#9;scrollTrack.Name = &quot;ScrollTrack&quot;
&#9;scrollTrack.BackgroundTransparency = 1
&#9;scrollTrack.Size = UDim2.new(0,18,1,-38)
&#9;scrollTrack.Position = UDim2.new(0,0,0,19)
&#9;scrollTrack.Parent = controlFrame

&#9;local scrollbar = Instance.new(&quot;TextButton&quot;)
&#9;scrollbar.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollbar.BorderColor3 = Color3.new(1,1,1)
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.AutoButtonColor = false
&#9;scrollbar.Text = &quot;&quot;
&#9;scrollbar.Active = true
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.ZIndex = 2
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.Size = UDim2.new(0, 18, 0.1, 0)
&#9;scrollbar.Position = UDim2.new(0,0,0,0)
&#9;scrollbar.Parent = scrollTrack

&#9;local scrollNub = Instance.new(&quot;Frame&quot;)
&#9;scrollNub.Name = &quot;ScrollNub&quot;
&#9;scrollNub.BorderColor3 = Color3.new(1,1,1)
&#9;scrollNub.Size = UDim2.new(0,10,0,0)
&#9;scrollNub.Position = UDim2.new(0.5,-5,0.5,0)
&#9;scrollNub.ZIndex = 2
&#9;scrollNub.BackgroundTransparency = 0.5
&#9;scrollNub.Parent = scrollbar

&#9;local newNub = scrollNub:clone()
&#9;newNub.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;newNub.Parent = scrollbar
&#9;
&#9;local lastNub = scrollNub:clone()
&#9;lastNub.Position = UDim2.new(0.5,-5,0.5,2)
&#9;lastNub.Parent = scrollbar

&#9;scrollbar.MouseEnter:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.1
&#9;&#9;scrollNub.BackgroundTransparency = 0.1
&#9;&#9;newNub.BackgroundTransparency = 0.1
&#9;&#9;lastNub.BackgroundTransparency = 0.1
&#9;end)
&#9;scrollbar.MouseLeave:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.5
&#9;&#9;scrollNub.BackgroundTransparency = 0.5
&#9;&#9;newNub.BackgroundTransparency = 0.5
&#9;&#9;lastNub.BackgroundTransparency = 0.5
&#9;end)

&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10
&#9;
&#9;local function positionScrollBar(x,y,offset)
&#9;&#9;local oldPos = scrollbar.Position

&#9;&#9;if y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;
&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y

&#9;&#9;if y &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;local newScaleYPos = (y - scrollTrack.AbsolutePosition.y - offset)/scrollTrack.AbsoluteSize.y
&#9;&#9;if newScaleYPos + relativeSize &gt; 1 then
&#9;&#9;&#9;newScaleYPos = 1 - relativeSize
&#9;&#9;&#9;scrollBottom.Value = true
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;elseif newScaleYPos &lt;= 0 then
&#9;&#9;&#9;newScaleYPos = 0
&#9;&#9;&#9;scrollUp.Value = true
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;else
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;end
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,newScaleYPos,0)
&#9;&#9;
&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;end

&#9;local function drillDownSetHighLow(instance)
&#9;&#9;if not instance or not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if instance == controlFrame then return end
&#9;&#9;if instance:IsDescendantOf(controlFrame) then return end
&#9;&#9;if not instance.Visible then return end

&#9;&#9;if lowY and lowY &gt; instance.AbsolutePosition.Y then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;elseif not lowY then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;end
&#9;&#9;if highY and highY &lt; (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;local children = instance:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;drillDownSetHighLow(children[i])
&#9;&#9;end
&#9;end

&#9;local function resetHighLow()
&#9;&#9;local firstChildren = scrollingFrame:GetChildren()

&#9;&#9;for i = 1, #firstChildren do
&#9;&#9;&#9;drillDownSetHighLow(firstChildren[i])
&#9;&#9;end
&#9;end

&#9;local function recalculate()
&#9;&#9;internalChange = true

&#9;&#9;local percentFrame = 0
&#9;&#9;if scrollbar.Position.Y.Scale &gt; 0 then
&#9;&#9;&#9;if scrollbar.Visible then
&#9;&#9;&#9;&#9;percentFrame = scrollbar.Position.Y.Scale/((scrollTrack.AbsoluteSize.Y - scrollbar.AbsoluteSize.Y)/scrollTrack.AbsoluteSize.Y)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;percentFrame = 0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if percentFrame &gt; 0.99 then percentFrame = 1 end

&#9;&#9;local hiddenYAmount = (scrollingFrame.AbsoluteSize.Y - (highY - lowY)) * percentFrame
&#9;&#9;
&#9;&#9;local guiChildren = scrollingFrame:GetChildren()
&#9;&#9;for i = 1, #guiChildren do
&#9;&#9;&#9;if guiChildren[i] ~= controlFrame then
&#9;&#9;&#9;&#9;guiChildren[i].Position = UDim2.new(guiChildren[i].Position.X.Scale,guiChildren[i].Position.X.Offset,
&#9;&#9;&#9;&#9;&#9;0, math.ceil(guiChildren[i].AbsolutePosition.Y) - math.ceil(lowY) + hiddenYAmount)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()
&#9;&#9;internalChange = false
&#9;end

&#9;local function setSliderSizeAndPosition()
&#9;&#9;if not highY or not lowY then return end

&#9;&#9;local totalYSpan = math.abs(highY - lowY)
&#9;&#9;if totalYSpan == 0 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false

&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;local percentShown = scrollingFrame.AbsoluteSize.Y/totalYSpan
&#9;&#9;if percentShown &gt;= 1 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false
&#9;&#9;&#9;recalculate()
&#9;&#9;else
&#9;&#9;&#9;scrollbar.Visible = true
&#9;&#9;&#9;scrollDownButton.Visible = true
&#9;&#9;&#9;scrollUpButton.Visible = true

&#9;&#9;&#9;scrollbar.Size = UDim2.new(scrollbar.Size.X.Scale,scrollbar.Size.X.Offset,percentShown,0)
&#9;&#9;end

&#9;&#9;local percentPosition = (scrollingFrame.AbsolutePosition.Y - lowY)/totalYSpan
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,percentPosition,-scrollbar.AbsoluteSize.X/2)

&#9;&#9;if scrollbar.AbsolutePosition.y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;end

&#9;&#9;if (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.Y) &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;end
&#9;end
&#9;
&#9;local buttonScrollAmountPixels = 7
&#9;local reentrancyGuardScrollUp = false
&#9;local function doScrollUp()
&#9;&#9;if reentrancyGuardScrollUp then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollUp = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y - buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollUp = false
&#9;end
&#9;
&#9;local reentrancyGuardScrollDown = false
&#9;local function doScrollDown()
&#9;&#9;if reentrancyGuardScrollDown then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollDown = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y + buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollDown = false
&#9;end

&#9;local function scrollUp(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollbar.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function scrollDown(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;scrollbar.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollbar.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollbar.AbsolutePosition.y
&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;local prevY = y
&#9;&#9;&#9;local reentrancyGuardMouseScroll = false
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;if reentrancyGuardMouseScroll then return end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = true
&#9;&#9;&#9;&#9;&#9;if positionScrollBar(x,y,mouseOffset) then
&#9;&#9;&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = false
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(function()
&#9;&#9;scrollUp()
&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)

&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(function()
&#9;&#9; scrollDown()
&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;
&#9;local function heightCheck(instance)
&#9;&#9;if highY and (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) &gt; highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;setSliderSizeAndPosition()
&#9;end
&#9;
&#9;local function highLowRecheck()
&#9;&#9;local oldLowY = lowY
&#9;&#9;local oldHighY = highY
&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()

&#9;&#9;if (lowY ~= oldLowY) or (highY ~= oldHighY) then
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end

&#9;local function descendantChanged(this, prop)
&#9;&#9;if internalChange then return end
&#9;&#9;if not this.Visible then return end

&#9;&#9;if prop == &quot;Size&quot; or prop == &quot;Position&quot; then
&#9;&#9;&#9;wait()
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end
&#9;end

&#9;scrollingFrame.DescendantAdded:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end

&#9;&#9;if instance.Visible then
&#9;&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end

&#9;&#9;descendantsChangeConMap[instance] = instance.Changed:connect(function(prop) descendantChanged(instance, prop) end)
&#9;end)

&#9;scrollingFrame.DescendantRemoving:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if descendantsChangeConMap[instance] then
&#9;&#9;&#9;descendantsChangeConMap[instance]:disconnect()
&#9;&#9;&#9;descendantsChangeConMap[instance] = nil
&#9;&#9;end
&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;highLowRecheck()
&#9;end)
&#9;
&#9;scrollingFrame.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;if not highY or not lowY then return end

&#9;&#9;&#9;highLowRecheck()
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end)

&#9;return scrollingFrame, controlFrame
end

t.CreateScrollingFrame = function(orderList,scrollStyle)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;ScrollingFrame&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(1,0,1,0)
&#9;
&#9;local scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.BackgroundTransparency = 1
&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 

&#9;
&#9;local scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.BackgroundTransparency = 1
&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;
&#9;local scrollbar = Instance.new(&quot;ImageButton&quot;)
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;scrollbar.BackgroundTransparency = 1
&#9;scrollbar.Size = UDim2.new(0, 18, 0, 150)

&#9;local scrollStamp = 0
&#9;&#9;
&#9;local scrollDrag = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDrag.Image = &quot;rbxasset://ui/scrolldrag.png&quot;
&#9;scrollDrag.Size = UDim2.new(1, 0, 0, 16)
&#9;scrollDrag.BackgroundTransparency = 1
&#9;scrollDrag.Name = &quot;ScrollDrag&quot;
&#9;scrollDrag.Active = true
&#9;scrollDrag.Parent = scrollbar
&#9;
&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10

&#9;local style = &quot;simple&quot;
&#9;if scrollStyle and tostring(scrollStyle) then
&#9;&#9;style = scrollStyle
&#9;end
&#9;
&#9;local scrollPosition = 1
&#9;local rowSize = 0
&#9;local howManyDisplayed = 0
&#9;&#9;
&#9;local layoutGridScrollBar = function()
&#9;&#9;howManyDisplayed = 0
&#9;&#9;local guiObjects = {}
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;
&#9;&#9;local totalPixelsY = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemainingY = frame.AbsoluteSize.Y
&#9;&#9;
&#9;&#9;local totalPixelsX  = frame.AbsoluteSize.X
&#9;&#9;
&#9;&#9;local xCounter = 0
&#9;&#9;local rowSizeCounter = 0
&#9;&#9;local setRowSize = true

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;
&#9;&#9;local currentRowY = 0

&#9;&#9;pos = scrollPosition
&#9;&#9;--count up from current scroll position to fill out grid
&#9;&#9;while pos &lt;= #guiObjects and pixelsBelowScrollbar &lt; totalPixelsY do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;--previous pos was the end of a row
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;end
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos + 1
&#9;&#9;end
&#9;&#9;--Count wherever current row left off
&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;currentRowY = 0
&#9;&#9;
&#9;&#9;pos = scrollPosition - 1
&#9;&#9;xCounter = 0
&#9;&#9;
&#9;&#9;--objects with varying X,Y dimensions can rarely cause minor errors
&#9;&#9;--rechecking every new scrollPosition is necessary to avoid 100% of errors
&#9;&#9;
&#9;&#9;--count backwards from current scrollPosition to see if we can add more rows
&#9;&#9;while pixelsBelowScrollbar + currentRowY &lt; totalPixelsY and pos &gt;= 1 do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;rowSizeCounter = rowSizeCounter + 1
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;rowSizeCounter = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= rowSize then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1 
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - rowSize
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end

&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end
&#9;&#9;
&#9;&#9;--Do check last time if pos = 0
&#9;&#9;if (pos == 0) and (pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY) then
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;end

&#9;&#9;xCounter = 0
&#9;&#9;--pos = scrollPosition
&#9;&#9;rowSizeCounter = 0
&#9;&#9;setRowSize = true
&#9;&#9;local lastChildSize = 0
&#9;&#9;
&#9;&#9;local xOffset,yOffset = 0
&#9;&#9;if guiObjects[1] then
&#9;&#9;&#9;yOffset = math.ceil(math.floor(math.fmod(totalPixelsY,guiObjects[1].AbsoluteSize.X))/2)
&#9;&#9;&#9;xOffset = math.ceil(math.floor(math.fmod(totalPixelsX,guiObjects[1].AbsoluteSize.Y))/2)
&#9;&#9;end
&#9;&#9;
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemainingY &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;if setRowSize then rowSizeCounter = rowSizeCounter + 1 end
&#9;&#9;&#9;&#9;&#9;if xCounter + child.AbsoluteSize.X &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;&#9;&#9;if setRowSize then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;setRowSize = false
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;xCounter = 0
&#9;&#9;&#9;&#9;&#9;&#9;pixelsRemainingY = pixelsRemainingY - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale,xCounter + xOffset, 0, totalPixelsY - pixelsRemainingY + yOffset)
&#9;&#9;&#9;&#9;&#9;xCounter = xCounter + child.AbsoluteSize.X
&#9;&#9;&#9;&#9;&#9;child.Visible = ((pixelsRemainingY - child.AbsoluteSize.Y) &gt;= 0)
&#9;&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;lastChildSize = child.AbsoluteSize&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;if lastChildSize == 0 then 
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;else
&#9;&#9;&#9;scrollDownButton.Active = ((pixelsRemainingY - lastChildSize.Y) &lt; 0)
&#9;&#9;end
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end



&#9;local layoutSimpleScrollBar = function()
&#9;&#9;local guiObjects = {}&#9;
&#9;&#9;howManyDisplayed = 0
&#9;&#9;
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemaining = frame.AbsoluteSize.Y

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;while pixelsBelowScrollbar &lt; totalPixels and pos &gt;= 1 do
&#9;&#9;&#9;if pos &gt;= scrollPosition then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y &lt;= totalPixels then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= 1 then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--local (&quot;Backing up ScrollPosition from -- &quot; ..scrollPosition)
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end

&#9;&#9;pos = scrollPosition
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemaining &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if  (pixelsRemaining &gt;= 0) then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;scrollDownButton.Active = (pixelsRemaining &lt; 0)
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end
&#9;
&#9;&#9;
&#9;local moveDragger = function()&#9;
&#9;&#9;local guiObjects = 0
&#9;&#9;local children = frame:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;if not scrollDrag.Parent then return end
&#9;&#9;
&#9;&#9;local dragSizeY = scrollDrag.Parent.AbsoluteSize.y * (1/(guiObjects - howManyDisplayed + 1))
&#9;&#9;if dragSizeY &lt; 16 then dragSizeY = 16 end
&#9;&#9;scrollDrag.Size = UDim2.new(scrollDrag.Size.X.Scale,scrollDrag.Size.X.Offset,scrollDrag.Size.Y.Scale,dragSizeY)

&#9;&#9;local relativeYPos = (scrollPosition - 1)/(guiObjects - (howManyDisplayed))
&#9;&#9;if relativeYPos &gt; 1 then relativeYPos = 1
&#9;&#9;elseif relativeYPos &lt; 0 then relativeYPos = 0 end
&#9;&#9;local absYPos = 0
&#9;&#9;
&#9;&#9;if relativeYPos ~= 0 then
&#9;&#9;&#9;absYPos = (relativeYPos * scrollbar.AbsoluteSize.y) - (relativeYPos * scrollDrag.AbsoluteSize.y)
&#9;&#9;end
&#9;&#9;
&#9;&#9;scrollDrag.Position = UDim2.new(scrollDrag.Position.X.Scale,scrollDrag.Position.X.Offset,scrollDrag.Position.Y.Scale,absYPos)
&#9;end

&#9;local reentrancyGuard = false
&#9;local recalculate = function()
&#9;&#9;if reentrancyGuard then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;reentrancyGuard = true
&#9;&#9;wait()
&#9;&#9;local success, err = nil
&#9;&#9;if style == &quot;grid&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutGridScrollBar() end)
&#9;&#9;elseif style == &quot;simple&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutSimpleScrollBar() end)
&#9;&#9;end
&#9;&#9;if not success then print(err) end
&#9;&#9;moveDragger()
&#9;&#9;reentrancyGuard = false
&#9;end
&#9;
&#9;local doScrollUp = function()
&#9;&#9;scrollPosition = (scrollPosition) - rowSize
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;recalculate(nil)
&#9;end
&#9;
&#9;local doScrollDown = function()
&#9;&#9;scrollPosition = (scrollPosition) + rowSize
&#9;&#9;recalculate(nil)
&#9;end

&#9;local scrollUp = function(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollDrag.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollDown = function(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollDrag.AbsolutePosition.y + scrollDrag.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local y = 0
&#9;scrollDrag.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollDrag.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollDrag.AbsolutePosition.y
&#9;&#9;&#9;local dragCon
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;local barAbsPos = scrollbar.AbsolutePosition.y
&#9;&#9;&#9;&#9;local barAbsSize = scrollbar.AbsoluteSize.y
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local dragAbsSize = scrollDrag.AbsoluteSize.y
&#9;&#9;&#9;&#9;local barAbsOne = barAbsPos + barAbsSize - dragAbsSize
&#9;&#9;&#9;&#9;y = y - mouseOffset
&#9;&#9;&#9;&#9;y = y &lt; barAbsPos and barAbsPos or y &gt; barAbsOne and barAbsOne or y
&#9;&#9;&#9;&#9;y = y - barAbsPos
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local guiObjects = 0
&#9;&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local doublePercent = y/(barAbsSize-dragAbsSize)
&#9;&#9;&#9;&#9;local rowDiff = rowSize
&#9;&#9;&#9;&#9;local totalScrollCount = guiObjects - (howManyDisplayed - 1)
&#9;&#9;&#9;&#9;local newScrollPosition = math.floor((doublePercent * totalScrollCount) + 0.5) + rowDiff
&#9;&#9;&#9;&#9;if newScrollPosition &lt; scrollPosition then
&#9;&#9;&#9;&#9;&#9;rowDiff = -rowDiff
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if newScrollPosition &lt; 1 then
&#9;&#9;&#9;&#9;&#9;newScrollPosition = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;scrollPosition = newScrollPosition
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollUp()
&#9;&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)


&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollDown()&#9;
&#9;&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollbar.MouseButton1Down:connect(
&#9;&#9;function(x,y)
&#9;&#9;&#9;if y &gt; (scrollDrag.AbsoluteSize.y + scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollDown(y)
&#9;&#9;&#9;elseif y &lt; (scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollUp(y)
&#9;&#9;&#9;end
&#9;&#9;end)


&#9;frame.ChildAdded:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)

&#9;frame.ChildRemoved:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(function() recalculate(nil) end)

&#9;return frame, scrollUpButton, scrollDownButton, recalculate, scrollbar
end
local function binaryGrow(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local biggestLegal = min

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (biggestLegal == nil or biggestLegal &lt; mid) then
&#9;&#9;&#9;biggestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--Try growing
&#9;&#9;&#9;min = mid + 1
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, shrink
&#9;&#9;&#9;max = mid - 1
&#9;&#9;end
&#9;end
&#9;return biggestLegal
end


local function binaryShrink(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local smallestLegal = max

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (smallestLegal == nil or smallestLegal &gt; mid) then
&#9;&#9;&#9;smallestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--It fits, shrink
&#9;&#9;&#9;max = mid - 1&#9;&#9;&#9;
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, grow
&#9;&#9;&#9;min = mid + 1
&#9;&#9;end
&#9;end
&#9;return smallestLegal
end


local function getGuiOwner(instance)
&#9;while instance ~= nil do
&#9;&#9;if instance:IsA(&quot;ScreenGui&quot;) or instance:IsA(&quot;BillboardGui&quot;)  then
&#9;&#9;&#9;return instance
&#9;&#9;end
&#9;&#9;instance = instance.Parent
&#9;end
&#9;return nil
end

t.AutoTruncateTextObject = function(textLabel)
&#9;local text = textLabel.Text

&#9;local fullLabel = textLabel:Clone()
&#9;fullLabel.Name = &quot;Full&quot; .. textLabel.Name 
&#9;fullLabel.BorderSizePixel = 0
&#9;fullLabel.BackgroundTransparency = 0
&#9;fullLabel.Text = text
&#9;fullLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;fullLabel.Position = UDim2.new(0,-3,0,0)
&#9;fullLabel.Size = UDim2.new(0,100,1,0)
&#9;fullLabel.Visible = false
&#9;fullLabel.Parent = textLabel

&#9;local shortText = nil
&#9;local mouseEnterConnection = nil
&#9;local mouseLeaveConnection= nil

&#9;local checkForResize = function()
&#9;&#9;if getGuiOwner(textLabel) == nil then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;textLabel.Text = text
&#9;&#9;if textLabel.TextFits then 
&#9;&#9;&#9;--Tear down the rollover if it is active
&#9;&#9;&#9;if mouseEnterConnection then
&#9;&#9;&#9;&#9;mouseEnterConnection:disconnect()
&#9;&#9;&#9;&#9;mouseEnterConnection = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection then
&#9;&#9;&#9;&#9;mouseLeaveConnection:disconnect()
&#9;&#9;&#9;&#9;mouseLeaveConnection = nil
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local len = string.len(text)
&#9;&#9;&#9;textLabel.Text = text .. &quot;~&quot;

&#9;&#9;&#9;--Shrink the text
&#9;&#9;&#9;local textSize = binaryGrow(0, len, 
&#9;&#9;&#9;&#9;function(pos)
&#9;&#9;&#9;&#9;&#9;if pos == 0 then
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = string.sub(text, 1, pos) .. &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;shortText = string.sub(text, 1, textSize) .. &quot;~&quot;
&#9;&#9;&#9;textLabel.Text = shortText
&#9;&#9;&#9;
&#9;&#9;&#9;--Make sure the fullLabel fits
&#9;&#9;&#9;if not fullLabel.TextFits then
&#9;&#9;&#9;&#9;--Already too small, grow it really bit to start
&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, 10000, 1, 0)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;--Okay, now try to binary shrink it back down
&#9;&#9;&#9;local fullLabelSize = binaryShrink(textLabel.AbsoluteSize.X,fullLabel.AbsoluteSize.X, 
&#9;&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, size, 1, 0)
&#9;&#9;&#9;&#9;&#9;return fullLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;fullLabel.Size = UDim2.new(0,fullLabelSize+6,1,0)

&#9;&#9;&#9;--Now setup the rollover effects, if they are currently off
&#9;&#9;&#9;if mouseEnterConnection == nil then
&#9;&#9;&#9;&#9;mouseEnterConnection = textLabel.MouseEnter:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.ZIndex = textLabel.ZIndex + 1
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection == nil then
&#9;&#9;&#9;&#9;mouseLeaveConnection = textLabel.MouseLeave:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = shortText
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;textLabel.AncestryChanged:connect(checkForResize)
&#9;textLabel.Changed:connect(
&#9;&#9;function(prop) 
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then 
&#9;&#9;&#9;&#9;checkForResize() &#9;
&#9;&#9;&#9;end 
&#9;&#9;end)

&#9;checkForResize()

&#9;local function changeText(newText)
&#9;&#9;text = newText
&#9;&#9;fullLabel.Text = text
&#9;&#9;checkForResize()
&#9;end

&#9;return textLabel, changeText
end

local function TransitionTutorialPages(fromPage, toPage, transitionFrame, currentPageValue)&#9;
&#9;if fromPage then
&#9;&#9;fromPage.Visible = false
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = fromPage.Size
&#9;&#9;&#9;transitionFrame.Position = fromPage.Position
&#9;&#9;end
&#9;else
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = UDim2.new(0.0,50,0.0,50)
&#9;&#9;&#9;transitionFrame.Position = UDim2.new(0.5,-25,0.5,-25)
&#9;&#9;end
&#9;end
&#9;transitionFrame.Visible = true
&#9;currentPageValue.Value = nil

&#9;local newsize, newPosition
&#9;if toPage then
&#9;&#9;--Make it visible so it resizes
&#9;&#9;toPage.Visible = true

&#9;&#9;newSize = toPage.Size
&#9;&#9;newPosition = toPage.Position

&#9;&#9;toPage.Visible = false
&#9;else
&#9;&#9;newSize = UDim2.new(0.0,50,0.0,50)
&#9;&#9;newPosition = UDim2.new(0.5,-25,0.5,-25)
&#9;end
&#9;transitionFrame:TweenSizeAndPosition(newSize, newPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, 0.3, true,
&#9;&#9;function(state)
&#9;&#9;&#9;if state == Enum.TweenStatus.Completed then
&#9;&#9;&#9;&#9;transitionFrame.Visible = false
&#9;&#9;&#9;&#9;if toPage then
&#9;&#9;&#9;&#9;&#9;toPage.Visible = true
&#9;&#9;&#9;&#9;&#9;currentPageValue.Value = toPage
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
end

t.CreateTutorial = function(name, tutorialKey, createButtons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;Tutorial-&quot; .. name
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)

&#9;local transitionFrame = Instance.new(&quot;Frame&quot;)
&#9;transitionFrame.Name = &quot;TransitionFrame&quot;
&#9;transitionFrame.Style = Enum.FrameStyle.RobloxRound
&#9;transitionFrame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;transitionFrame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;transitionFrame.Visible = false
&#9;transitionFrame.Parent = frame

&#9;local currentPageValue = Instance.new(&quot;ObjectValue&quot;)
&#9;currentPageValue.Name = &quot;CurrentTutorialPage&quot;
&#9;currentPageValue.Value = nil
&#9;currentPageValue.Parent = frame

&#9;local boolValue = Instance.new(&quot;BoolValue&quot;)
&#9;boolValue.Name = &quot;Buttons&quot;
&#9;boolValue.Value = createButtons
&#9;boolValue.Parent = frame

&#9;local pages = Instance.new(&quot;Frame&quot;)
&#9;pages.Name = &quot;Pages&quot;
&#9;pages.BackgroundTransparency = 1
&#9;pages.Size = UDim2.new(1,0,1,0)
&#9;pages.Parent = frame

&#9;local function getVisiblePageAndHideOthers()
&#9;&#9;local visiblePage = nil
&#9;&#9;local children = pages:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i,child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;if visiblePage then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;visiblePage = child
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return visiblePage
&#9;end

&#9;local showTutorial = function(alwaysShow)
&#9;&#9;if alwaysShow or UserSettings().GameSettings:GetTutorialState(tutorialKey) == false then
&#9;&#9;&#9;print(&quot;Showing tutorial-&quot;,tutorialKey)
&#9;&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;&#9;local firstPage = pages:FindFirstChild(&quot;TutorialPage1&quot;)
&#9;&#9;&#9;if firstPage then
&#9;&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, firstPage, transitionFrame, currentPageValue)&#9;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;Could not find TutorialPage1&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local dismissTutorial = function()
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;if currentTutorialPage then
&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, nil, transitionFrame, currentPageValue)
&#9;&#9;end

&#9;&#9;UserSettings().GameSettings:SetTutorialState(tutorialKey, true)
&#9;end

&#9;local gotoPage = function(pageNum)
&#9;&#9;local page = pages:FindFirstChild(&quot;TutorialPage&quot; .. pageNum)
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()
&#9;&#9;TransitionTutorialPages(currentTutorialPage, page, transitionFrame, currentPageValue)
&#9;end

&#9;return frame, showTutorial, dismissTutorial, gotoPage
end 

local function CreateBasicTutorialPage(name, handleResize, skipTutorial, giveDoneButton)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TutorialPage&quot;
&#9;frame.Style = Enum.FrameStyle.RobloxRound
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;frame.Visible = false
&#9;
&#9;local frameHeader = Instance.new(&quot;TextLabel&quot;)
&#9;frameHeader.Name = &quot;Header&quot;
&#9;frameHeader.Text = name
&#9;frameHeader.BackgroundTransparency = 1
&#9;frameHeader.FontSize = Enum.FontSize.Size24
&#9;frameHeader.Font = Enum.Font.ArialBold
&#9;frameHeader.TextColor3 = Color3.new(1,1,1)
&#9;frameHeader.TextXAlignment = Enum.TextXAlignment.Center
&#9;frameHeader.TextWrap = true
&#9;frameHeader.Size = UDim2.new(1,-55, 0, 22)
&#9;frameHeader.Position = UDim2.new(0,0,0,0)
&#9;frameHeader.Parent = frame

&#9;local skipButton = Instance.new(&quot;ImageButton&quot;)
&#9;skipButton.Name = &quot;SkipButton&quot;
&#9;skipButton.AutoButtonColor = false
&#9;skipButton.BackgroundTransparency = 1
&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;skipButton.MouseButton1Click:connect(function()
&#9;&#9;skipTutorial()
&#9;end)
&#9;skipButton.MouseEnter:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton_dn.png&quot;
&#9;end)
&#9;skipButton.MouseLeave:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;end)
&#9;skipButton.Size = UDim2.new(0, 25, 0, 25)
&#9;skipButton.Position = UDim2.new(1, -25, 0, 0)
&#9;skipButton.Parent = frame
&#9;
&#9;
&#9;if giveDoneButton then
&#9;&#9;local doneButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;doneButton.Name = &quot;DoneButton&quot;
&#9;&#9;doneButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;doneButton.Text = &quot;Done&quot;
&#9;&#9;doneButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;doneButton.Font = Enum.Font.ArialBold
&#9;&#9;doneButton.FontSize = Enum.FontSize.Size18
&#9;&#9;doneButton.Size = UDim2.new(0,100,0,50)
&#9;&#9;doneButton.Position = UDim2.new(0.5,-50,1,-50)
&#9;&#9;
&#9;&#9;if skipTutorial then
&#9;&#9;&#9;doneButton.MouseButton1Click:connect(function() skipTutorial() end)
&#9;&#9;end
&#9;&#9;
&#9;&#9;doneButton.Parent = frame
&#9;end

&#9;local innerFrame = Instance.new(&quot;Frame&quot;)
&#9;innerFrame.Name = &quot;ContentFrame&quot;
&#9;innerFrame.BackgroundTransparency = 1
&#9;innerFrame.Position = UDim2.new(0,0,0,25)
&#9;innerFrame.Parent = frame

&#9;local nextButton = Instance.new(&quot;TextButton&quot;)
&#9;nextButton.Name = &quot;NextButton&quot;
&#9;nextButton.Text = &quot;Next&quot;
&#9;nextButton.TextColor3 = Color3.new(1,1,1)
&#9;nextButton.Font = Enum.Font.Arial
&#9;nextButton.FontSize = Enum.FontSize.Size18
&#9;nextButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;nextButton.Size = UDim2.new(0,80, 0, 32)
&#9;nextButton.Position = UDim2.new(0.5, 5, 1, -32)
&#9;nextButton.Active = false
&#9;nextButton.Visible = false
&#9;nextButton.Parent = frame

&#9;local prevButton = Instance.new(&quot;TextButton&quot;)
&#9;prevButton.Name = &quot;PrevButton&quot;
&#9;prevButton.Text = &quot;Previous&quot;
&#9;prevButton.TextColor3 = Color3.new(1,1,1)
&#9;prevButton.Font = Enum.Font.Arial
&#9;prevButton.FontSize = Enum.FontSize.Size18
&#9;prevButton.Style = Enum.ButtonStyle.RobloxButton
&#9;prevButton.Size = UDim2.new(0,80, 0, 32)
&#9;prevButton.Position = UDim2.new(0.5, -85, 1, -32)
&#9;prevButton.Active = false
&#9;prevButton.Visible = false
&#9;prevButton.Parent = frame

&#9;if giveDoneButton then
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-75)
&#9;else
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-22)
&#9;end

&#9;local parentConnection = nil

&#9;local function basicHandleResize()
&#9;&#9;if frame.Visible and frame.Parent then
&#9;&#9;&#9;local maxSize = math.min(frame.Parent.AbsoluteSize.X, frame.Parent.AbsoluteSize.Y)
&#9;&#9;&#9;handleResize(200,maxSize)
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;Parent&quot; then
&#9;&#9;&#9;&#9;if parentConnection ~= nil then
&#9;&#9;&#9;&#9;&#9;parentConnection:disconnect()
&#9;&#9;&#9;&#9;&#9;parentConnection = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if frame.Parent and frame.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;parentConnection = frame.Parent.Changed:connect(
&#9;&#9;&#9;&#9;&#9;&#9;function(parentProp)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if parentProp == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;if prop == &quot;Visible&quot; then 
&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;end
&#9;&#9;end)

&#9;return frame, innerFrame
end

t.CreateTextTutorialPage = function(name, text, skipTutorialFunc)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local textLabel = Instance.new(&quot;TextLabel&quot;)
&#9;textLabel.BackgroundTransparency = 1
&#9;textLabel.TextColor3 = Color3.new(1,1,1)
&#9;textLabel.Text = text
&#9;textLabel.TextWrap = true
&#9;textLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;textLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;textLabel.Font = Enum.Font.Arial
&#9;textLabel.FontSize = Enum.FontSize.Size14
&#9;textLabel.Size = UDim2.new(1,0,1,0)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;end)
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc)
&#9;textLabel.Parent = contentFrame

&#9;return frame
end

t.CreateImageTutorialPage = function(name, imageAsset, x, y, skipTutorialFunc, giveDoneButton)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local imageLabel = Instance.new(&quot;ImageLabel&quot;)
&#9;imageLabel.BackgroundTransparency = 1
&#9;imageLabel.Image = imageAsset
&#9;imageLabel.Size = UDim2.new(0,x,0,y)
&#9;imageLabel.Position = UDim2.new(0.5,-x/2,0.5,-y/2)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;return size &gt;= x and size &gt;= y
&#9;&#9;&#9;end)
&#9;&#9;if size &gt;= x and size &gt;= y then
&#9;&#9;&#9;imageLabel.Size = UDim2.new(0,x, 0,y)
&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5,-x/2, 0.5, -y/2)
&#9;&#9;else
&#9;&#9;&#9;if x &gt; y then
&#9;&#9;&#9;&#9;--X is limiter, so 
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(1,0,y/x,0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0,0, 0.5 - (y/x)/2, 0)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--Y is limiter
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(x/y,0,1, 0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5-(x/y)/2, 0, 0, 0)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;size = size + 50
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc, giveDoneButton)
&#9;imageLabel.Parent = contentFrame

&#9;return frame
end

t.AddTutorialPage = function(tutorial, tutorialPage)
&#9;local transitionFrame = tutorial.TransitionFrame
&#9;local currentPageValue = tutorial.CurrentTutorialPage

&#9;if not tutorial.Buttons.Value then
&#9;&#9;tutorialPage.NextButton.Parent = nil
&#9;&#9;tutorialPage.PrevButton.Parent = nil
&#9;end

&#9;local children = tutorial.Pages:GetChildren()
&#9;if children and #children &gt; 0 then
&#9;&#9;tutorialPage.Name = &quot;TutorialPage&quot; .. (#children+1)
&#9;&#9;local previousPage = children[#children]
&#9;&#9;if not previousPage:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements under Pages must be GuiObjects&quot;)
&#9;&#9;end

&#9;&#9;if tutorial.Buttons.Value then
&#9;&#9;&#9;if previousPage.NextButton.Active then
&#9;&#9;&#9;&#9;error(&quot;NextButton already Active on previousPage, please only add pages with RbxGui.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;previousPage.NextButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(previousPage, tutorialPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;previousPage.NextButton.Active = true
&#9;&#9;&#9;previousPage.NextButton.Visible = true

&#9;&#9;&#9;if tutorialPage.PrevButton.Active then
&#9;&#9;&#9;&#9;error(&quot;PrevButton already Active on tutorialPage, please only add pages with RbxGui.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;tutorialPage.PrevButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(tutorialPage, previousPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;tutorialPage.PrevButton.Active = true
&#9;&#9;&#9;tutorialPage.PrevButton.Visible = true
&#9;&#9;end

&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;else
&#9;&#9;--First child
&#9;&#9;tutorialPage.Name = &quot;TutorialPage1&quot;
&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;end
end 

t.CreateSetPanel = function(userIdsForSets, objectSelected, dialogClosed, size, position, showAdminCategories, useAssetVersionId)

&#9;if not userIdsForSets then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is nil, should be a table of number ids&quot;)
&#9;end
&#9;if type(userIdsForSets) ~= &quot;table&quot; and type(userIdsForSets) ~= &quot;userdata&quot; then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is of type &quot; ..type(userIdsForSets) .. &quot;, should be of type table or userdata&quot;)
&#9;end
&#9;if not objectSelected then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is nil, should be a callback function!&quot;)
&#9;end
&#9;if type(objectSelected) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is of type &quot; .. type(objectSelected) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;if dialogClosed and type(dialogClosed) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: dialogClosed (third arg) is of type &quot; .. type(dialogClosed) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;
&#9;if showAdminCategories == nil then -- by default, don&apos;t show beta sets
&#9;&#9;showAdminCategories = false
&#9;end

&#9;local arrayPosition = 1
&#9;local insertButtons = {}
&#9;local insertButtonCons = {}
&#9;local contents = nil
&#9;local setGui = nil

&#9;-- used for water selections
&#9;local waterForceDirection = &quot;NegX&quot;
&#9;local waterForce = &quot;None&quot;
&#9;local waterGui, waterTypeChangedEvent = nil
&#9;
&#9;local Data = {}
&#9;Data.CurrentCategory = nil
&#9;Data.Category = {}
&#9;local SetCache = {}
&#9;
&#9;local userCategoryButtons = nil
&#9;
&#9;local buttonWidth = 64
&#9;local buttonHeight = buttonWidth
&#9;
&#9;local SmallThumbnailUrl = nil
&#9;local LargeThumbnailUrl = nil
&#9;local BaseUrl = game:GetService(&quot;ContentProvider&quot;).BaseUrl:lower()
&#9;
&#9;if useAssetVersionId then
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;assetversionid=&quot;
&#9;else
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;aid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;aid=&quot;
&#9;end
&#9;&#9;
&#9;local function drillDownSetZIndex(parent, index)
&#9;&#9;local children = parent:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;if children[i]:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;children[i].ZIndex = index
&#9;&#9;&#9;end
&#9;&#9;&#9;drillDownSetZIndex(children[i], index)
&#9;&#9;end
&#9;end
&#9;
&#9;-- for terrain stamping
&#9;local currTerrainDropDownFrame = nil
&#9;local terrainShapes = {&quot;Block&quot;,&quot;Vertical Ramp&quot;,&quot;Corner Wedge&quot;,&quot;Inverse Corner Wedge&quot;,&quot;Horizontal Ramp&quot;,&quot;Auto-Wedge&quot;}
&#9;local terrainShapeMap = {}
&#9;for i = 1, #terrainShapes do
&#9;&#9;terrainShapeMap[terrainShapes[i]] = i - 1
&#9;end&#9;
&#9;terrainShapeMap[terrainShapes[#terrainShapes]] = 6

&#9;local function createWaterGui()
&#9;&#9;local waterForceDirections = {&quot;NegX&quot;,&quot;X&quot;,&quot;NegY&quot;,&quot;Y&quot;,&quot;NegZ&quot;,&quot;Z&quot;}
&#9;&#9;local waterForces = {&quot;None&quot;, &quot;Small&quot;, &quot;Medium&quot;, &quot;Strong&quot;, &quot;Max&quot;}

&#9;&#9;local waterFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;waterFrame.Name = &quot;WaterFrame&quot;
&#9;&#9;waterFrame.Style = Enum.FrameStyle.RobloxSquare
&#9;&#9;waterFrame.Size = UDim2.new(0,150,0,110)
&#9;&#9;waterFrame.Visible = false

&#9;&#9;local waterForceLabel = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;waterForceLabel.Name = &quot;WaterForceLabel&quot;
&#9;&#9;waterForceLabel.BackgroundTransparency = 1
&#9;&#9;waterForceLabel.Size = UDim2.new(1,0,0,12)
&#9;&#9;waterForceLabel.Font = Enum.Font.ArialBold
&#9;&#9;waterForceLabel.FontSize = Enum.FontSize.Size12
&#9;&#9;waterForceLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;waterForceLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;waterForceLabel.Text = &quot;Water Force&quot;
&#9;&#9;waterForceLabel.Parent = waterFrame

&#9;&#9;local waterForceDirLabel = waterForceLabel:Clone()
&#9;&#9;waterForceDirLabel.Name = &quot;WaterForceDirectionLabel&quot;
&#9;&#9;waterForceDirLabel.Text = &quot;Water Force Direction&quot;
&#9;&#9;waterForceDirLabel.Position = UDim2.new(0,0,0,50)
&#9;&#9;waterForceDirLabel.Parent = waterFrame

&#9;&#9;local waterTypeChangedEvent = Instance.new(&quot;BindableEvent&quot;,waterFrame)
&#9;&#9;waterTypeChangedEvent.Name = &quot;WaterTypeChangedEvent&quot;

&#9;&#9;local waterForceDirectionSelectedFunc = function(newForceDirection)
&#9;&#9;&#9;waterForceDirection = newForceDirection
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end
&#9;&#9;local waterForceSelectedFunc = function(newForce)
&#9;&#9;&#9;waterForce = newForce
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end

&#9;&#9;local waterForceDirectionDropDown, forceWaterDirectionSelection = t.CreateDropDownMenu(waterForceDirections, waterForceDirectionSelectedFunc)
&#9;&#9;waterForceDirectionDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDirectionDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;forceWaterDirectionSelection(&quot;NegX&quot;)
&#9;&#9;waterForceDirectionDropDown.Parent = waterForceDirLabel

&#9;&#9;local waterForceDropDown, forceWaterForceSelection = t.CreateDropDownMenu(waterForces, waterForceSelectedFunc)
&#9;&#9;forceWaterForceSelection(&quot;None&quot;)
&#9;&#9;waterForceDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;waterForceDropDown.Parent = waterForceLabel

&#9;&#9;return waterFrame, waterTypeChangedEvent
&#9;end

&#9;-- Helper Function that contructs gui elements
&#9;local function createSetGui()
&#9;
&#9;&#9;local setGui = Instance.new(&quot;ScreenGui&quot;)
&#9;&#9;setGui.Name = &quot;SetGui&quot;
&#9;&#9;
&#9;&#9;local setPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;setPanel.Name = &quot;SetPanel&quot;
&#9;&#9;setPanel.Active = true
&#9;&#9;setPanel.BackgroundTransparency = 1
&#9;&#9;if position then
&#9;&#9;&#9;setPanel.Position = position
&#9;&#9;else
&#9;&#9;&#9;setPanel.Position = UDim2.new(0.2, 29, 0.1, 24)
&#9;&#9;end
&#9;&#9;if size then
&#9;&#9;&#9;setPanel.Size = size
&#9;&#9;else
&#9;&#9;&#9;setPanel.Size = UDim2.new(0.6, -58, 0.64, 0)
&#9;&#9;end
&#9;&#9;setPanel.Style = Enum.FrameStyle.RobloxRound
&#9;&#9;setPanel.ZIndex = 6
&#9;&#9;setPanel.Parent = setGui
&#9;&#9;
&#9;&#9;&#9;-- Children of SetPanel
&#9;&#9;&#9;local itemPreview = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;itemPreview.Name = &quot;ItemPreview&quot;
&#9;&#9;&#9;itemPreview.BackgroundTransparency = 1
&#9;&#9;&#9;itemPreview.Position = UDim2.new(0.8,5,0.085,0)
&#9;&#9;&#9;itemPreview.Size = UDim2.new(0.21,0,0.9,0)
&#9;&#9;&#9;itemPreview.ZIndex = 6
&#9;&#9;&#9;itemPreview.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of ItemPreview
&#9;&#9;&#9;&#9;local textPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;textPanel.Name = &quot;TextPanel&quot;
&#9;&#9;&#9;&#9;textPanel.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;textPanel.Position = UDim2.new(0,0,0.45,0)
&#9;&#9;&#9;&#9;textPanel.Size = UDim2.new(1,0,0.55,0)
&#9;&#9;&#9;&#9;textPanel.ZIndex = 6
&#9;&#9;&#9;&#9;textPanel.Parent = itemPreview
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- Children of TextPanel
&#9;&#9;&#9;&#9;&#9;local rolloverText = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;&#9;rolloverText.Name = &quot;RolloverText&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;rolloverText.Size = UDim2.new(1,0,0,48)
&#9;&#9;&#9;&#9;&#9;rolloverText.ZIndex = 6
&#9;&#9;&#9;&#9;&#9;rolloverText.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;rolloverText.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;&#9;rolloverText.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;&#9;rolloverText.TextWrap = true
&#9;&#9;&#9;&#9;&#9;rolloverText.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;&#9;rolloverText.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;&#9;rolloverText.Parent = textPanel
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local largePreview = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;largePreview.Name = &quot;LargePreview&quot;
&#9;&#9;&#9;&#9;largePreview.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;largePreview.Image = &quot;&quot;
&#9;&#9;&#9;&#9;largePreview.Size = UDim2.new(1,0,0,170)
&#9;&#9;&#9;&#9;largePreview.ZIndex = 6
&#9;&#9;&#9;&#9;largePreview.Parent = itemPreview
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;local sets = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;sets.Name = &quot;Sets&quot;
&#9;&#9;&#9;sets.BackgroundTransparency = 1
&#9;&#9;&#9;sets.Position = UDim2.new(0,0,0,5)
&#9;&#9;&#9;sets.Size = UDim2.new(0.23,0,1,-5)
&#9;&#9;&#9;sets.ZIndex = 6
&#9;&#9;&#9;sets.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Sets
&#9;&#9;&#9;&#9;local line = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;line.Name = &quot;Line&quot;
&#9;&#9;&#9;&#9;line.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;line.BackgroundTransparency = 0.7
&#9;&#9;&#9;&#9;line.BorderSizePixel = 0
&#9;&#9;&#9;&#9;line.Position = UDim2.new(1,-3,0.06,0)
&#9;&#9;&#9;&#9;line.Size = UDim2.new(0,3,0.9,0)
&#9;&#9;&#9;&#9;line.ZIndex = 6
&#9;&#9;&#9;&#9;line.Parent = sets
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsLists, controlFrame = t.CreateTrueScrollingFrame()
&#9;&#9;&#9;&#9;setsLists.Size = UDim2.new(1,-6,0.94,0)
&#9;&#9;&#9;&#9;setsLists.Position = UDim2.new(0,0,0.06,0)
&#9;&#9;&#9;&#9;setsLists.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsLists.Name = &quot;SetsLists&quot;
&#9;&#9;&#9;&#9;setsLists.ZIndex = 6
&#9;&#9;&#9;&#9;setsLists.Parent = sets
&#9;&#9;&#9;&#9;drillDownSetZIndex(controlFrame, 7)
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsHeader = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;setsHeader.Name = &quot;SetsHeader&quot;
&#9;&#9;&#9;&#9;setsHeader.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsHeader.Size = UDim2.new(0,47,0,24)
&#9;&#9;&#9;&#9;setsHeader.ZIndex = 6
&#9;&#9;&#9;&#9;setsHeader.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;setsHeader.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;setsHeader.Text = &quot;Sets&quot;
&#9;&#9;&#9;&#9;setsHeader.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setsHeader.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;setsHeader.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;setsHeader.Parent = sets
&#9;&#9;&#9;
&#9;&#9;&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;&#9;&#9;cancelButton.Position = UDim2.new(1,-32,0,-2)
&#9;&#9;&#9;cancelButton.Size = UDim2.new(0,34,0,34)
&#9;&#9;&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;&#9;cancelButton.ZIndex = 6
&#9;&#9;&#9;cancelButton.Text = &quot;&quot;
&#9;&#9;&#9;cancelButton.Modal = true
&#9;&#9;&#9;cancelButton.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Cancel Button
&#9;&#9;&#9;&#9;local cancelImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;cancelImage.Name = &quot;CancelImage&quot;
&#9;&#9;&#9;&#9;cancelImage.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;cancelImage.Image = &quot;rbxasset://ui/cancel.png&quot;
&#9;&#9;&#9;&#9;cancelImage.Position = UDim2.new(0,-2,0,-2)
&#9;&#9;&#9;&#9;cancelImage.Size = UDim2.new(0,16,0,16)
&#9;&#9;&#9;&#9;cancelImage.ZIndex = 6
&#9;&#9;&#9;&#9;cancelImage.Parent = cancelButton
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;return setGui
&#9;end
&#9;
&#9;local function createSetButton(text)
&#9;&#9;local setButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;
&#9;&#9;if text then setButton.Text = text
&#9;&#9;else setButton.Text = &quot;&quot; end
&#9;&#9;
&#9;&#9;setButton.AutoButtonColor = false
&#9;&#9;setButton.BackgroundTransparency = 1
&#9;&#9;setButton.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.BorderSizePixel = 0
&#9;&#9;setButton.Size = UDim2.new(1,-5,0,18)
&#9;&#9;setButton.ZIndex = 6
&#9;&#9;setButton.Visible = false
&#9;&#9;setButton.Font = Enum.Font.Arial
&#9;&#9;setButton.FontSize = Enum.FontSize.Size18
&#9;&#9;setButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;
&#9;&#9;return setButton
&#9;end
&#9;
&#9;local function buildSetButton(name, setId, setImageId, i,  count)
&#9;&#9;local button = createSetButton(name)
&#9;&#9;button.Text = name
&#9;&#9;button.Name = &quot;SetButton&quot;
&#9;&#9;button.Visible = true
&#9;&#9;
&#9;&#9;local setValue = Instance.new(&quot;IntValue&quot;)
&#9;&#9;setValue.Name = &quot;SetId&quot;
&#9;&#9;setValue.Value = setId
&#9;&#9;setValue.Parent = button

&#9;&#9;local setName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;setName.Name = &quot;SetName&quot;
&#9;&#9;setName.Value = name
&#9;&#9;setName.Parent = button

&#9;&#9;return button
&#9;end
&#9;
&#9;local function processCategory(sets)
&#9;&#9;local setButtons = {}
&#9;&#9;local numSkipped = 0
&#9;&#9;for i = 1, #sets do
&#9;&#9;&#9;if not showAdminCategories and sets[i].Name == &quot;Beta&quot; then
&#9;&#9;&#9;&#9;numSkipped = numSkipped + 1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;setButtons[i - numSkipped] = buildSetButton(sets[i].Name, sets[i].CategoryId, sets[i].ImageAssetId, i - numSkipped, #sets)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return setButtons
&#9;end
&#9;
&#9;local function handleResize()
&#9;&#9;wait() -- neccessary to insure heartbeat happened
&#9;&#9;
&#9;&#9;local itemPreview = setGui.SetPanel.ItemPreview
&#9;&#9;
&#9;&#9;itemPreview.LargePreview.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.X)
&#9;&#9;itemPreview.LargePreview.Position = UDim2.new(0.5,-itemPreview.LargePreview.AbsoluteSize.X/2,0,0)
&#9;&#9;itemPreview.TextPanel.Position = UDim2.new(0,0,0,itemPreview.LargePreview.AbsoluteSize.Y)
&#9;&#9;itemPreview.TextPanel.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.Y - itemPreview.LargePreview.AbsoluteSize.Y)
&#9;end
&#9;
&#9;local function makeInsertAssetButton()
&#9;&#9;local insertAssetButtonExample = Instance.new(&quot;Frame&quot;)
&#9;&#9;insertAssetButtonExample.Name = &quot;InsertAssetButtonExample&quot;
&#9;&#9;insertAssetButtonExample.Position = UDim2.new(0,128,0,64)
&#9;&#9;insertAssetButtonExample.Size = UDim2.new(0,64,0,64)
&#9;&#9;insertAssetButtonExample.BackgroundTransparency = 1
&#9;&#9;insertAssetButtonExample.ZIndex = 6
&#9;&#9;insertAssetButtonExample.Visible = false

&#9;&#9;local assetId = Instance.new(&quot;IntValue&quot;)
&#9;&#9;assetId.Name = &quot;AssetId&quot;
&#9;&#9;assetId.Value = 0
&#9;&#9;assetId.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;local assetName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;assetName.Name = &quot;AssetName&quot;
&#9;&#9;assetName.Value = &quot;&quot;
&#9;&#9;assetName.Parent = insertAssetButtonExample

&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot;
&#9;&#9;button.Text = &quot;&quot;
&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;button.Position = UDim2.new(0.025,0,0.025,0)
&#9;&#9;button.Size = UDim2.new(0.95,0,0.95,0)
&#9;&#9;button.ZIndex = 6
&#9;&#9;button.Parent = insertAssetButtonExample

&#9;&#9;local buttonImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;buttonImage.Name = &quot;ButtonImage&quot;
&#9;&#9;buttonImage.Image = &quot;&quot;
&#9;&#9;buttonImage.Position = UDim2.new(0,-7,0,-7)
&#9;&#9;buttonImage.Size = UDim2.new(1,14,1,14)
&#9;&#9;buttonImage.BackgroundTransparency = 1
&#9;&#9;buttonImage.ZIndex = 7
&#9;&#9;buttonImage.Parent = button

&#9;&#9;local configIcon = buttonImage:clone()
&#9;&#9;configIcon.Name = &quot;ConfigIcon&quot;
&#9;&#9;configIcon.Visible = false
&#9;&#9;configIcon.Position = UDim2.new(1,-23,1,-24)
&#9;&#9;configIcon.Size = UDim2.new(0,16,0,16)
&#9;&#9;configIcon.Image = &quot;&quot;
&#9;&#9;configIcon.ZIndex = 6
&#9;&#9;configIcon.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;return insertAssetButtonExample
&#9;end
&#9;
&#9;local function showLargePreview(insertButton)
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetId&quot;) then
&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(LargeThumbnailUrl .. tostring(insertButton.AssetId.Value))
&#9;&#9;&#9;&#9;setGui.SetPanel.ItemPreview.LargePreview.Image = LargeThumbnailUrl .. tostring(insertButton.AssetId.Value)
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetName&quot;) then
&#9;&#9;&#9;setGui.SetPanel.ItemPreview.TextPanel.RolloverText.Text = insertButton.AssetName.Value
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectTerrainShape(shape)
&#9;&#9;if currTerrainDropDownFrame then
&#9;&#9;&#9;objectSelected(tostring(currTerrainDropDownFrame.AssetName.Value), tonumber(currTerrainDropDownFrame.AssetId.Value), shape)
&#9;&#9;end
&#9;end
&#9;
&#9;local function createTerrainTypeButton(name, parent)
&#9;&#9;local dropDownTextButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;dropDownTextButton.Name = name .. &quot;Button&quot;
&#9;&#9;dropDownTextButton.Font = Enum.Font.ArialBold
&#9;&#9;dropDownTextButton.FontSize = Enum.FontSize.Size14
&#9;&#9;dropDownTextButton.BorderSizePixel = 0
&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;dropDownTextButton.Text = name
&#9;&#9;dropDownTextButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;dropDownTextButton.ZIndex = parent.ZIndex + 1
&#9;&#9;dropDownTextButton.Size = UDim2.new(0,parent.Size.X.Offset - 2,0,16)
&#9;&#9;dropDownTextButton.Position = UDim2.new(0,1,0,0)

&#9;&#9;dropDownTextButton.MouseEnter:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 0
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(0,0,0)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseLeave:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;if dropDownTextButton.Parent and dropDownTextButton.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;dropDownTextButton.Parent.Visible = false
&#9;&#9;&#9;end
&#9;&#9;&#9;selectTerrainShape(terrainShapeMap[dropDownTextButton.Text])
&#9;&#9;end)

&#9;&#9;return dropDownTextButton
&#9;end
&#9;
&#9;local function createTerrainDropDownMenu(zIndex)
&#9;&#9;local dropDown = Instance.new(&quot;Frame&quot;)
&#9;&#9;dropDown.Name = &quot;TerrainDropDown&quot;
&#9;&#9;dropDown.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;dropDown.BorderColor3 = Color3.new(1,0,0)
&#9;&#9;dropDown.Size = UDim2.new(0,200,0,0)
&#9;&#9;dropDown.Visible = false
&#9;&#9;dropDown.ZIndex = zIndex
&#9;&#9;dropDown.Parent = setGui

&#9;&#9;for i = 1, #terrainShapes do
&#9;&#9;&#9;local shapeButton = createTerrainTypeButton(terrainShapes[i],dropDown)
&#9;&#9;&#9;shapeButton.Position = UDim2.new(0,1,0,(i - 1) * (shapeButton.Size.Y.Offset))
&#9;&#9;&#9;shapeButton.Parent = dropDown
&#9;&#9;&#9;dropDown.Size = UDim2.new(0,200,0,dropDown.Size.Y.Offset + (shapeButton.Size.Y.Offset))
&#9;&#9;end

&#9;&#9;dropDown.MouseLeave:connect(function()
&#9;&#9;&#9;dropDown.Visible = false
&#9;&#9;end)
&#9;end

&#9;
&#9;local function createDropDownMenuButton(parent)
&#9;&#9;local dropDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;dropDownButton.Name = &quot;DropDownButton&quot;
&#9;&#9;dropDownButton.Image = &quot;rbxasset://ui/dropdownbutton.png&quot;
&#9;&#9;dropDownButton.BackgroundTransparency = 1
&#9;&#9;dropDownButton.Size = UDim2.new(0,16,0,16)
&#9;&#9;dropDownButton.Position = UDim2.new(1,-24,0,6)
&#9;&#9;dropDownButton.ZIndex = parent.ZIndex + 2
&#9;&#9;dropDownButton.Parent = parent
&#9;&#9;
&#9;&#9;if not setGui:FindFirstChild(&quot;TerrainDropDown&quot;) then
&#9;&#9;&#9;createTerrainDropDownMenu(8)
&#9;&#9;end
&#9;&#9;
&#9;&#9;dropDownButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;setGui.TerrainDropDown.Visible = true
&#9;&#9;&#9;setGui.TerrainDropDown.Position = UDim2.new(0,parent.AbsolutePosition.X,0,parent.AbsolutePosition.Y)
&#9;&#9;&#9;currTerrainDropDownFrame = parent
&#9;&#9;end)
&#9;end
&#9;
&#9;local function buildInsertButton()
&#9;&#9;local insertButton = makeInsertAssetButton()
&#9;&#9;insertButton.Name = &quot;InsertAssetButton&quot;
&#9;&#9;insertButton.Visible = true

&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;createDropDownMenuButton(insertButton)
&#9;&#9;end

&#9;&#9;local lastEnter = nil
&#9;&#9;local mouseEnterCon = insertButton.MouseEnter:connect(function()
&#9;&#9;&#9;lastEnter = insertButton
&#9;&#9;&#9;delay(0.1,function()
&#9;&#9;&#9;&#9;if lastEnter == insertButton then
&#9;&#9;&#9;&#9;&#9;showLargePreview(insertButton)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end)
&#9;&#9;return insertButton, mouseEnterCon
&#9;end
&#9;
&#9;local function realignButtonGrid(columns)
&#9;&#9;local x = 0
&#9;&#9;local y = 0 
&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;insertButtons[i].Position = UDim2.new(0, buttonWidth * x, 0, buttonHeight * y)
&#9;&#9;&#9;x = x + 1
&#9;&#9;&#9;if x &gt;= columns then
&#9;&#9;&#9;&#9;x = 0
&#9;&#9;&#9;&#9;y = y + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function setInsertButtonImageBehavior(insertFrame, visible, name, assetId)
&#9;&#9;if visible then
&#9;&#9;&#9;insertFrame.AssetName.Value = name
&#9;&#9;&#9;insertFrame.AssetId.Value = assetId
&#9;&#9;&#9;local newImageUrl = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;if newImageUrl ~= insertFrame.Button.ButtonImage.Image then
&#9;&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(SmallThumbnailUrl  .. assetId)
&#9;&#9;&#9;&#9;&#9;insertFrame.Button.ButtonImage.Image = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;table.insert(insertButtonCons,
&#9;&#9;&#9;&#9;insertFrame.Button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;-- special case for water, show water selection gui
&#9;&#9;&#9;&#9;&#9;local isWaterSelected = (name == &quot;Water&quot;) and (Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot;)
&#9;&#9;&#9;&#9;&#9;waterGui.Visible = isWaterSelected
&#9;&#9;&#9;&#9;&#9;if isWaterSelected then
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId), nil)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId))
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;)
&#9;&#9;&#9;insertFrame.Visible = true
&#9;&#9;else
&#9;&#9;&#9;insertFrame.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local function loadSectionOfItems(setGui, rows, columns)
&#9;&#9;local pageSize = rows * columns

&#9;&#9;if arrayPosition &gt; #contents then return end

&#9;&#9;local origArrayPos = arrayPosition

&#9;&#9;local yCopy = 0
&#9;&#9;for i = 1, pageSize + 1 do 
&#9;&#9;&#9;if arrayPosition &gt;= #contents + 1 then
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end

&#9;&#9;&#9;local buttonCon
&#9;&#9;&#9;insertButtons[arrayPosition], buttonCon = buildInsertButton()
&#9;&#9;&#9;table.insert(insertButtonCons,buttonCon)
&#9;&#9;&#9;insertButtons[arrayPosition].Parent = setGui.SetPanel.ItemsFrame
&#9;&#9;&#9;arrayPosition = arrayPosition + 1
&#9;&#9;end
&#9;&#9;realignButtonGrid(columns)

&#9;&#9;local indexCopy = origArrayPos
&#9;&#9;for index = origArrayPos, arrayPosition do
&#9;&#9;&#9;if insertButtons[index] then
&#9;&#9;&#9;&#9;if contents[index] then

&#9;&#9;&#9;&#9;&#9;-- we don&apos;t want water to have a drop down button
&#9;&#9;&#9;&#9;&#9;if contents[index].Name == &quot;Water&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;insertButtons[index]:FindFirstChild(&quot;DropDownButton&quot;,true):Destroy()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;local assetId
&#9;&#9;&#9;&#9;&#9;if useAssetVersionId then
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetVersionId
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;setInsertButtonImageBehavior(insertButtons[index], true, contents[index].Name, assetId)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;&#9;indexCopy = index
&#9;&#9;end
&#9;end
&#9;
&#9;local function setSetIndex()
&#9;&#9;Data.Category[Data.CurrentCategory].Index = 0

&#9;&#9;rows = 7
&#9;&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;&#9;contents = Data.Category[Data.CurrentCategory].Contents
&#9;&#9;if contents then
&#9;&#9;&#9;-- remove our buttons and their connections
&#9;&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;&#9;insertButtons[i]:remove()
&#9;&#9;&#9;end
&#9;&#9;&#9;for i = 1, #insertButtonCons do
&#9;&#9;&#9;&#9;if insertButtonCons[i] then insertButtonCons[i]:disconnect() end
&#9;&#9;&#9;end
&#9;&#9;&#9;insertButtonCons = {}
&#9;&#9;&#9;insertButtons = {}

&#9;&#9;&#9;arrayPosition = 1
&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectSet(button, setName, setId, setIndex)
&#9;&#9;if button and Data.Category[Data.CurrentCategory] ~= nil then
&#9;&#9;&#9;if button ~= Data.Category[Data.CurrentCategory].Button then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = button

&#9;&#9;&#9;&#9;if SetCache[setId] == nil then
&#9;&#9;&#9;&#9;&#9;SetCache[setId] = game:GetService(&quot;InsertService&quot;):GetCollection(setId)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Contents = SetCache[setId]

&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetName = setName
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetId = setId
&#9;&#9;&#9;end
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategoryPage(buttons, page)
&#9;&#9;if buttons ~= Data.CurrentCategory then
&#9;&#9;&#9;if Data.CurrentCategory then
&#9;&#9;&#9;&#9;for key, button in pairs(Data.CurrentCategory) do
&#9;&#9;&#9;&#9;&#9;button.Visible = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;Data.CurrentCategory = buttons
&#9;&#9;&#9;if Data.Category[Data.CurrentCategory] == nil then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory] = {}
&#9;&#9;&#9;&#9;if #buttons &gt; 0 then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[1], buttons[1].SetName.Value, buttons[1].SetId.Value, 0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = nil
&#9;&#9;&#9;&#9;selectSet(Data.Category[Data.CurrentCategory].ButtonFrame, Data.Category[Data.CurrentCategory].SetName, Data.Category[Data.CurrentCategory].SetId, Data.Category[Data.CurrentCategory].Index)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategory(category)
&#9;&#9;selectCategoryPage(category, 0)
&#9;end
&#9;
&#9;local function resetAllSetButtonSelection()
&#9;&#9;local setButtons = setGui.SetPanel.Sets.SetsLists:GetChildren()
&#9;&#9;for i = 1, #setButtons do
&#9;&#9;&#9;if setButtons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;setButtons[i].Selected = false
&#9;&#9;&#9;&#9;setButtons[i].BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setButtons[i].TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setButtons[i].BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function populateSetsFrame()
&#9;&#9;local currRow = 0
&#9;&#9;for i = 1, #userCategoryButtons do
&#9;&#9;&#9;local button = userCategoryButtons[i]
&#9;&#9;&#9;button.Visible = true
&#9;&#9;&#9;button.Position = UDim2.new(0,5,0,currRow * button.Size.Y.Offset)
&#9;&#9;&#9;button.Parent = setGui.SetPanel.Sets.SetsLists
&#9;&#9;&#9;
&#9;&#9;&#9;if i == 1 then -- we will have this selected by default, so show it
&#9;&#9;&#9;&#9;button.Selected = true
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;end

&#9;&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;resetAllSetButtonSelection()
&#9;&#9;&#9;&#9;button.Selected = not button.Selected
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;selectSet(button, button.Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;end)

&#9;&#9;&#9;currRow = currRow + 1
&#9;&#9;end

&#9;&#9;local buttons =  setGui.SetPanel.Sets.SetsLists:GetChildren()

&#9;&#9;-- set first category as loaded for default
&#9;&#9;if buttons then
&#9;&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;&#9;if buttons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[i], buttons[i].Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;&#9;&#9;selectCategory(userCategoryButtons)
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;setGui = createSetGui()
&#9;waterGui, waterTypeChangedEvent = createWaterGui()
&#9;waterGui.Position = UDim2.new(0,55,0,0)
&#9;waterGui.Parent = setGui
&#9;setGui.Changed:connect(function(prop) -- this resizes the preview image to always be the right size
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;handleResize()
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end)
&#9;
&#9;local scrollFrame, controlFrame = t.CreateTrueScrollingFrame()
&#9;scrollFrame.Size = UDim2.new(0.54,0,0.85,0)
&#9;scrollFrame.Position = UDim2.new(0.24,0,0.085,0)
&#9;scrollFrame.Name = &quot;ItemsFrame&quot;
&#9;scrollFrame.ZIndex = 6
&#9;scrollFrame.Parent = setGui.SetPanel
&#9;scrollFrame.BackgroundTransparency = 1

&#9;drillDownSetZIndex(controlFrame,7)

&#9;controlFrame.Parent = setGui.SetPanel
&#9;controlFrame.Position = UDim2.new(0.76, 5, 0, 0)

&#9;local debounce = false
&#9;controlFrame.ScrollBottom.Changed:connect(function(prop)
&#9;&#9;if controlFrame.ScrollBottom.Value == true then
&#9;&#9;&#9;if debounce then return end
&#9;&#9;&#9;debounce = true
&#9;&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;&#9;debounce = false
&#9;&#9;end
&#9;end)

&#9;local userData = {}
&#9;for id = 1, #userIdsForSets do
&#9;&#9;local newUserData = game:GetService(&quot;InsertService&quot;):GetUserSets(userIdsForSets[id])
&#9;&#9;if newUserData and #newUserData &gt; 2 then
&#9;&#9;&#9;-- start at #3 to skip over My Decals and My Models for each account
&#9;&#9;&#9;for category = 3, #newUserData do
&#9;&#9;&#9;&#9;if newUserData[category].Name == &quot;High Scalability&quot; then -- we want high scalability parts to show first
&#9;&#9;&#9;&#9;&#9;table.insert(userData,1,newUserData[category])
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;table.insert(userData, newUserData[category])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;
&#9;end
&#9;if userData then
&#9;&#9;userCategoryButtons = processCategory(userData)
&#9;end

&#9;rows = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;populateSetsFrame()

&#9;insertPanelCloseCon = setGui.SetPanel.CancelButton.MouseButton1Click:connect(function()
&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;if dialogClosed then dialogClosed() end
&#9;end)
&#9;
&#9;local setVisibilityFunction = function(visible)
&#9;&#9;if visible then
&#9;&#9;&#9;setGui.SetPanel.Visible = true
&#9;&#9;else
&#9;&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local getVisibilityFunction = function()
&#9;&#9;if setGui then
&#9;&#9;&#9;if setGui:FindFirstChild(&quot;SetPanel&quot;) then
&#9;&#9;&#9;&#9;return setGui.SetPanel.Visible
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;return false
&#9;end
&#9;
&#9;return setGui, setVisibilityFunction, getVisibilityFunction, waterTypeChangedEvent
end

t.CreateTerrainMaterialSelector = function(size,position)
&#9;local terrainMaterialSelectionChanged = Instance.new(&quot;BindableEvent&quot;)
&#9;terrainMaterialSelectionChanged.Name = &quot;TerrainMaterialSelectionChanged&quot;

&#9;local selectedButton = nil

&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TerrainMaterialSelector&quot;
&#9;if size then
&#9;&#9;frame.Size = size
&#9;else
&#9;&#9;frame.Size = UDim2.new(0, 245, 0, 230)
&#9;end
&#9;if position then
&#9;&#9;frame.Position = position
&#9;end
&#9;frame.BorderSizePixel = 0
&#9;frame.BackgroundColor3 = Color3.new(0,0,0)
&#9;frame.Active = true

&#9;terrainMaterialSelectionChanged.Parent = frame

&#9;local waterEnabled = true -- todo: turn this on when water is ready

&#9;local materialToImageMap = {}
&#9;local materialNames = {&quot;Grass&quot;, &quot;Sand&quot;, &quot;Brick&quot;, &quot;Granite&quot;, &quot;Asphalt&quot;, &quot;Iron&quot;, &quot;Aluminum&quot;, &quot;Gold&quot;, &quot;Plank&quot;, &quot;Log&quot;, &quot;Gravel&quot;, &quot;Cinder Block&quot;, &quot;Stone Wall&quot;, &quot;Concrete&quot;, &quot;Plastic (red)&quot;, &quot;Plastic (blue)&quot;}
&#9;if waterEnabled then
&#9;&#9;table.insert(materialNames,&quot;Water&quot;)
&#9;end
&#9;local currentMaterial = 1

&#9;function getEnumFromName(choice)
&#9;&#9;if choice == &quot;Grass&quot; then return 1 end
&#9;&#9;if choice == &quot;Sand&quot; then return 2 end 
&#9;&#9;if choice == &quot;Erase&quot; then return 0 end
&#9;&#9;if choice == &quot;Brick&quot; then return 3 end
&#9;&#9;if choice == &quot;Granite&quot; then return 4 end
&#9;&#9;if choice == &quot;Asphalt&quot; then return 5 end
&#9;&#9;if choice == &quot;Iron&quot; then return 6 end
&#9;&#9;if choice == &quot;Aluminum&quot; then return 7 end
&#9;&#9;if choice == &quot;Gold&quot; then return 8 end
&#9;&#9;if choice == &quot;Plank&quot; then return 9 end
&#9;&#9;if choice == &quot;Log&quot; then return 10 end
&#9;&#9;if choice == &quot;Gravel&quot; then return 11 end
&#9;&#9;if choice == &quot;Cinder Block&quot; then return 12 end
&#9;&#9;if choice == &quot;Stone Wall&quot; then return 13 end
&#9;&#9;if choice == &quot;Concrete&quot; then return 14 end
&#9;&#9;if choice == &quot;Plastic (red)&quot; then return 15 end
&#9;&#9;if choice == &quot;Plastic (blue)&quot; then return 16 end
&#9;&#9;if choice == &quot;Water&quot; then return 17 end
&#9;end

&#9;function getNameFromEnum(choice)
&#9;&#9;if choice == Enum.CellMaterial.Grass or choice == 1 then return &quot;Grass&quot;end
&#9;&#9;if choice == Enum.CellMaterial.Sand or choice == 2 then return &quot;Sand&quot; end 
&#9;&#9;if choice == Enum.CellMaterial.Empty or choice == 0 then return &quot;Erase&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Brick or choice == 3 then return &quot;Brick&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Granite or choice == 4 then return &quot;Granite&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Asphalt or choice == 5 then return &quot;Asphalt&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Iron or choice == 6 then return &quot;Iron&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Aluminum or choice == 7 then return &quot;Aluminum&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gold or choice == 8 then return &quot;Gold&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodPlank or choice == 9 then return &quot;Plank&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodLog or choice == 10 then return &quot;Log&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gravel or choice == 11 then return &quot;Gravel&quot; end
&#9;&#9;if choice == Enum.CellMaterial.CinderBlock or choice == 12 then return &quot;Cinder Block&quot; end
&#9;&#9;if choice == Enum.CellMaterial.MossyStone or choice == 13 then return &quot;Stone Wall&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Cement or choice == 14 then return &quot;Concrete&quot; end
&#9;&#9;if choice == Enum.CellMaterial.RedPlastic or choice == 15 then return &quot;Plastic (red)&quot; end
&#9;&#9;if choice == Enum.CellMaterial.BluePlastic or choice == 16 then return &quot;Plastic (blue)&quot; end

&#9;&#9;if waterEnabled then
&#9;&#9;&#9;if choice == Enum.CellMaterial.Water or choice == 17 then return &quot;Water&quot; end
&#9;&#9;end
&#9;end


&#9;local function updateMaterialChoice(choice)
&#9;&#9;currentMaterial = getEnumFromName(choice)
&#9;&#9;terrainMaterialSelectionChanged:Fire(currentMaterial)
&#9;end

&#9;-- we so need a better way to do this
&#9;for i,v in pairs(materialNames) do
&#9;&#9;materialToImageMap[v] = {}
&#9;&#9;if v == &quot;Grass&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Grass.png&quot;
&#9;&#9;elseif v == &quot;Sand&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Sand.png&quot;
&#9;&#9;elseif v == &quot;Brick&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Brick.png&quot;
&#9;&#9;elseif v == &quot;Granite&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Granite.png&quot;
&#9;&#9;elseif v == &quot;Asphalt&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Asphalt.png&quot;
&#9;&#9;elseif v == &quot;Iron&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Iron.png&quot;
&#9;&#9;elseif v == &quot;Aluminum&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Aluminum.png&quot;
&#9;&#9;elseif v == &quot;Gold&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Gold.png&quot;
&#9;&#9;elseif v == &quot;Plastic (red)&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/PlasticRed.png&quot;
&#9;&#9;elseif v == &quot;Plastic (blue)&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/PlasticBlue.png&quot;
&#9;&#9;elseif v == &quot;Plank&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Plank.png&quot;
&#9;&#9;elseif v == &quot;Log&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Log.png&quot;
&#9;&#9;elseif v == &quot;Gravel&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Gravel.png&quot;
&#9;&#9;elseif v == &quot;Cinder Block&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/CinderBlock.png&quot;
&#9;&#9;elseif v == &quot;Stone Wall&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/StoneWall.png&quot;
&#9;&#9;elseif v == &quot;Concrete&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Concrete.png&quot;
&#9;&#9;elseif v == &quot;Water&quot; then materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/Water.png&quot;
&#9;&#9;else materialToImageMap[v].Regular = &quot;rbxasset://textures/terrain/unknown.png&quot; -- fill in the rest here!!
&#9;&#9;end
&#9;end

&#9;local scrollFrame, scrollUp, scrollDown, recalculateScroll = t.CreateScrollingFrame(nil,&quot;grid&quot;)
&#9;scrollFrame.Size = UDim2.new(0.85,0,1,0)
&#9;scrollFrame.Position = UDim2.new(0,0,0,0)
&#9;scrollFrame.Parent = frame

&#9;scrollUp.Parent = frame
&#9;scrollUp.Visible = true
&#9;scrollUp.Position = UDim2.new(1,-19,0,0)

&#9;scrollDown.Parent = frame
&#9;scrollDown.Visible = true
&#9;scrollDown.Position = UDim2.new(1,-19,1,-17)

&#9;local function goToNewMaterial(buttonWrap, materialName)
&#9;&#9;updateMaterialChoice(materialName)
&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;selectedButton.BackgroundTransparency = 1
&#9;&#9;selectedButton = buttonWrap
&#9;end

&#9;local function createMaterialButton(name)&#9;
&#9;&#9;local buttonWrap = Instance.new(&quot;TextButton&quot;)
&#9;&#9;buttonWrap.Text = &quot;&quot;
&#9;&#9;buttonWrap.Size = UDim2.new(0,32,0,32)
&#9;&#9;buttonWrap.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;buttonWrap.BorderSizePixel = 0
&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;buttonWrap.AutoButtonColor = false
&#9;&#9;buttonWrap.Name = tostring(name)
&#9;&#9;
&#9;&#9;local imageButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;imageButton.AutoButtonColor = false
&#9;&#9;imageButton.BackgroundTransparency = 1
&#9;&#9;imageButton.Size = UDim2.new(0,30,0,30)
&#9;&#9;imageButton.Position = UDim2.new(0,1,0,1)
&#9;&#9;imageButton.Name = tostring(name)
&#9;&#9;imageButton.Parent = buttonWrap
&#9;&#9;imageButton.Image = materialToImageMap[name].Regular

&#9;&#9;local enumType = Instance.new(&quot;NumberValue&quot;)
&#9;&#9;enumType.Name = &quot;EnumType&quot;
&#9;&#9;enumType.Parent = buttonWrap
&#9;&#9;enumType.Value = 0
&#9;&#9;
&#9;&#9;imageButton.MouseEnter:connect(function()
&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;imageButton.MouseLeave:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;imageButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;goToNewMaterial(buttonWrap, tostring(name))
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;
&#9;&#9;return buttonWrap 
&#9;end

&#9;for i = 1, #materialNames do
&#9;&#9;local imageButton = createMaterialButton(materialNames[i])
&#9;&#9;
&#9;&#9;if materialNames[i] == &quot;Grass&quot; then -- always start with grass as the default
&#9;&#9;&#9;selectedButton = imageButton
&#9;&#9;&#9;imageButton.BackgroundTransparency = 0
&#9;&#9;end
&#9;&#9;
&#9;&#9;imageButton.Parent = scrollFrame
&#9;end

&#9;local forceTerrainMaterialSelection = function(newMaterialType)
&#9;&#9;if not newMaterialType then return end
&#9;&#9;if currentMaterial == newMaterialType then return end

&#9;&#9;local matName = getNameFromEnum(newMaterialType)
&#9;&#9;local buttons = scrollFrame:GetChildren()
&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (blue)&quot; and matName == &quot;Plastic (blue)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (red)&quot; and matName == &quot;Plastic (red)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if string.find(buttons[i].Name, matName) then
&#9;&#9;&#9;&#9;goToNewMaterial(buttons[i],matName)
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(function ( prop )
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;recalculateScroll()
&#9;&#9;end
&#9;end)

&#9;recalculateScroll()
&#9;return frame, terrainMaterialSelectionChanged, forceTerrainMaterialSelection
end

t.CreateLoadingFrame = function(name,size,position)
&#9;game:GetService(&quot;ContentProvider&quot;):Preload(&quot;rbxasset://ui/loadingbar.png&quot;)

&#9;local loadingFrame = Instance.new(&quot;Frame&quot;)
&#9;loadingFrame.Name = &quot;LoadingFrame&quot;
&#9;loadingFrame.Style = Enum.FrameStyle.RobloxRound

&#9;if size then loadingFrame.Size = size
&#9;else loadingFrame.Size = UDim2.new(0,300,0,160) end
&#9;if position then loadingFrame.Position = position 
&#9;else loadingFrame.Position = UDim2.new(0.5, -150, 0.5,-80) end

&#9;local loadingBar = Instance.new(&quot;Frame&quot;)
&#9;loadingBar.Name = &quot;LoadingBar&quot;
&#9;loadingBar.BackgroundColor3 = Color3.new(0,0,0)
&#9;loadingBar.BorderColor3 = Color3.new(79/255,79/255,79/255)
&#9;loadingBar.Position = UDim2.new(0,0,0,41)
&#9;loadingBar.Size = UDim2.new(1,0,0,30)
&#9;loadingBar.Parent = loadingFrame

&#9;&#9;local loadingGreenBar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;loadingGreenBar.Name = &quot;LoadingGreenBar&quot;
&#9;&#9;loadingGreenBar.Image = &quot;rbxasset://ui/loadingbar.png&quot;
&#9;&#9;loadingGreenBar.Position = UDim2.new(0,0,0,0)
&#9;&#9;loadingGreenBar.Size = UDim2.new(0,0,1,0)
&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;loadingGreenBar.Parent = loadingBar

&#9;&#9;local loadingPercent = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;loadingPercent.Name = &quot;LoadingPercent&quot;
&#9;&#9;loadingPercent.BackgroundTransparency = 1
&#9;&#9;loadingPercent.Position = UDim2.new(0,0,1,0)
&#9;&#9;loadingPercent.Size = UDim2.new(1,0,0,14)
&#9;&#9;loadingPercent.Font = Enum.Font.Arial
&#9;&#9;loadingPercent.Text = &quot;0%&quot;
&#9;&#9;loadingPercent.FontSize = Enum.FontSize.Size14
&#9;&#9;loadingPercent.TextColor3 = Color3.new(1,1,1)
&#9;&#9;loadingPercent.Parent = loadingBar

&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;cancelButton.Position = UDim2.new(0.5,-60,1,-40)
&#9;cancelButton.Size = UDim2.new(0,120,0,40)
&#9;cancelButton.Font = Enum.Font.Arial
&#9;cancelButton.FontSize = Enum.FontSize.Size18
&#9;cancelButton.TextColor3 = Color3.new(1,1,1)
&#9;cancelButton.Text = &quot;Cancel&quot;
&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButton
&#9;cancelButton.Parent = loadingFrame

&#9;local loadingName = Instance.new(&quot;TextLabel&quot;)
&#9;loadingName.Name = &quot;loadingName&quot;
&#9;loadingName.BackgroundTransparency = 1
&#9;loadingName.Size = UDim2.new(1,0,0,18)
&#9;loadingName.Position = UDim2.new(0,0,0,2)
&#9;loadingName.Font = Enum.Font.Arial
&#9;loadingName.Text = name
&#9;loadingName.TextColor3 = Color3.new(1,1,1)
&#9;loadingName.TextStrokeTransparency = 1
&#9;loadingName.FontSize = Enum.FontSize.Size18
&#9;loadingName.Parent = loadingFrame

&#9;local cancelButtonClicked = Instance.new(&quot;BindableEvent&quot;)
&#9;cancelButtonClicked.Name = &quot;CancelButtonClicked&quot;
&#9;cancelButtonClicked.Parent = cancelButton
&#9;cancelButton.MouseButton1Click:connect(function()
&#9;&#9;cancelButtonClicked:Fire()
&#9;end)

&#9;local updateLoadingGuiPercent = function(percent, tweenAction, tweenLength)
&#9;&#9;if percent and type(percent) ~= &quot;number&quot; then
&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent expects number as argument, got&quot;,type(percent),&quot;instead&quot;)
&#9;&#9;end

&#9;&#9;local newSize = nil
&#9;&#9;if percent &lt; 0 then
&#9;&#9;&#9;newSize = UDim2.new(0,0,1,0)
&#9;&#9;elseif percent &gt; 1 then
&#9;&#9;&#9;newSize = UDim2.new(1,0,1,0)
&#9;&#9;else
&#9;&#9;&#9;newSize = UDim2.new(percent,0,1,0)
&#9;&#9;end

&#9;&#9;if tweenAction then
&#9;&#9;&#9;if not tweenLength then
&#9;&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent is set to tween new percentage, but got no tween time length! Please pass this in as third argument&quot;)
&#9;&#9;&#9;end

&#9;&#9;&#9;if (newSize.X.Scale &gt; 0) then
&#9;&#9;&#9;&#9;loadingGreenBar.Visible = true
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function() 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (newSize.X.Scale &lt; 0) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end

&#9;&#9;else
&#9;&#9;&#9;loadingGreenBar.Size = newSize
&#9;&#9;&#9;loadingGreenBar.Visible = (newSize.X.Scale &gt; 0)
&#9;&#9;end
&#9;end

&#9;loadingGreenBar.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Size&quot; then
&#9;&#9;&#9;loadingPercent.Text = tostring( math.ceil(loadingGreenBar.Size.X.Scale * 100) ) .. &quot;%&quot;
&#9;&#9;end
&#9;end)

&#9;return loadingFrame, updateLoadingGuiPercent, cancelButtonClicked
end

t.CreatePluginFrame = function (name,size,position,scrollable,parent)
&#9;function createMenuButton(size,position,text,fontsize,name,parent)
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;,parent)
&#9;&#9;button.AutoButtonColor = false
&#9;&#9;button.Name = name
&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;button.Position = position
&#9;&#9;button.Size = size
&#9;&#9;button.Font = Enum.Font.ArialBold
&#9;&#9;button.FontSize = fontsize
&#9;&#9;button.Text =  text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.BorderSizePixel = 0
&#9;&#9;button.BackgroundColor3 = Color3.new(20/255,20/255,20/255)

&#9;&#9;button.MouseEnter:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;button.MouseLeave:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)

&#9;&#9;return button

&#9;end

&#9;local dragBar = Instance.new(&quot;Frame&quot;,parent)
&#9;dragBar.Name = tostring(name) .. &quot;DragBar&quot;
&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;dragBar.BorderColor3 = Color3.new(0,0,0)
&#9;if size then
&#9;&#9;dragBar.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,20)  + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;dragBar.Size = UDim2.new(0,183,0,20)
&#9;end
&#9;if position then
&#9;&#9;dragBar.Position = position
&#9;end
&#9;dragBar.Active = true
&#9;dragBar.Draggable = true
&#9;--dragBar.Visible = false
&#9;dragBar.MouseEnter:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(49/255,49/255,49/255)
&#9;end)
&#9;dragBar.MouseLeave:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;end)

&#9;-- plugin name label
&#9;local pluginNameLabel = Instance.new(&quot;TextLabel&quot;,dragBar)
&#9;pluginNameLabel.Name = &quot;BarNameLabel&quot;
&#9;pluginNameLabel.Text = &quot; &quot; .. tostring(name)
&#9;pluginNameLabel.TextColor3 = Color3.new(1,1,1)
&#9;pluginNameLabel.TextStrokeTransparency = 0
&#9;pluginNameLabel.Size = UDim2.new(1,0,1,0)
&#9;pluginNameLabel.Font = Enum.Font.ArialBold
&#9;pluginNameLabel.FontSize = Enum.FontSize.Size18
&#9;pluginNameLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;pluginNameLabel.BackgroundTransparency = 1

&#9;-- close button
&#9;local closeButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-16,0.5,-8),&quot;X&quot;,Enum.FontSize.Size14,&quot;CloseButton&quot;,dragBar)
&#9;local closeEvent = Instance.new(&quot;BindableEvent&quot;)
&#9;closeEvent.Name = &quot;CloseEvent&quot;
&#9;closeEvent.Parent = closeButton
&#9;closeButton.MouseButton1Click:connect(function ()
&#9;&#9;closeEvent:Fire()
&#9;&#9;closeButton.BackgroundTransparency = 1
&#9;end)

&#9;-- help button
&#9;local helpButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-51,0.5,-8),&quot;?&quot;,Enum.FontSize.Size14,&quot;HelpButton&quot;,dragBar)
&#9;local helpFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;helpFrame.Name = &quot;HelpFrame&quot;
&#9;helpFrame.BackgroundColor3 = Color3.new(0,0,0)
&#9;helpFrame.Size = UDim2.new(0,300,0,552)
&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;helpFrame.Active = true
&#9;helpFrame.BorderSizePixel = 0
&#9;helpFrame.Visible = false

&#9;helpButton.MouseButton1Click:connect(function(  )
&#9;&#9;helpFrame.Visible = not helpFrame.Visible
&#9;&#9;if helpFrame.Visible then
&#9;&#9;&#9;helpButton.Selected = true
&#9;&#9;&#9;helpButton.BackgroundTransparency = 0
&#9;&#9;&#9;local screenGui = getScreenGuiAncestor(helpFrame)
&#9;&#9;&#9;if screenGui then
&#9;&#9;&#9;&#9;if helpFrame.AbsolutePosition.X + helpFrame.AbsoluteSize.X &gt; screenGui.AbsoluteSize.X then --position on left hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(0,-5 - helpFrame.AbsoluteSize.X,0,0)
&#9;&#9;&#9;&#9;else -- position on right hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;helpButton.Selected = false
&#9;&#9;&#9;helpButton.BackgroundTransparency = 1
&#9;&#9;end
&#9;end)

&#9;local minimizeButton = createMenuButton(UDim2.new(0,16,0,17),UDim2.new(1,-34,0.5,-8),&quot;-&quot;,Enum.FontSize.Size14,&quot;MinimizeButton&quot;,dragBar)
&#9;minimizeButton.TextYAlignment = Enum.TextYAlignment.Top

&#9;local minimizeFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;minimizeFrame.Name = &quot;MinimizeFrame&quot;
&#9;minimizeFrame.BackgroundColor3 = Color3.new(73/255,73/255,73/255)
&#9;minimizeFrame.BorderColor3 = Color3.new(0,0,0)
&#9;minimizeFrame.Position = UDim2.new(0,0,1,0)
&#9;if size then
&#9;&#9;minimizeFrame.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,50) + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;minimizeFrame.Size = UDim2.new(0,183,0,50)
&#9;end
&#9;minimizeFrame.Visible = false

&#9;local minimizeBigButton = Instance.new(&quot;TextButton&quot;,minimizeFrame)
&#9;minimizeBigButton.Position = UDim2.new(0.5,-50,0.5,-20)
&#9;minimizeBigButton.Name = &quot;MinimizeButton&quot;
&#9;minimizeBigButton.Size = UDim2.new(0,100,0,40)
&#9;minimizeBigButton.Style = Enum.ButtonStyle.RobloxButton
&#9;minimizeBigButton.Font = Enum.Font.ArialBold
&#9;minimizeBigButton.FontSize = Enum.FontSize.Size18
&#9;minimizeBigButton.TextColor3 = Color3.new(1,1,1)
&#9;minimizeBigButton.Text = &quot;Show&quot;

&#9;local separatingLine = Instance.new(&quot;Frame&quot;,dragBar)
&#9;separatingLine.Name = &quot;SeparatingLine&quot;
&#9;separatingLine.BackgroundColor3 = Color3.new(115/255,115/255,115/255)
&#9;separatingLine.BorderSizePixel = 0
&#9;separatingLine.Position = UDim2.new(1,-18,0.5,-7)
&#9;separatingLine.Size = UDim2.new(0,1,0,14)

&#9;local otherSeparatingLine = separatingLine:clone()
&#9;otherSeparatingLine.Position = UDim2.new(1,-35,0.5,-7)
&#9;otherSeparatingLine.Parent = dragBar

&#9;local widgetContainer = Instance.new(&quot;Frame&quot;,dragBar)
&#9;widgetContainer.Name = &quot;WidgetContainer&quot;
&#9;widgetContainer.BackgroundTransparency = 1
&#9;widgetContainer.Position = UDim2.new(0,0,1,0)
&#9;widgetContainer.BorderColor3 = Color3.new(0,0,0)
&#9;if not scrollable then
&#9;&#9;widgetContainer.BackgroundTransparency = 0
&#9;&#9;widgetContainer.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;end

&#9;if size then
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = size
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,size.Y.Scale,size.Y.Offset)
&#9;&#9;end
&#9;else
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,163,0,400)
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,0,400)
&#9;&#9;end
&#9;end
&#9;if position then
&#9;&#9;widgetContainer.Position = position + UDim2.new(0,0,0,20)
&#9;end

&#9;local frame,control,verticalDragger = nil
&#9;if scrollable then
&#9;&#9;--frame for widgets
&#9;&#9;frame,control = t.CreateTrueScrollingFrame()
&#9;&#9;frame.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;frame.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;frame.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;frame.Active = true
&#9;&#9;frame.Parent = widgetContainer
&#9;&#9;control.Parent = dragBar
&#9;&#9;control.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;control.BorderSizePixel = 0
&#9;&#9;control.BackgroundTransparency = 0
&#9;&#9;control.Position = UDim2.new(1,-21,1,1)
&#9;&#9;if size then
&#9;&#9;&#9;control.Size = UDim2.new(0,21,size.Y.Scale,size.Y.Offset)
&#9;&#9;else
&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,400)
&#9;&#9;end
&#9;&#9;control:FindFirstChild(&quot;ScrollDownButton&quot;).Position = UDim2.new(0,0,1,-20)

&#9;&#9;local fakeLine = Instance.new(&quot;Frame&quot;,control)
&#9;&#9;fakeLine.Name = &quot;FakeLine&quot;
&#9;&#9;fakeLine.BorderSizePixel = 0
&#9;&#9;fakeLine.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;fakeLine.Size = UDim2.new(0,1,1,1)
&#9;&#9;fakeLine.Position = UDim2.new(1,0,0,0)

&#9;&#9;verticalDragger = Instance.new(&quot;TextButton&quot;,widgetContainer)
&#9;&#9;verticalDragger.ZIndex = 2
&#9;&#9;verticalDragger.AutoButtonColor = false
&#9;&#9;verticalDragger.Name = &quot;VerticalDragger&quot;
&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;verticalDragger.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;verticalDragger.Size = UDim2.new(1,20,0,20)
&#9;&#9;verticalDragger.Position = UDim2.new(0,0,1,0)
&#9;&#9;verticalDragger.Active = true
&#9;&#9;verticalDragger.Text = &quot;&quot;

&#9;&#9;local scrubFrame = Instance.new(&quot;Frame&quot;,verticalDragger)
&#9;&#9;scrubFrame.Name = &quot;ScrubFrame&quot;
&#9;&#9;scrubFrame.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;scrubFrame.BorderSizePixel = 0
&#9;&#9;scrubFrame.Position = UDim2.new(0.5,-5,0.5,0)
&#9;&#9;scrubFrame.Size = UDim2.new(0,10,0,1)
&#9;&#9;scrubFrame.ZIndex = 5
&#9;&#9;local scrubTwo = scrubFrame:clone()
&#9;&#9;scrubTwo.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;&#9;scrubTwo.Parent = verticalDragger
&#9;&#9;local scrubThree = scrubFrame:clone()
&#9;&#9;scrubThree.Position = UDim2.new(0.5,-5,0.5,2)
&#9;&#9;scrubThree.Parent = verticalDragger

&#9;&#9;local areaSoak = Instance.new(&quot;TextButton&quot;,getScreenGuiAncestor(parent))
&#9;&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;&#9;areaSoak.BackgroundTransparency = 1
&#9;&#9;areaSoak.BorderSizePixel = 0
&#9;&#9;areaSoak.Text = &quot;&quot;
&#9;&#9;areaSoak.ZIndex = 10
&#9;&#9;areaSoak.Visible = false
&#9;&#9;areaSoak.Active = true

&#9;&#9;local draggingVertical = false
&#9;&#9;local startYPos = nil
&#9;&#9;verticalDragger.MouseEnter:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(60/255,60/255,60/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseLeave:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseButton1Down:connect(function(x,y)
&#9;&#9;&#9;draggingVertical = true
&#9;&#9;&#9;areaSoak.Visible = true
&#9;&#9;&#9;startYPos = y
&#9;&#9;end)
&#9;&#9;areaSoak.MouseButton1Up:connect(function (  )
&#9;&#9;&#9;draggingVertical = false
&#9;&#9;&#9;areaSoak.Visible = false
&#9;&#9;end)
&#9;&#9;areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;if not draggingVertical then return end

&#9;&#9;&#9;local yDelta = y - startYPos
&#9;&#9;&#9;if not control.ScrollDownButton.Visible and yDelta &gt; 0 then
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;if (widgetContainer.Size.Y.Offset + yDelta) &lt; 150 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,150)
&#9;&#9;&#9;&#9;control.Size = UDim2.new (0,21,0,150)
&#9;&#9;&#9;&#9;return 
&#9;&#9;&#9;end 

&#9;&#9;&#9;startYPos = y

&#9;&#9;&#9;if widgetContainer.Size.Y.Offset + yDelta &gt;= 0 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,widgetContainer.Size.Y.Offset + yDelta)
&#9;&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,control.Size.Y.Offset + yDelta )
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end

&#9;local function switchMinimize()
&#9;&#9;minimizeFrame.Visible = not minimizeFrame.Visible
&#9;&#9;if scrollable then
&#9;&#9;&#9;frame.Visible = not frame.Visible
&#9;&#9;&#9;verticalDragger.Visible = not verticalDragger.Visible
&#9;&#9;&#9;control.Visible = not control.Visible
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Visible = not widgetContainer.Visible
&#9;&#9;end

&#9;&#9;if minimizeFrame.Visible then
&#9;&#9;&#9;minimizeButton.Text = &quot;+&quot;
&#9;&#9;else
&#9;&#9;&#9;minimizeButton.Text = &quot;-&quot;
&#9;&#9;end
&#9;end

&#9;minimizeBigButton.MouseButton1Click:connect(function (  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;minimizeButton.MouseButton1Click:connect(function(  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;if scrollable then
&#9;&#9;return dragBar, frame, helpFrame, closeEvent
&#9;else
&#9;&#9;return dragBar, widgetContainer, helpFrame, closeEvent
&#9;end
end

t.Help = 
&#9;function(funcNameOrFunc) 
&#9;&#9;--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
&#9;&#9;if funcNameOrFunc == &quot;CreatePropertyDropDownMenu&quot; or funcNameOrFunc == t.CreatePropertyDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreatePropertyDropDownMenu.  &quot; ..
&#9;&#9;&#9;&#9;   &quot;Arguments: (instance, propertyName, enumType).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: returns a container with a drop-down-box that is linked to the &apos;property&apos; field of &apos;instance&apos; which is of type &apos;enumType&apos;&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateDropDownMenu&quot; or funcNameOrFunc == t.CreateDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreateDropDownMenu.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (items, onItemSelected).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: Returns 2 results, a container to the gui object and a &apos;updateSelection&apos; function for external updating.  The container is a drop-down-box created around a list of items&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateMessageDialog&quot; or funcNameOrFunc == t.CreateMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button&quot;
&#9;&#9;end&#9;&#9;
&#9;&#9;if funcNameOrFunc == &quot;CreateStyledMessageDialog&quot; or funcNameOrFunc == t.CreateStyledMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateStyledMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, style, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button, &apos;style&apos; is a string, either Error, Notify or Confirm&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;GetFontHeight&quot; or funcNameOrFunc == t.GetFontHeight then
&#9;&#9;&#9;return &quot;Function GetFontHeight.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (font, fontSize). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: returns the size in pixels of the given font + fontSize&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;LayoutGuiObjects&quot; or funcNameOrFunc == t.LayoutGuiObjects then
&#9;&#9;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateScrollingFrame&quot; or funcNameOrFunc == t.CreateScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (orderList, style) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 4 objects, (scrollFrame, scrollUpButton, scrollDownButton, recalculateFunction).  &apos;scrollFrame&apos; can be filled with GuiObjects.  It will lay them out and allow scrollUpButton/scrollDownButton to interact with them.  Orderlist is optional (and specifies the order to layout the children.  Without orderlist, it uses the children order. style is also optional, and allows for a &apos;grid&apos; styling if style is passed &apos;grid&apos; as a string.  recalculateFunction can be called when a relayout is needed (when orderList changes)&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTrueScrollingFrame&quot; or funcNameOrFunc == t.CreateTrueScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateTrueScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (nil) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (scrollFrame, controlFrame).  &apos;scrollFrame&apos; can be filled with GuiObjects, and they will be clipped if not inside the frame&apos;s bounds. controlFrame has children scrollup and scrolldown, as well as a slider.  controlFrame can be parented to any guiobject and it will readjust itself to fit.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;AutoTruncateTextObject&quot; or funcNameOrFunc == t.AutoTruncateTextObject then
&#9;&#9;&#9;return &quot;Function AutoTruncateTextObject.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (textLabel) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (textLabel, changeText).  The &apos;textLabel&apos; input is modified to automatically truncate text (with ellipsis), if it gets too small to fit.  &apos;changeText&apos; is a function that can be used to change the text, it takes 1 string as an argument&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSlider&quot; or funcNameOrFunc == t.CreateSlider then
&#9;&#9;&#9;return &quot;Function CreateSlider.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateLoadingFrame&quot; or funcNameOrFunc == t.CreateLoadingFrame then
&#9;&#9;&#9;return &quot;Function CreateLoadingFrame.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (name, size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Creates a gui that can be manipulated to show progress for a particular action.  Name appears above the loading bar, and size and position are udim2 values (both size and position are optional arguments).  Returns 3 arguments, the first being the gui created. The second being updateLoadingGuiPercent, which is a bindable function.  This function takes one argument (two optionally), which should be a number between 0 and 1, representing the percentage the loading gui should be at.  The second argument to this function is a boolean value that if set to true will tween the current percentage value to the new percentage value, therefore our third argument is how long this tween should take. Our third returned argument is a BindableEvent, that when fired means that someone clicked the cancel button on the dialog.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTerrainMaterialSelector&quot; or funcNameOrFunc == t.CreateTerrainMaterialSelector then
&#9;&#9;&#9;return &quot;Function CreateTerrainMaterialSelector.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Size and position are UDim2 values that specifies the selector&apos;s size and position.  Both size and position are optional arguments. This method returns 3 objects (terrainSelectorGui, terrainSelected, forceTerrainSelection).  terrainSelectorGui is just the gui object that we generate with this function, parent it as you like. TerrainSelected is a BindableEvent that is fired whenever a new terrain type is selected in the gui.  ForceTerrainSelection is a function that takes an argument of Enum.CellMaterial and will force the gui to show that material as currently selected.&quot;
&#9;&#9;end
&#9;end

--RBXGUI END


--rbxsig%mno74b/wRJKHL8Xt9/BxwXVZl+tc9a/CmKlTTsWwuH0ibb5lbU57AjhmG/j/sFf+k7yKL9GKKWCUdPSSH3I6N4Vg02Ru5DtokfUAKrgAAdixtQU0mSgGT3ZI/vNZjH7Dw39RzLgT4rVVyCh38B/pVg0BKcE3SdIXVdeIRPX0cb8=%
--rbxassetid%53878053%

-- A couple of necessary functions
local function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end
local function waitForProperty(instance, property)
&#9;while not instance[property] do
&#9;&#9;instance.Changed:wait()
&#9;end
end

waitForChild(game,&quot;Players&quot;)
waitForProperty(game.Players,&quot;LocalPlayer&quot;)
local player = game.Players.LocalPlayer

local RbxGui,msg = t
if not RbxGui then print(&quot;could not find RbxGui!&quot;) return end

--- Begin Locals
waitForChild(game,&quot;Players&quot;)

-- don&apos;t do anything if we are in an empty game
if #game.Players:GetChildren() &lt; 1 then
&#9;game.Players.ChildAdded:wait()
end

local tilde = &quot;~&quot;
local backquote = &quot;`&quot;
game:GetService(&quot;GuiService&quot;):AddKey(tilde) -- register our keys
game:GetService(&quot;GuiService&quot;):AddKey(backquote)

local player = game.Players.LocalPlayer

local backpack = script.Parent
local screen = script.Parent.Parent

local openCloseDebounce = false

local backpackItems = {}

local buttons = {}

local debounce = false

local guiTweenSpeed = 1

local backpackOldStateVisible = false
local browsingMenu = false

local mouseEnterCons = {}
local mouseClickCons = {}

local characterChildAddedCon = nil
local characterChildRemovedCon = nil
local backpackAddCon = nil
local humanoidDiedCon = nil
local backpackButtonClickCon = nil
local guiServiceKeyPressCon = nil

local currentLoadout = backpack.Parent.CurrentLoadout
local swapSlot = script.Parent.SwapSlot
local grid = script.Parent.Gear.GearGrid
local scroller = backpack.Gear.GearGridScrollingArea
local gearPreview = backpack.Gear.GearPreview
local playerBackpack = player.Backpack
local currentLoadout = backpack.Parent.CurrentLoadout
local backpackButton = backpack.Parent.ControlFrame.BackpackButton
local gearButton = backpack.Gear.GearGrid.GearButton
local searchBox = backpack.SearchFrame.SearchBoxFrame.SearchBox
local searchButton = backpack.SearchFrame.SearchButton
local gearPreview = backpack.Gear.GearPreview
local resetButton = backpack.SearchFrame.ResetButton



-- creating scroll bar early as to make sure items get placed correctly
local scrollFrame, scrollUp, scrollDown, recalculateScroll = RbxGui.CreateScrollingFrame(nil,&quot;grid&quot;)

scrollFrame.Position = UDim2.new(0,0,0,30)
scrollFrame.Size = UDim2.new(1,0,1,-30)
scrollFrame.Parent = grid

local scrollBar = Instance.new(&quot;Frame&quot;)
scrollBar.Name = &quot;ScrollBar&quot;
scrollBar.BackgroundTransparency = 0.9
scrollBar.BackgroundColor3 = Color3.new(1,1,1)
scrollBar.BorderSizePixel = 0
scrollBar.Size = UDim2.new(0, 17, 1, -36)
scrollBar.Position = UDim2.new(0,0,0,18)
scrollBar.Parent = scroller

scrollDown.Position = UDim2.new(0,0,1,-17)

scrollUp.Parent = scroller
scrollDown.Parent = scroller

local scrollFrameLoadout, scrollUpLoadout, scrollDownLoadout, recalculateScrollLoadout = RbxGui.CreateScrollingFrame()

scrollFrameLoadout.Position = UDim2.new(0,0,0,0)
scrollFrameLoadout.Size = UDim2.new(1,0,1,0)
scrollFrameLoadout.Parent = backpack.Gear.GearLoadouts.LoadoutsList

local LoadoutButton = Instance.new(&quot;TextButton&quot;)
LoadoutButton.Name = &quot;LoadoutButton&quot;
LoadoutButton.Font = Enum.Font.ArialBold
LoadoutButton.FontSize = Enum.FontSize.Size14
LoadoutButton.Position = UDim2.new(0,0,0,0)
LoadoutButton.Size = UDim2.new(1,0,0,32)
LoadoutButton.Style = Enum.ButtonStyle.RobloxButton
LoadoutButton.Text = &quot;Loadout #1&quot;
LoadoutButton.TextColor3 = Color3.new(1,1,1)
LoadoutButton.Parent = scrollFrameLoadout

local LoadoutButtonTwo = LoadoutButton:clone()
LoadoutButtonTwo.Text = &quot;Loadout #2&quot;
LoadoutButtonTwo.Parent = scrollFrameLoadout

local LoadoutButtonThree = LoadoutButton:clone()
LoadoutButtonThree.Text = &quot;Loadout #3&quot;
LoadoutButtonThree.Parent = scrollFrameLoadout

local LoadoutButtonFour = LoadoutButton:clone()
LoadoutButtonFour.Text = &quot;Loadout #4&quot;
LoadoutButtonFour.Parent = scrollFrameLoadout

local scrollBarLoadout = Instance.new(&quot;Frame&quot;)
scrollBarLoadout.Name = &quot;ScrollBarLoadout&quot;
scrollBarLoadout.BackgroundTransparency = 0.9
scrollBarLoadout.BackgroundColor3 = Color3.new(1,1,1)
scrollBarLoadout.BorderSizePixel = 0
scrollBarLoadout.Size = UDim2.new(0, 17, 1, -36)
scrollBarLoadout.Position = UDim2.new(0,0,0,18)
scrollBarLoadout.Parent = backpack.Gear.GearLoadouts.GearLoadoutsScrollingArea

scrollDownLoadout.Position = UDim2.new(0,0,1,-17)

scrollUpLoadout.Parent = script.Parent.Gear.GearLoadouts.GearLoadoutsScrollingArea
scrollDownLoadout.Parent = script.Parent.Gear.GearLoadouts.GearLoadoutsScrollingArea


-- Begin Functions
function removeFromMap(map,object)
&#9;for i = 1, #map do
&#9;&#9;if map[i] == object then
&#9;&#9;&#9;table.remove(map,i)
&#9;&#9;&#9;break
&#9;&#9;end
&#9;end
end

function robloxLock(instance)
end

function resize()
&#9;local size = 0
&#9;if gearPreview.AbsoluteSize.Y &gt; gearPreview.AbsoluteSize.X then
&#9;&#9;size = gearPreview.AbsoluteSize.X * 0.75
&#9;else
&#9;&#9;size = gearPreview.AbsoluteSize.Y * 0.75
&#9;end

&#9;gearPreview.GearImage.Size = UDim2.new(0,size,0,size)
&#9;gearPreview.GearImage.Position = UDim2.new(0,gearPreview.AbsoluteSize.X/2 - size/2,0.75,-size)
&#9;
&#9;resizeGrid()
end

function addToGrid(child)
&#9;if not child:IsA(&quot;Tool&quot;) then
&#9;&#9;if not child:IsA(&quot;HopperBin&quot;) then 
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end
&#9;if child:FindFirstChild(&quot;RobloxBuildTool&quot;) then return end
&#9;
&#9;for i,v in pairs(backpackItems) do  -- check to see if we already have this gear registered
&#9;&#9;if v == child then return end
&#9;end

&#9;table.insert(backpackItems,child)
&#9;
&#9;local changeCon = child.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Name&quot; then
&#9;&#9;&#9;if buttons[child] then
&#9;&#9;&#9;&#9;if buttons[child].Image == &quot;&quot; then
&#9;&#9;&#9;&#9;&#9;buttons[child].GearText.Text = child.Name
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;local ancestryCon = nil
&#9;ancestryCon = child.AncestryChanged:connect(function(theChild,theParent)
&#9;&#9;local thisObject = nil
&#9;&#9;for k,v in pairs(backpackItems) do
&#9;&#9;&#9;if v == child then
&#9;&#9;&#9;&#9;thisObject = v
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;waitForProperty(player,&quot;Character&quot;)
&#9;&#9;waitForChild(player,&quot;Backpack&quot;)
&#9;&#9;if (child.Parent ~= player.Backpack and child.Parent ~= player.Character) then
&#9;&#9;&#9;if ancestryCon then ancestryCon:disconnect() end
&#9;&#9;&#9;if changeCon then changeCon:disconnect() end
&#9;&#9;&#9;
&#9;&#9;&#9;for k,v in pairs(backpackItems) do
&#9;&#9;&#9;&#9;if v == thisObject then
&#9;&#9;&#9;&#9;&#9;if mouseEnterCons[buttons[v]] then mouseEnterCons[buttons[v]]:disconnect() end
&#9;&#9;&#9;&#9;&#9;if mouseClickCons[buttons[v]] then mouseClickCons[buttons[v]]:disconnect() end
&#9;&#9;&#9;&#9;&#9;buttons[v].Parent = nil
&#9;&#9;&#9;&#9;&#9;buttons[v] = nil
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;removeFromMap(backpackItems,thisObject)
&#9;&#9;&#9;
&#9;&#9;&#9;resizeGrid()
&#9;&#9;else
&#9;&#9;&#9;resizeGrid()
&#9;&#9;end
&#9;&#9;updateGridActive()
&#9;end)
&#9;resizeGrid()
end

function buttonClick(button)
&#9;if button:FindFirstChild(&quot;UnequipContextMenu&quot;) and not button.Active then
&#9;&#9;button.UnequipContextMenu.Visible = true
&#9;&#9;browsingMenu = true
&#9;end
end

function previewGear(button)
&#9;if not browsingMenu then
&#9;&#9;gearPreview.GearImage.Image = button.Image
&#9;&#9;gearPreview.GearStats.GearName.Text = button.GearReference.Value.Name
&#9;end
end

function checkForSwap(button,x,y)
&#9;local loadoutChildren = currentLoadout:GetChildren()
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) and string.find(loadoutChildren[i].Name,&quot;Slot&quot;) then
&#9;&#9;&#9;if x &gt;= loadoutChildren[i].AbsolutePosition.x and x &lt;= (loadoutChildren[i].AbsolutePosition.x + loadoutChildren[i].AbsoluteSize.x) then
&#9;&#9;&#9;&#9;if y &gt;= loadoutChildren[i].AbsolutePosition.y and y &lt;= (loadoutChildren[i].AbsolutePosition.y + loadoutChildren[i].AbsoluteSize.y) then
&#9;&#9;&#9;&#9;&#9;local slot = tonumber(string.sub(loadoutChildren[i].Name,5))
&#9;&#9;&#9;&#9;&#9;swapGearSlot(slot,button)
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return false
end

function resizeGrid()
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if not v:FindFirstChild(&quot;RobloxBuildTool&quot;) then
&#9;&#9;&#9;if not buttons[v] then
&#9;&#9;&#9;&#9;local buttonClone = gearButton:clone()
&#9;&#9;&#9;&#9;buttonClone.Parent = grid.ScrollingFrame
&#9;&#9;&#9;&#9;buttonClone.Visible = true
&#9;&#9;&#9;&#9;buttonClone.Image = v.TextureId
&#9;&#9;&#9;&#9;if buttonClone.Image == &quot;&quot; then
&#9;&#9;&#9;&#9;&#9;buttonClone.GearText.Text = v.Name
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;buttonClone.GearReference.Value = v
&#9;&#9;&#9;&#9;buttonClone.Draggable = true 
&#9;&#9;&#9;&#9;buttons[v] = buttonClone
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local unequipMenu = getGearContextMenu()
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;unequipMenu.Visible = false
&#9;&#9;&#9;&#9;unequipMenu.Parent = buttonClone
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local beginPos = nil
&#9;&#9;&#9;&#9;buttonClone.DragBegin:connect(function(value)
&#9;&#9;&#9;&#9;&#9;buttonClone.ZIndex = 9
&#9;&#9;&#9;&#9;&#9;beginPos = value
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;buttonClone.DragStopped:connect(function(x,y)
&#9;&#9;&#9;&#9;&#9;if beginPos ~= buttonClone.Position then
&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.ZIndex = 1
&#9;&#9;&#9;&#9;&#9;&#9;if not checkForSwap(buttonClone,x,y) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone:TweenPosition(beginPos,Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.5, true)
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.Position = beginPos
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end&#9;
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;mouseEnterCons[buttonClone] = buttonClone.MouseEnter:connect(function() previewGear(buttonClone) end)
&#9;&#9;&#9;&#9;mouseClickCons[buttonClone] = buttonClone.MouseButton1Click:connect(function() buttonClick(buttonClone) end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;recalculateScroll()
end

function showPartialGrid(subset)


&#9;for k,v in pairs(buttons) do
&#9;&#9;v.Parent = nil
&#9;end
&#9;for k,v in pairs(subset) do
&#9;&#9;v.Parent =  grid.ScrollingFrame
&#9;end
&#9;recalculateScroll()
end

function showEntireGrid()
&#9;
&#9;for k,v in pairs(buttons) do
&#9;&#9;v.Parent = grid.ScrollingFrame
&#9;end
&#9;recalculateScroll()
end

function inLoadout(gear)
&#9;local children = currentLoadout:GetChildren()
&#9;for i = 1, #children do
&#9;&#9;if children[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;local button = children[i]:GetChildren()
&#9;&#9;&#9;if #button &gt; 0 then
&#9;&#9;&#9;&#9;if button[1].GearReference.Value and button[1].GearReference.Value == gear then
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return false
end&#9;

function updateGridActive()
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if buttons[v] then
&#9;&#9;&#9;local gear = nil
&#9;&#9;&#9;local gearRef = buttons[v]:FindFirstChild(&quot;GearReference&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;if gearRef then gear = gearRef.Value end
&#9;&#9;&#9;
&#9;&#9;&#9;if not gear then
&#9;&#9;&#9;&#9;buttons[v].Active = false
&#9;&#9;&#9;elseif inLoadout(gear) then
&#9;&#9;&#9;&#9;buttons[v].Active = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;buttons[v].Active = true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function centerGear(loadoutChildren)
&#9;local gearButtons = {}
&#9;local lastSlotAdd = nil
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) and #loadoutChildren[i]:GetChildren() &gt; 0 then
&#9;&#9;&#9;if loadoutChildren[i].Name == &quot;Slot0&quot; then 
&#9;&#9;&#9;&#9;lastSlotAdd = loadoutChildren[i]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;table.insert(gearButtons, loadoutChildren[i])
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;if lastSlotAdd then table.insert(gearButtons,lastSlotAdd) end
&#9;
&#9;local startPos = ( 1 - (#gearButtons * 0.1) ) / 2
&#9;for i = 1, #gearButtons do&#9;
&#9;&#9;gearButtons[i]:TweenPosition(UDim2.new(startPos + ((i - 1) * 0.1),0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.25, true)
&#9;end
end

function spreadOutGear(loadoutChildren)
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;local slot = tonumber(string.sub(loadoutChildren[i].Name,5))
&#9;&#9;&#9;if slot == 0 then slot = 10 end
&#9;&#9;&#9;loadoutChildren[i]:TweenPosition(UDim2.new((slot - 1)/10,0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.25, true)
&#9;&#9;end
&#9;end
end

function openCloseBackpack()
&#9;if backpack.Visible == true then
&#9;&#9;updateGridActive()
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;loadoutChildren = currentLoadout:GetChildren()
&#9;&#9;&#9;&#9;for i = 1, #loadoutChildren do
&#9;&#9;&#9;&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;loadoutChildren[i].BackgroundTransparency = 0.5
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;spreadOutGear(loadoutChildren)

&#9;&#9;--[[backpackButton.Selected = true
&#9;&#9;backpack:TweenSizeAndPosition(UDim2.new(0.55, 0, 0.6, 0),UDim2.new(0.225, 0, 0.2, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, guiTweenSpeed/2, true)
&#9;&#9;delay(guiTweenSpeed/2 + 0.01,
&#9;&#9;&#9;function()--]]
&#9;&#9;&#9;&#9;local children = backpack:getChildren()
&#9;&#9;&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;&#9;&#9;if children[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;children[i].Visible = true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;resizeGrid()
&#9;&#9;&#9;&#9;resize()
&#9;&#9;&#9;&#9;openCloseDebounce = false


&#9;end
end

function loadoutCheck(child, selectState)
&#9;if not child:IsA(&quot;ImageButton&quot;) then return end
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if buttons[v] then
&#9;&#9;&#9;if child:FindFirstChild(&quot;GearReference&quot;) then
&#9;&#9;&#9;&#9;if buttons[v].GearReference.Value == child.GearReference.Value then
&#9;&#9;&#9;&#9;&#9;buttons[v].Active = selectState
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function clearPreview()
&#9;gearPreview.GearImage.Image = &quot;&quot;
&#9;gearPreview.GearStats.GearName.Text = &quot;&quot;
end

function removeAllEquippedGear(physGear)
&#9;local stuff = player.Character:GetChildren()
&#9;for i = 1, #stuff do
&#9;&#9;if ( stuff[i]:IsA(&quot;Tool&quot;) or stuff[i]:IsA(&quot;HopperBin&quot;) ) and stuff[i] ~= physGear then
&#9;&#9;&#9;stuff[i].Parent = playerBackpack
&#9;&#9;end
&#9;end
end

function equipGear(physGear)
&#9;removeAllEquippedGear(physGear)
&#9;physGear.Parent = player.Character
&#9;updateGridActive()
end

function unequipGear(physGear)
&#9;physGear.Parent = playerBackpack
&#9;updateGridActive()
end

function highlight(button)
&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;button.BackgroundColor3 = Color3.new(0.8,0.8,0.8)
end
function clearHighlight(button)
&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;button.BackgroundColor3 = Color3.new(0,0,0)
end

function swapGearSlot(slot,gearButton)
&#9;if not swapSlot.Value then -- signal loadout to swap a gear out
&#9;&#9;swapSlot.Slot.Value = slot
&#9;&#9;swapSlot.GearButton.Value = gearButton
&#9;&#9;swapSlot.Value = true
&#9;&#9;updateGridActive()
&#9;end
end


local UnequipGearMenuClick = function(element, menu)
&#9;if type(element.Action) ~= &quot;number&quot; then return end
&#9;local num = element.Action
&#9;if num == 1 then -- remove from loadout
&#9;&#9;unequipGear(menu.Parent.GearReference.Value)
&#9;&#9;local inventoryButton = menu.Parent
&#9;&#9;local gearToUnequip = inventoryButton.GearReference.Value
&#9;&#9;local loadoutChildren = currentLoadout:GetChildren()
&#9;&#9;local slot = -1
&#9;&#9;for i = 1, #loadoutChildren do
&#9;&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;local button = loadoutChildren[i]:GetChildren()
&#9;&#9;&#9;&#9;if button[1] and button[1].GearReference.Value == gearToUnequip then
&#9;&#9;&#9;&#9;&#9;slot = button[1].SlotNumber.Text
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;swapGearSlot(slot,nil)
&#9;end
end

-- these next two functions are used to stop any use of backpack while the player is dead (can cause issues)
function activateBackpack()
&#9;backpack.Visible = backpackOldStateVisible
&#9;
&#9;backpackButtonClickCon = backpackButton.MouseButton1Click:connect(function() openCloseBackpack() end)
&#9;guiServiceKeyPressCon = game:GetService(&quot;GuiService&quot;).KeyPressed:connect(function(key)
&#9;&#9;if key == tilde or key == backquote then
&#9;&#9;&#9;openCloseBackpack()
&#9;&#9;end
&#9;end)
end
function deactivateBackpack()
&#9;if backpackButtonClickCon then backpackButtonClickCon:disconnect() end
&#9;if guiServiceKeyPressCon then guiServiceKeyPressCon:disconnect() end

&#9;backpackOldStateVisible = backpack.Visible
&#9;backpack.Visible = false
end

function setupCharacterConnections()

&#9;if backpackAddCon then backpackAddCon:disconnect() end
&#9;backpackAddCon = game.Players.LocalPlayer.Backpack.ChildAdded:connect(function(child) addToGrid(child) end)
&#9;
&#9;-- make sure we get all the children
&#9;local backpackChildren = game.Players.LocalPlayer.Backpack:GetChildren()
&#9;for i = 1, #backpackChildren do
&#9;&#9;addToGrid(backpackChildren[i])
&#9;end

&#9;if characterChildAddedCon then characterChildAddedCon:disconnect() end
&#9;characterChildAddedCon = 
&#9;&#9;game.Players.LocalPlayer.Character.ChildAdded:connect(function(child)
&#9;&#9;&#9;addToGrid(child)
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;&#9;
&#9;if characterChildRemovedCon then characterChildRemovedCon:disconnect() end
&#9;characterChildRemovedCon = 
&#9;&#9;game.Players.LocalPlayer.Character.ChildRemoved:connect(function(child)
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;&#9;
&#9;&#9;&#9;
&#9;if humanoidDiedCon then humanoidDiedCon:disconnect() end
&#9;local localPlayer = game.Players.LocalPlayer
&#9;waitForProperty(localPlayer,&quot;Character&quot;)
&#9;waitForChild(localPlayer.Character,&quot;Humanoid&quot;)
&#9;humanoidDiedCon = game.Players.LocalPlayer.Character.Humanoid.Died:connect(function() deactivateBackpack() end)
&#9;
&#9;activateBackpack()
end

function removeCharacterConnections()
&#9;if characterChildAddedCon then characterChildAddedCon:disconnect() end
&#9;if characterChildRemovedCon then characterChildRemovedCon:disconnect() end
&#9;if backpackAddCon then backpackAddCon:disconnect() end
end

function trim(s)
  return (s:gsub(&quot;^%s*(.-)%s*$&quot;, &quot;%1&quot;))
end

function splitByWhiteSpace(text)
&#9;if type(text) ~= &quot;string&quot; then return nil end
&#9;
&#9;local terms = {}
&#9;for token in string.gmatch(text, &quot;[^%s]+&quot;) do
&#9;   if string.len(token) &gt; 2 then
&#9;&#9;&#9;table.insert(terms,token)
&#9;   end
&#9;end
&#9;return terms
end

function filterGear(searchTerm)
&#9;string.lower(searchTerm)
&#9;searchTerm = trim(searchTerm)
&#9;if string.len(searchTerm) &lt; 2 then return nil end
&#9;local terms = splitByWhiteSpace(searchTerm)
&#9;
&#9;local filteredGear = {}
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if buttons[v] then
&#9;&#9;&#9;local gearString = string.lower(buttons[v].GearReference.Value.Name)
&#9;&#9;&#9;gearString = trim(gearString)
&#9;&#9;&#9;for i = 1, #terms do
&#9;&#9;&#9;&#9;if string.match(gearString,terms[i]) then
&#9;&#9;&#9;&#9;&#9;table.insert(filteredGear,buttons[v])
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;return filteredGear
end


function showSearchGear()
   local searchBox = backpack.SearchFrame.SearchBoxFrame.SearchBox
&#9;local searchText = searchBox.Text
&#9;searchBox.Text = &quot;Search...&quot;
&#9;local filteredButtons = filterGear(searchText)
&#9;if filteredButtons and #filteredButtons &gt; 0 then
&#9;&#9;showPartialGrid(filteredButtons)
&#9;else
&#9;&#9;showEntireGrid()
&#9;end
end

function nukeBackpack()
&#9;while #buttons &gt; 0 do
&#9;&#9;table.remove(buttons)
&#9;end
&#9;buttons = {}
&#9;while #backpackItems &gt; 0 do
&#9;&#9;table.remove(backpackItems)
&#9;end
&#9;backpackItems = {}
&#9;local scrollingFrameChildren = grid.ScrollingFrame:GetChildren()
&#9;for i = 1, #scrollingFrameChildren do
&#9;&#9;scrollingFrameChildren[i]:remove()
&#9;end
end

function getGearContextMenu()
&#9;local gearContextMenu = Instance.new(&quot;Frame&quot;)
&#9;gearContextMenu.Active = true
&#9;gearContextMenu.Name = &quot;UnequipContextMenu&quot;
&#9;gearContextMenu.Size = UDim2.new(0,115,0,70)
&#9;gearContextMenu.Position = UDim2.new(0,-16,0,-16)
&#9;gearContextMenu.BackgroundTransparency = 1
&#9;gearContextMenu.Visible = false

&#9;local gearContextMenuButton = Instance.new(&quot;TextButton&quot;)
&#9;gearContextMenuButton.Name = &quot;UnequipContextMenuButton&quot;
&#9;gearContextMenuButton.Text = &quot;&quot;
&#9;gearContextMenuButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;gearContextMenuButton.ZIndex = 4
&#9;gearContextMenuButton.Size = UDim2.new(1, 0, 1, -20)
&#9;gearContextMenuButton.Visible = true
&#9;gearContextMenuButton.Parent = gearContextMenu
&#9;
&#9;local elementHeight = 12
&#9;
&#9;local contextMenuElements = {}&#9;&#9;
&#9;local contextMenuElementsName = {&quot;Remove Hotkey&quot;}

&#9;for i = 1, #contextMenuElementsName do
&#9;&#9;local element = {}
&#9;&#9;element.Type = &quot;Button&quot;
&#9;&#9;element.Text = contextMenuElementsName[i]
&#9;&#9;element.Action = i
&#9;&#9;element.DoIt = UnequipGearMenuClick
&#9;&#9;table.insert(contextMenuElements,element)
&#9;end

&#9;for i, contextElement in ipairs(contextMenuElements) do
&#9;&#9;local element = contextElement
&#9;&#9;if element.Type == &quot;Button&quot; then
&#9;&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;button.Name = &quot;UnequipContextButton&quot; .. i
&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;button.BorderSizePixel = 0
&#9;&#9;&#9;button.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;button.Text = &quot; &quot; .. contextElement.Text
&#9;&#9;&#9;button.Font = Enum.Font.Arial
&#9;&#9;&#9;button.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;button.Size = UDim2.new(1, 8, 0, elementHeight)
&#9;&#9;&#9;button.Position = UDim2.new(0,0,0,elementHeight * i)
&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;button.ZIndex = 4
&#9;&#9;&#9;button.Parent = gearContextMenuButton

&#9;&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;if button.Active and not gearContextMenu.Parent.Active then
&#9;&#9;&#9;&#9;&#9;local success, result = pcall(function() element.DoIt(element, gearContextMenu) end)
&#9;&#9;&#9;&#9;&#9;browsingMenu = false
&#9;&#9;&#9;&#9;&#9;gearContextMenu.Visible = false
&#9;&#9;&#9;&#9;&#9;clearHighlight(button)
&#9;&#9;&#9;&#9;&#9;clearPreview()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;if button.Active and gearContextMenu.Parent.Active then
&#9;&#9;&#9;&#9;&#9;highlight(button)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;if button.Active and gearContextMenu.Parent.Active then
&#9;&#9;&#9;&#9;&#9;clearHighlight(button)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;contextElement.Button = button
&#9;&#9;&#9;contextElement.Element = button
&#9;&#9;elseif element.Type == &quot;Label&quot; then
&#9;&#9;&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;frame.Name = &quot;ContextLabel&quot; .. i
&#9;&#9;&#9;frame.BackgroundTransparency = 1
&#9;&#9;&#9;frame.Size = UDim2.new(1, 8, 0, elementHeight)

&#9;&#9;&#9;local label = Instance.new(&quot;TextLabel&quot;)&#9;
&#9;&#9;&#9;label.Name = &quot;Text1&quot;
&#9;&#9;&#9;label.BackgroundTransparency = 1
&#9;&#9;&#9;label.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;label.BorderSizePixel = 0
&#9;&#9;&#9;label.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;label.Font = Enum.Font.ArialBold
&#9;&#9;&#9;label.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;label.Position = UDim2.new(0.0, 0, 0, 0)
&#9;&#9;&#9;label.Size = UDim2.new(0.5, 0, 1, 0)
&#9;&#9;&#9;label.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;label.ZIndex = 4
&#9;&#9;&#9;label.Parent = frame
&#9;&#9;&#9;element.Label1 = label
&#9;&#9;
&#9;&#9;&#9;if element.GetText2 then
&#9;&#9;&#9;&#9;label = Instance.new(&quot;TextLabel&quot;)&#9;
&#9;&#9;&#9;&#9;label.Name = &quot;Text2&quot;
&#9;&#9;&#9;&#9;label.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;label.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;label.BorderSizePixel = 0
&#9;&#9;&#9;&#9;label.TextXAlignment = Enum.TextXAlignment.Right
&#9;&#9;&#9;&#9;label.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;label.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;&#9;label.Position = UDim2.new(0.5, 0, 0, 0)
&#9;&#9;&#9;&#9;label.Size = UDim2.new(0.5, 0, 1, 0)
&#9;&#9;&#9;&#9;label.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;label.ZIndex = 4
&#9;&#9;&#9;&#9;label.Parent = frame
&#9;&#9;&#9;&#9;element.Label2 = label
&#9;&#9;&#9;end
&#9;&#9;&#9;frame.Parent = gearContextMenuButton
&#9;&#9;&#9;element.Label = frame
&#9;&#9;&#9;element.Element =  frame
&#9;&#9;end
&#9;end

&#9;gearContextMenu.ZIndex = 4
&#9;gearContextMenu.MouseLeave:connect(function()
&#9;&#9;browsingMenu = false
&#9;&#9;gearContextMenu.Visible = false
&#9;&#9;clearPreview()
&#9;end)
&#9;robloxLock(gearContextMenu)
&#9;
&#9;return gearContextMenu
end

local backpackChildren = player.Backpack:GetChildren()
for i = 1, #backpackChildren do
&#9;addToGrid(backpackChildren[i])
end

------------------------- Start Lifelong Connections -----------------------
screen.Changed:connect(function(prop)
&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;if debounce then return end
&#9;&#9;debounce = true
&#9;&#9;wait()
&#9;&#9;resize()
&#9;&#9;resizeGrid()
&#9;&#9;debounce = false
&#9;end
end)

currentLoadout.ChildAdded:connect(function(child) loadoutCheck(child, false) end)
currentLoadout.ChildRemoved:connect(function(child) loadoutCheck(child, true) end)

grid.MouseEnter:connect(function() clearPreview() end)
grid.MouseLeave:connect(function() clearPreview() end)

player.CharacterRemoving:connect(function()
&#9;removeCharacterConnections()
&#9;nukeBackpack()
end)
player.CharacterAdded:connect(function() setupCharacterConnections() end)

player.ChildAdded:connect(function(child)
&#9;if child:IsA(&quot;Backpack&quot;) then
&#9;&#9;playerBackpack = child
&#9;&#9;if backpackAddCon then backpackAddCon:disconnect() end
&#9;&#9;backpackAddCon = game.Players.LocalPlayer.Backpack.ChildAdded:connect(function(child) addToGrid(child) end)
&#9;end
end)

swapSlot.Changed:connect(function()
&#9;if not swapSlot.Value then
&#9;&#9;updateGridActive()
&#9;end
end)

searchBox.FocusLost:connect(function(enterPressed)
&#9;if enterPressed then
&#9;&#9;showSearchGear()
&#9;end
end)

local loadoutChildren = currentLoadout:GetChildren()
for i = 1, #loadoutChildren do
&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) and string.find(loadoutChildren[i].Name,&quot;Slot&quot;) then
&#9;&#9;loadoutChildren[i].ChildRemoved:connect(function()
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;&#9;loadoutChildren[i].ChildAdded:connect(function()
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;end
end

searchButton.MouseButton1Click:connect(function() showSearchGear() end)
------------------------- End Lifelong Connections -----------------------

resize()
resizeGrid()

-- make sure any items in the loadout are accounted for in inventory
local loadoutChildren = currentLoadout:GetChildren()
for i = 1, #loadoutChildren do
&#9;loadoutCheck(loadoutChildren[i], false)
end

-- make sure that inventory is listening to gear reparenting
if characterChildAddedCon == nil and game.Players.LocalPlayer[&quot;Character&quot;] then
&#9;setupCharacterConnections()
end
if not backpackAddCon then
&#9;backpackAddCon = game.Players.LocalPlayer.Backpack.ChildAdded:connect(function(child) addToGrid(child) end)
end


&#9;backpackButton.Visible = true


recalculateScrollLoadout()</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX11">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Workaround</string>
					<ProtectedString name="Source">wait(0.1)
game.Players.LocalPlayer.PlayerGui.Backpack.BackpackResizer.Disabled = true
game.Players.LocalPlayer.PlayerGui.Backpack.BackpackResizer.Disabled = false
game.Players.LocalPlayer.PlayerGui.Backpack.CurrentLoadout.Visible = true</ProtectedString>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>